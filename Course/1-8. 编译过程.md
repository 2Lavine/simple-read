# webpack 编译过程 {ignore}

整个过程大致分为三个步骤

1. 初始化
2. 编译
3. 输出

## 初始化

此阶段，webpack会将**CLI参数**、**配置文件**、**默认配置**进行融合，形成一个最终的配置对象。

对配置的处理过程是依托一个第三方库```yargs```完成的

## 编译

1. **创建chunk**

chunk是webpack在内部构建过程中的一个概念，译为```块```，它表示通过某个入口找到的所有依赖的统称。

根据入口模块（默认为```./src/index.js```）创建一个chunk

每个chunk都有至少两个属性：
- name：默认为main
- id：唯一编号，开发环境和name相同，生产环境是一个数字，从0开始

2. **构建所有依赖模块**
    1. 读取文件,并且变成 ast 树
    3. 记录依赖并且替代依赖的函数
        4. 如 require 会被替换成 __webpack_require__
    5. 用列表保存替代后的函数和对应的 id
    5. 深度递归所依赖的模块,重复以上步骤

3. **产生chunk assets**

在第二步完成后，chunk中会产生一个模块列表，
- 列表中包含了**模块id**和**模块转换后的代码**

接下来，webpack会根据配置为chunk生成一个资源列表，
- 即```chunk assets```，资源列表可以理解为是生成到最终文件的文件名和文件内容
chunk hash是根据所有chunk assets的内容生成的一个hash字符串

4. **合并chunk assets**

将多个chunk的assets合并到一起，并产生一个总的hash

## 输出

此步骤非常简单，webpack将利用node中的fs模块（文件处理模块），根据编译产生的总的assets，生成相应的文件。

![](assets/2020-01-09-12-54-34.png)


**涉及术语**

1. module：模块，分割的代码单元，webpack中的模块可以是任何内容的文件，不仅限于JS
2. chunk：webpack内部构建模块的块，一个chunk中包含多个模块，这些模块是从入口模块通过依赖分析得来的
3. bundle：chunk构建好模块后会生成chunk的资源清单，清单中的每一项就是一个bundle，可以认为bundle就是最终生成的文件
4. hash：最终的资源清单所有内容联合生成的hash值
5. chunkhash：chunk生成的资源清单内容联合生成的hash值
6. chunkname：chunk的名称，如果没有配置则使用main
7. id：通常指chunk的唯一编号，如果在开发环境下构建，和chunkname相同；如果是生产环境下构建，则使用一个从0开始的数字进行编号