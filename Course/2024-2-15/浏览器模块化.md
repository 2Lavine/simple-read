# 如何在浏览器端实现模块化 {ignore}

## 浏览器端的模块化问题：

- 效率问题：模块划分带来了更多的JS文件，在服务器端的模块化更多的JS文件带来了更多的请求，降低了页面访问效率
- 兼容性问题：浏览器目前仅支持ES6的模块化标准，并且还存在兼容性问题
  - 不支持 commonjs导出的包，如 axios 仅仅支持 commoJS 的导出因此不能使用
  - 不支持裸导入，必须以 /,./ ,../开头

- 工具问题：浏览器不支持npm下载的第三方包

## 浏览器端的模块化问题根本原因

思考：上面提到的问题，为什么在node端没有那么明显，反而到了浏览器端变得如此严重呢？

答：在node端，运行的JS文件在本地，因此可以本地读取文件，它的效率比浏览器远程传输文件高的多

**根本原因**：在浏览器端，开发时态（devtime）和运行时态（runtime）的侧重点不一样

**开发时态，devtime：**

1. 模块划分越细越好
2. 支持多种模块化标准
3. 支持npm或其他包管理器下载的模块
4. 能够解决其他工程化的问题

**运行时态，runtime：**

1. 文件越少越好
2. 文件体积越小越好
3. 代码内容越乱越好
4. 所有浏览器都要兼容
5. 能够解决其他运行时的问题，主要是执行效率问题

## 解决办法

既然开发时态和运行时态面临的局面有巨大的差异，因此，我们需要有一个工具，这个工具能够让开发者专心的在开发时态写代码，然后利用这个工具将开发时态编写的代码转换为运行时态需要的东西。

这样的工具，叫做**构建工具**

这样一来，开发者就可以专注于开发时态的代码结构，而不用担心运行时态遇到的问题了。

## 常见的构建工具

- **webpack**
- grunt
- gulp
- browserify
- fis
- 其他