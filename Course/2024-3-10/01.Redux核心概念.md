# Redux核心概念

action  reducer  store

## MVC

它是一个UI的解决方案，用于降低UI，以及UI关联的数据的复杂度。

## **传统的服务器端的**服务端渲染

![](https://raw.githubusercontent.com/2Lavine/ImgRep/main/img/2024/03/10/2019-08-20-13-18-58_21-30-11.png)

环境：
1. 服务端需要响应一个完整的HTML
2. 该HTML中包含页面需要的数据
3. 浏览器仅承担渲染页面的作用
以上的这种方式叫做**服务端渲染**，即服务器端将完整的页面组装好之后，一起发送给客户端。
服务器端需要处理UI中要用到的数据，并且要将数据嵌入到页面中，最终生成一个完整的HTML页面响应。

## 服务端MVC模式
为了降低处理这个过程的复杂度，出现了MVC模式。

![](https://raw.githubusercontent.com/2Lavine/ImgRep/main/img/2024/03/10/2019-08-20-13-29-14_21-30-11.png)

**Controller**: 处理请求，判断是否成功组装这次请求需要的数据
**Model**：需要用于UI渲染的数据模型
**View**：视图，用于将模型组装到界面中

View视图层组装过于复杂，后面 View 层由专门的前端开发负责，进行了前后端分离。
- 前端不在服务器端而是在客户端
由此产生了 MVVM 模式，从数据出发来产生页面

## **前端MVC模式
controller层面
1. 前端中的controller处理的是用户的操作，而用户的操作场景是复杂的。
	1. 这比服务端的复杂很多，服务端仅仅是针对不同请求进行处理

Model 数据层面
对于那些组件化的框架（比如vue、react），它们使用的是单向数据流。
2. 若需要共享数据，则必须将数据提升到顶层组件，然后数据再一层一层传递，极其繁琐。 
	1. 虽然可以使用上下文来提供共享数据，但对数据的操作难以监控，容易导致调试错误的困难，以及数据还原的困难。
	2. 并且，若开发一个大中型项目，共享的数据很多，会导致上下文中的数据变得非常复杂。
比如，上下文中有如下格式的数据：
```js
value = {
    users:[{},{},{}],
    addUser: function(u){},
    deleteUser: function(u){},
    updateUser: function(u){}
}
```
因此前端需要一个前端需要一个独立的数据解决方案，即解决 control ler 和 model 

## 前端需要一个独立的数据解决方案

**Flux** 数据解决方案，它的最大历史意义，在于它引入了action的概念
- 服务端的controller 是可以通过 url 和方法名来确定分类
- 我们把用户的操作抽象为对应的 action 来确定分类

action是一个普通的对象，用于描述要干什么。
- **action是触发数据变化的唯一原因**
store表示数据仓库，用于存储共享数据。
- 可以根据不同的action更改仓库中的数据

示例：
```js
var loginAction = {
    type: "login",
    payload: {
        loginId:"admin",
        loginPwd:"123123"
    }
}

var deleteAction = {
    type: "delete",
    payload: 1  // 用户id为1
}
```

在Flux基础上，Redux引入了reducer的概念
reducer：处理器，用于根据action来处理数据，处理后的数据会被仓库重新保存。
- reducer 就是相当于服务器端的 controller
- action 就是请求地址和方法，用来区分不同的操作
![](https://raw.githubusercontent.com/2Lavine/ImgRep/main/img/2024/03/10/2019-08-20-14-23-05_21-30-11.png)