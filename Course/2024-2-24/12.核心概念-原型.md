# 原型

## 原型要解决的问题

<img src="http://mdrs.yuanjin.tech/img/20211210142340.png" alt="image-20211210142340406" style="zoom:50%;" />

上图中通过构造函数可以创建一个用户对象

这种做法有一个严重的缺陷，就是每个用户对象中都拥有一个`sayHi`方法，对于每个用户而言，`sayHi`方法是完全一样的，没必要为每个用户单独生成一个。

这可以通过原型来解决，我们把方法赋值到构造函数的 prototype 上，让所有实例共享

## 原型是如何解决的

<img src="http://mdrs.yuanjin.tech/img/20211210141850.png" alt="image-20211210141850465" style="zoom:50%;" />

1. **原型**

   每个函数都会自动附带一个属性`prototype`，这个属性的值是一个普通对象，称之为原型对象

2. **实例**

   instance，通过`new`产生的对象称之为实例。

   > 由于 JS 中所有对象都是通过`new`产生的，因此，严格来说，JS 中所有对象都称之为实例

3. **隐式原型**

   每个实例都拥有一个特殊的属性`__proto__`，称之为隐式原型，它指向构造函数的原型

## 公共函数共享(在构造函数上使用原型)

我们在在构造函数上使用原型

**当访问实例成员时，先找自身，如果不存在，会自动从隐式原型中寻找**

**这样一来，我们可以把那些公共成员，放到函数的原型中，即可被所有实例共享**

<img src="http://mdrs.yuanjin.tech/img/20211210143328.png" alt="image-20211210143328533" style="zoom:50%;" />

## 检验是在原型链上的还是在对象本身上的

obj.hasOwnProperty('name') // 检查 obj 本身
name in obj // 检查 obj 本身和原型链上 
