

# catch方法

`.catch(onRejected)` = `.then(null, onRejected)`

# 链式调用

![image-20210621103501094](http://mdrs.yuanjin.tech/img/20210621103501.png)

1. then方法必定会返回一个新的Promise

   可理解为`后续处理也是一个任务`

2. 新的Promise的状态取决于后续处理：后续处理即 then 的onFulfilled或者 onRejected的函数

   - 若没有相关的后续处理，新任务的状态和前任务一致，数据为前任务的数据
     - 没有后续处理即 then 方法没有传入对应的onFulfilled或者 onRejected的后续处理函数
   
     - 这样设计可以让我们在 then 中不处理 onRejected而是在后面调用 catch 方法来处理
       - 这样 catch 可以捕捉前面所有的错误
   
   - 若有后续处理但还未执行，新任务挂起（也就是 pending 状态）。
   - 若后续处理执行了，则根据后续处理的情况确定新任务的状态
     - 后续处理返回的不是 promise 对象
       - 后续处理执行无错，新任务的状态为完成，数据为后续处理的返回值
       - 后续处理执行有错，新任务的状态为失败，数据为异常对象
     - 后续执行后返回的是一个promise对象，
       - 新任务的状态和数据与该promise对象一致

由于链式任务的存在，异步代码拥有了更强的表达力

```js
// 常见任务处理代码

/*
 * 任务成功后，执行处理1，失败则执行处理2
 */
pro.then(处理1).catch(处理2)

/*
 * 任务成功后，依次执行处理1、处理2
 */
pro.then(处理1).then(处理2)

/*
 * 任务成功后，依次执行处理1、处理2，若任务失败或前面的处理有错，执行处理3
 */
pro.then(处理1).then(处理2).catch(处理3)
```

