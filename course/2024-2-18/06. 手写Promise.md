手写 Promise 课程资料，仅提供最终的完整代码

至于每节课的代码，请同学们理解视频课程内容，然后自行手写，以达到最好的学习效果



## 状态变化

1. class 中私有的属性方法 下划线\_ 开头
2. 我们写 promise 方法中 resolve 和 reject 是直接调用的,因此 this 指向全局对象，
   1. 但我们希望 resolve 的时候改变返回的promise状态，因此 我们要对 resolve 进行 bind操作

3. constuctor 中对 error 进行 catch



## then 函数

1. Params： 2 个函数  Return：一个新的 Promise

3. then 链式调用时，由于我们无法判断合适执行对应的后续操作函数（onFulfuilled函数），因此我们在 then 中用一个队列把所有对应的函数收集起来. 在发生状态改变的时候执行对应的函数

4. 由于then 函数返回的 Promise 的状态改变和then 里面的操作函数相关，因此我们将 Promise 的 resolve 和 reject也和对应的操作函数一起收集起来

   

   我们可以得到一个handler对象，存储了这些值。 把所有的 handler 存储到队列中

   ```js
   {
     exector:fn
     state:"fulfilled"
     _resolve:resolve,
   }
   ```

   具体执行 onFulfuilled 函数的时候要注意用结构的语法，否则会改变 this 的指向

Pro.then(fn1,fn2)

Pro.then(fn3.fn4)

Promise 支持同一个 promise 调用多个 then 方法，因此在任务改变的时候我们需要对所有这些操作进行处理



## 什么时候handler队列

- 在 State 状态发生改变的时候我们会执行对应的 then 队列（异步任务）

- 也有可能之前的 promise 直接返回一个 resolved 的任务（同步），因此也需要在then方法内执行对应的队列



## 如何遍历handler执行代码

我们仅仅会在非 pending 下执行对应的后续处理任务

我们在执行完对应的操作之后需要将对应操作删除

```js
for (const item of arr){
  console.log(item)
  arr.shift()
}
这个方法并不能删除所有 arr，因为item 实际上指向的是 arr 的第 i 个元素。 shift 之后会改变当前 item 的取值
while (this._handlers[0]) {
  const handler = this._handlers[0];
  this._runOneHandler(handler);
  this._handlers.shift();
}

```

## 处理一个handler

1. 处理具体的 handler 时我们要把这个放到微队列当中
   1. node 环境下 通过process.nextTick（fn） 把 fn 插入到微队列
   2. browser 环境下 通过 MutationObserver 把 fn 插入到微队列
2. 由于有两个状态的 handler 要对状态进行匹配
3. 如果 handler 不是函数，我们要将当前的 promise 状态和数据进行传递
   1. 根据状态调用then返回对应Promise的 resolve 还是 reject
4. 如果当前 handler 是函数
   1. 如果返回结果是 promise，则把resolve和 reject传递给当前的promise ，让返回结果觉得
   2. 如果返回结果不是 promise 则resolve 对应的结果

## 判断是否是 Promise

Obj是一个对象，且 obj.then是是一个函数



## finally

无论成功还是失败都会执行，而且返回调用 finally 的 Promise的状态和数据

如 p1.finally(fn)  的状态和数据 和p1相同



## Promise.resolve

特殊情况：

1. 传递的data本身就是ES6的Promise对象,则直接返回

2. 传递的data是PromiseLike（Promise A+），返回新的Promise，状态和其保持一致即可

3. 否则之间 resolve（data）

```js
return new Promise((resolve, reject) => {
      if (isPromise(data)) {
        data.then(resolve, reject);
      } else {
        resolve(data);
      }
    });
```

类似的可以得到 reject

```js

   reject(reason) {
    return new MyPromise((resolve, reject) => {
      reject(reason);
    });
  }
```



## Promise ALL

他还支持迭代器，而迭代器还支持 for of循环，不支持下标循环

空数组要特殊处理 因为不会进入 for of

关键是用计数而不是 push



## Promise AllSettled

为了确保正确错误都能执行，对每个promise的onfulfilled和 onRejected 都进行必定成功的处理，得到一个必定成功的 Promise

然后使用 Promise.all得到所有结果

```js
p.then(
  (value) => ({
    status: FULFILLED,
    value,
  }),
  (reason) => ({
    status: REJECTED,
    reason,
  })
)
Promise.resolve(p).then(...同上)
```

为了避免 p 不是 Promise 而是一个数值或其他. 我们调用 Promise.resolve来确保他是一个 Promise
