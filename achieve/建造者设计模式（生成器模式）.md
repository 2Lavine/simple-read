> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/builder)

生成器模式
=====
**生成器模式**允许你使用相同的创建代码生成不同类型和形式的对象。
问题
--
例思考如何创建一个 `房屋`House 对象。 建造一栋简单的房屋， 首先你需要建造四面墙和地板， 安装房门和一套窗户， 然后再建造一个屋顶。 但是如果你还要有暖气、 排水和供电设备， 那又该怎么办呢？

最简单的方法是扩展 `房屋`基类
- 然后创建一系列涵盖所有参数组合的子类。 但最终你将面对相当数量的子类。

另一种方法则无需生成子类。
-  `房屋`基类中创建一个包括所有可能参数的超级构造函数， 并用它来控制房屋对象。 
- 拥有大量输入参数的构造函数也有缺陷：通常情况下， 绝大部分的参数都没有使用，

解决方案
----
生成器模式建议将对象构造代码从产品类中抽取出来， 将对象构造过程划分为一组步骤
-  重点在于你无需调用所有步骤， 而只需调用创建特定对象配置所需的那些步骤即可。
#### 主管

你可以进一步将用于创建产品的一系列生成器步骤调用抽取成为单独的主管类。 

主管类可定义创建步骤的执行顺序， 而生成器则提供这些步骤的实现。
主管知道需要哪些创建步骤才能获得可正常使用的产品。

---
严格来说， 你的程序中并不一定需要主管类。 客户端代码可直接以特定顺序调用创建步骤。 

不过， 主管类中非常适合放入各种例行构造流程， 以便在程序中反复使用。
 主管类完全隐藏了产品构造细节。 客户端只需要将一个生成器与主管类关联， 然后使用主管类来构造产品， 就能从生成器处获得构造结果了。

生成器模式结构
-------

![](https://refactoringguru.cn/images/patterns/diagrams/builder/structure-indexed.png)

2.  **具体生成器** （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
3.  **产品** （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
4.  **主管** （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
5.  **客户端** （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。
    

伪代码
---
分步骤制造汽车并制作对应型号用户使用手册的示例

汽车是一个复杂对象， 有数百种不同的制造方法。 
- 我们没有在 `汽车`类中塞入一个巨型构造函数， 而是将汽车组装代码抽取到单独的汽车生成器类中。 
- 该类中有一组方法可用来配置汽车的各种部件。

```
class Director is
    // 主管可同由客户端代码传递给自身的任何生成器实例进行交互。客户端可通
    // 过这种方式改变最新组装完毕的产品的最终类型。主管可使用同样的生成步
    // 骤创建多个产品变体。
    method constructSportsCar(builder: Builder) is
        builder.reset()
        builder.setSeats(2)
        builder.setEngine(new SportEngine())
        builder.setTripComputer(true)
        builder.setGPS(true)
    method constructSUV(builder: Builder) is
        // ……
class Application is
    method makeCar() is
        director = new Director()
        CarBuilder builder = new CarBuilder()
        director.constructSportsCar(builder)
        Car car = builder.getProduct()
        CarManualBuilder builder = new CarManualBuilder()
        director.constructSportsCar(builder)
        // 最终产品通常需要从生成器对象中获取，因为主管不知晓具体生成器和
        // 产品的存在，也不会对其产生依赖。
        Manual manual = builder.getProduct()
```

生成器模式适合应用场景
-----------

使用生成器模式可避免 “重叠构造函数 （telescoping constructor）” 的出现。

假设你的构造函数中有十个可选参数， 那么调用该函数会非常不方便； 
因此， 你需要重载这个构造函数， 新建几个只有较少参数的简化版。 
只有在 C# 或 Java 等支持方法重载的编程语言中才能写出如此复杂的构造函数。
但这些构造函数仍需调用主构造函数， 传递一些默认数值来替代省略掉的参数。

```
class Pizza {
    Pizza(int size) { …… }
    Pizza(int size, boolean cheese) { …… }
    Pizza(int size, boolean cheese, boolean pepperoni) { …… }
    // ……
```

生成器模式让你可以分步骤生成对象， 而且允许你仅使用必须的步骤。 应用该模式后， 你再也不需要将几十个参数塞进构造函数里了。


---
当你希望使用代码创建不同形式的产品 （例如石头或木头房屋） 时， 可使用生成器模式。
如果你需要创建的各种形式的产品， 它们的制造过程相似且仅有细节上的差异， 此时可使用生成器模式。

基本生成器接口中定义了所有可能的制造步骤， 具体生成器将实现这些步骤来制造特定形式的产品。 
同时， 主管类将负责管理制造步骤的顺序。


---
使用生成器构造[组合](/design-patterns/composite)树或其他复杂对象。
生成器模式让你能分步骤构造产品。 你可以延迟执行某些步骤而不会影响最终产品。 你甚至可以递归调用这些步骤， 这在创建对象树时非常方便。
生成器在执行制造步骤时， 不能对外发布未完成的产品。 这可以避免客户端代码获取到不完整结果对象的情况。

实现方法
----
1.  在基本生成器接口中声明通用步骤。
2.  为每个形式的产品创建具体生成器类， 并实现其构造步骤。
    1. 不要忘记实现获取构造结果对象的方法。 你不能在生成器接口中声明该方法， 因为不同生成器构造的产品可能没有公共接口， 因此你就不知道该方法返回的对象类型。 
    2. 但是， 如果所有产品都位于单一类层次中， 你就可以安全地在基本接口中添加获取生成对象的方法。
4.  客户端代码会同时创建生成器和主管对象。 构造开始前， 
	1. 客户端必须将生成器对象传递给主管对象。  主管类使用生成器对象完成后续所有制造任务。 
	1. 还有另一种方式， 那就是客户端可以将生成器对象直接传递给主管类的制造方法。
5.  只有在所有产品都遵循相同接口的情况下， 构造结果可以直接通过主管类获取。 否则， 客户端应当通过生成器获取构造结果。

生成器模式优缺点
--------
*   你可以分步创建对象， 暂缓创建步骤或递归运行创建步骤。
*   生成不同形式的产品时， 你可以复用相同的制造代码。
*   _单一职责原则_。 你可以将复杂构造代码从产品的业务逻辑中分离出来。
* 
*   由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。

与其他模式的关系
--------
*   你可以在创建复杂[组合模式](/design-patterns/composite)树时使用[生成器](/design-patterns/builder)， 因为这可使其构造步骤以递归的方式运行。 
*   你可以结合使用[生成器](/design-patterns/builder)和[桥接模式](/design-patterns/bridge)： 主管类负责抽象工作， 各种不同的生成器负责实现工作。