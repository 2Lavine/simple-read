%%begin highlights%%
## 继承（inheritance），
包括简单继承，多重继承，以及修饰器（modifier）和构造函数（constructor）的继承。

规则
virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。
override：子合约重写了父合约中的函数，需要加上override关键字。

先写一个简单的爷爷合约Yeye，里面

再定义一个爸爸合约Baba，让他继承Yeye合约，语法就是contract Baba is Yeye，非常直观

在Baba合约里，我们重写一下hip()和pop()这两个函数，加上override关键字

```js
function pop() public virtual override{
emit Log("Baba");
}
function baba() public virtual{
emit Log("Baba");
}
```


## 多重继承​

solidity的合约可以继承多个合约。规则：

继承时要按辈分最高到最低的顺序排。

比如我们写一个Erzi合约，继承Yeye合约和Baba合约，那么就要写成contract Erzi is Yeye, Baba，而不能写成contract Erzi is Baba, Yeye，不然就会报错。

如果某一个函数在多个继承的合约里都存在，比如例子中的hip()和pop()，在子合约里必须重写，不然会报错。

重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约名字，例如override(Yeye, Baba)。

function hip() public virtual override(Yeye, Baba){
emit Log("Erzi");
}

## 修饰器的继承​

Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。

```solidity
contract Base1 {
	modifier exactDividedBy2And3(uint _a) virtual {
	require(_a % 2 == 0 && _a % 3 == 0);
	_;
}
}
```


Identifier合约可以直接在代码中使用父合约中的exactDividedBy2And3修饰器，也可以利用override关键字重写修饰器：

```js
modifier exactDividedBy2And3(uint _a) override {
_;
require(_a % 2 == 0 && _a % 3 == 0);
}
```


## 构造函数的继承​

子合约有两种方法继承父合约的构造函数

在继承时声明父构造函数的参数，例如：contract B is A(1)

在子合约的构造函数中声明构造函数的参数，例如：

contract C is A {
constructor(uint _c) A(_c * _c) {}
}

## 调用父合约的函数​

两种方式调用父合约的函数，直接调用和利用super关键字

直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数，例如Yeye.pop()。

super关键字：子合约可以利用super.函数名()来调用最近的父合约函数。

solidity继承关系按声明时从右到左的顺序是：contract Erzi is Yeye, Baba，那么Baba是最近的父合约，super.pop()将调用Baba.pop()而不是Yeye.pop()：
%%end highlights%%

!!!PAGE NOTE!!!
%%begin pagenote%%

%%end pagenote%%

 #五彩插件 [原文](https://www.wtf.academy/solidity-start/Inheritance/)
更新时间: 2023-07-22 20:41