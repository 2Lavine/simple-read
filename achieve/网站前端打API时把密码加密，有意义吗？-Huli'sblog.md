> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [blog.huli.tw](https://blog.huli.tw/2023/01/10/security-of-encrypt-or-hash-password-in-client-side/#)

这篇想处理的问题是：
「已经使用了 HTTPS，在打登入 API 以前先把密码加密过或是不做任何处理，这两者的差别在哪？」
而我们可以把回答分成两个部分：
1.  假设 HTTPS 被破解了，是不安全的，差别在哪？
2.  假设 HTTPS 是安全的，差别在哪？

假设 HTTPS 不安全，差别在哪？
-----------------
怎样的状况会造成 HTTPS 不安全，攻击者掌握了系统的哪些部分？
底下简单分为四种状况讨论：
1.  攻击者掌控整台计算机，信任恶意凭证
	1. 攻击者有其他更好的手段去取得你的密码。
2.  攻击者成功执行了中间人攻击
	1. 只是数据包在传输的过程中被中间人攻击。
	2. 没加密的情形就能直接被获取密码，而有加密的情形攻击者只能获取到加密过的密文而非明文
	3. 但攻击者除了监听你的 request 以外，也能发送伪造的 response 给你，把前端用来加密密码的部分换掉。
3.  攻击者可以在网络层监听 request 并使用漏洞取得明文
	1. 如果有把密码先加密，攻击者就无法取得密码的明文。但依然可以透过重送请求来登入你的账号（先假设没有其他机制），所以你账号还是被盗了，只是攻击者不知道你的密码明文。（避免了撞库攻击）
4.  攻击者直接针对 HTTPS server 进行攻击
	1. 结论跟上个一样，就是加密密码会更安全。

一个是严重性（severity），另一个是可能性（possibility）
攻击者若是可以绕过 HTTPS 拿到明文的 request，那在应用层将密码加密，确实会比较安全，但要注意的是要达成这个前提非常困难，发生的概率极低。

假设 HTTPS 是安全的
-------------
有一个现实生活中会发生，而且也确实发生过的风险，那就是 logging。

身为前端工程师，在前端加装一些 error tracking 的服务是很合理的事情，若是我们直接实作一个「只要服务器回传 5xx，就把 request 记录起来」的机制，如果好巧不巧哪天登入的 API 出现这个状况，你就可以在 log 里面看到用户的明文密码。

而且不只前端，后端也可能有类似的机制，碰到一些问题就把 request 整个写到 log 档去，方便以后查看以及 debug，一不小心密码就可能被写进去。

在这种状况下，在 client 端先把密码加密显然是有好处的，那就是在这些错误处理的 log 中，被记录下来的密码会是密文，除非你有密钥，否则你是不会知道用户的密码的。

加密还是 hash？
----------
文章开头我有提到 hash 的状况有些复杂，所以我先把情境设置在「对密码做非对称式加密」再传输，因为对上面我举的那些例子而言，这两种情境的差异不大。

举例来说，HTTPS 被拿到明文内容，无论你对密码做了非对称式加密还是散列，在攻击者无法取得服务端密钥的前提之下，都是拿不到明文密码的。

那为什么 hash 的状况有些复杂呢？

假设我们在前端先把密码 hash 过后再传到后端，那后端是要直接存进去数据库吗？如果直接存进去数据库，哪天数据库的内容曝光，攻击者就拿到这些 hash 过的密码了。

通常在有加盐以及散列演算法够强的前提之下，被拿到 hash 的密码还是能保证一定的安全性，可是在这种情况下，反而变得很不安全。

因为前端传给后端的内容已经是 hash 过的了，所以攻击者可以直接拿 hash 过的密码进行登入，根本不用知道明文是什么。虽然保护了明文，但失去了原本散列的安全性。

因此如果要做 client side hashing，server side 收到后也要再做一次。如此一来，就算数据库被偷走，攻击者也没办法利用数据库中的 hash 直接登入。

有些人可能跟我一样好奇：「做两次 hash 不会更不安全吗？」，我们可以看一下 Google 在 [Modern password security for system designers](https://cloud.google.com/static/solutions/modern-password-security-for-system-designers.pdf) 里面怎么说：

> Have the client computer hash the password using a cryptographically secure algorithm and a unique salt provided by the server. When the password is received by the server, hash it again with a different salt that is unknown to the client. Be sure to store both salts securely. If you are using a modern and secure hashing algorithm, repeated hashing does not reduce entropy.

看起来是还好，问题不大。

总之呢，看起来最安全的但也更复杂的解法就是 client side 先 hash 一次，然后丢到 server 的时候再 hash 一次存进数据库，如此一来就可以保证：

1.  HTTPS 因为各种原因失效时，攻击者无法取得明文密码
2.  在 Server 端，没有任何人知道用户的明文密码
3.  明文密码不会因为人为失误被记录到 log 中

那如果真的比较好用，为什么没人在用？


结论
--
第一个结论是：「在 client 端发送密码前先把密码加密或是 hash，确实能够增加安全性」
理由是做了以后，能够达成以下事项：
1.  HTTPS 因为各种原因失效时，攻击者无法取得明文密码
2.  在 Server 端，没有任何人知道用户的明文密码
3.  明文密码不会因为人为失误被记录到 log 中
以上都是没有在 client 加密或是 hash 时做不到的。


第三个结论是：「虽然从技术上来看能够增加安全性，但实际上是否实作，仍然要考虑其他因素」
这因素就是我前面提过的「可能性」还有开头我讲先不谈的「成本」。
若是真的比较安全，为什么一般网站不会实作这个机制？
- 或许是因为觉得 HTTPS 被攻破的可能性太低，低到可以忽略不计（我相信这是大多数留言的人觉得不需要做的理由，我也同意这点）
- 也或许是成本太高，会增加程序码复杂度；若是采用加密的方案，也会消耗更多运算的资源在加解密上面，这也是成本。


---

这就是我觉得应该讲清楚的地方。
在前端先做 hash 或是加密，它确实是有优点的，不是多此一举，也不是没有意义，更不是让系统变得更危险。

但这不代表每个系统都该实作这个机制，因为它带来的效益或许没有成本高，这个端看各个公司的考量。对大部分的公司来说，与其为了 HTTPS 失效这个极低的可能性去投入成本，不如把时间花在加强其他登入环节的安全性（例如说 2FA 啦，或是不同设备登录警告等等），带来的效益会更高。

有些服务还会选择把整包 request 都加密，而非只有密码，这个又更安全但是成本又更高，而且 debug 很不方便。虽然说既然加密做在 client 端，攻击者一定有办法逆向这个机制，看出是怎么做的，但这不代表这些机制没帮助。

举例来说，假设我有个抢票 App 不想让别人知道 API 怎么调用，于是就实作了一个超复杂的加解密机制，尽管高手还是可以做逆向工程，写出一个抢票机器人，但这个机制增加了他的时间成本以及对技术的要求。

以技术上来说，就算理论上一定会被破解，这些机制还是有意义的，它的意义在于增加破解难度，加壳、混淆都是一样的，不会因为「在 client 端的东西一定会被看穿」而不去做这些机制。

重点在于你想保护的商业逻辑的价值，有没有高到你需要付出这些成本去做额外的安全机制。
很多人在讨论这个问题的时候，没有办法把「单一问题」跟「最佳实践」切开来看，总是在讨论着「以成本来说，怎样怎样才是最好的」或是「为什么不干脆怎样怎样」，但技术选型从来都不是一刀切的事情，最好的方案通常成本也较高，如果真的没有这么多的资源怎么办？是不是就需要选择次好且成本较低的方案？

不是只有最佳实践才叫做实践，技术是需要进行妥协的。

举个例子，把登入验证机制都换成 [Passkeys](https://developers.google.com/identity/passkeys?hl=zh-tw)，成本可能是 50，增加的安全性是 90。

把原本明文传输的密码先 hash，成本可能是 20，增加的安全性是 5。

尽管 Passkeys 的效益整体来说更高，但问题是有些公司可能现在就只有 20 个单位的资源。

我自己认为一位优秀的工程师不能只给得出最佳实践，而是必须针对有限资源的状况之下，给出各种不同的解法，因此这篇讨论的问题不是毫无意义的。把这个问题整理过一轮之后，自然而然就会出现许多成本不同，效益也不同的解法。

有多少资源，就做多少事。


---
最后，如果你需要一个条列式的简单结论，会是：
1.  无论如何，一定要先用 HTTPS
2.  可以的话，能用 Passkeys 当然是最好，少掉传统密码的一些问题
3.  如果你想要用很安全的方式验证密码，请参考 SRP（Secure Remote Password）协定
4.  若是上述都没有资源做的话，那在前端先把密码做加密或是 hash 后再发送，确实能够增加一点安全性，但同时还是会带来额外成本
5.  如果你是银行或需要较高的安全性，再来考虑要不要做这个，否则极大多数的状况下，你不需要这个机制就够安全了，资源投入在其他地方的效益会更大

若是对这个结论有不同意见，或是有在文章中发现哪些逻辑错误或技术错误，欢迎留言指正与讨论，感恩。