> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/6QTdeM2l1htofCnKLZS6yw)

理解理念：React 的野心与颠覆式创新
--------------------
### 核心理念

React 核心原理就是：**当数据发生变化时，UI 随之更新**，就是所谓的数据驱动，之所以说 React 很有野心，是因为它完全抛弃了前端熟悉的开发模式，创造出一个全新的思路，试图颠覆前端工作者的开发方式，确实这是个很伟大的尝试。

![](https://mmbiz.qpic.cn/sz_mmbiz_png/cAd6ObKOzEBcAl6LxOVx5ibEG78sicoSalNLAFjGJHUiaSbWibAhkOKuFibNzrU4RA6hAek5mLP8sXghDaiaRw6bthiaQ/640?wx_fmt=png)

### 实现方式

当然你说 Vue 同样是数据驱动，但不同的是 Vue 做了更上层的封装，Vue 设计了新的类似 HTML 的模板语法，通过选项属性为开发者提供编写逻辑和 state 的地方，再通过一个 viewModel，当监听到 state 变化时再去更新 view ，总结起来就是在前端现有开发习惯下，以 “糖水” 的方式 “注入” 了更多让开发变的更加容易的功能，但无疑设计上会变的非常的复杂。


----
最终 React 选择了 js 中的 **【函数】**  去承载所有的功能，所以 React 的函数组件本质上真的就只是 js 中的**普通函数**而已，而非 .vue 这种专门需要复杂编译的新产物

那一个简单的函数是如何实现上述这么多复杂的功能的呢：
1.  首先 React 将 **HTML 与 js 相融合**，我们可以在函数组件中直接写 DOM 语法，DOM 在 js 中成为了合法的结构，最终函数组件返回一个 DOM ，就是该函数作为一个 React 组件最终要渲染的 UI
2.  第二是**逻辑**，函数本身天然就是可以直接写 js 执行逻辑的，所以将业务逻辑直接写在函数中即可，无需像 Vue 一样提供各种选项 API，让开发者将不同的逻辑写进预置好的各种接口里
3.  第三是组件的**状态**，函数组件是一个纯函数，通过函数自身的执行去渲染页面，所以函数组件本身天然无法留存状态，所以 React 采用 hooks 的方式为组件提供状态，
	1. 最终实现就是：**状态可以写在函数中，既不破坏纯函数的特性，又能在状态变更时使函数组件以最新的状态重新执行，更新页面**
4.  第四是生命周期，因为现在大多传统框架架构都会引入生命周期的概念，以在组件的不同阶段去更新视图，但是 React 的函数组件完全摒弃了这一概念，它只是在特定的时机会触发整个函数组件的重新执行，自然会生成最新的视图，不需要做不同逻辑的处理。
5.  最后是渲染，函数组件本身最终返回一个 DOM 结构，可以理解它本身就是执行的一个渲染逻辑，所以只需要让函数组件在需要更新的时候反复执行自身就行了。

### 为什么会有 Class 组件

有个局限就是，函数组件内部无法留存状态，函数也更没办法设计一套生命周期，用函数作为组件有严重缺功能陷的，所以在当时选用 Class 作为组件的载体。

Class 组件我现在看起来依然觉得很难接受，原因有几点：
1.  在现在的前端开发中，Class 真的很少被用到，尤其目前函数式编程盛行的情况下。
2.  其次 Class 最大的特性就是**继承**和通过 Class **实例**化出一个对象，但这两种特性跟 React 的组件化思想，都极其违和，完全用不到。
**可以说 Class 只是为了实现组件基本功能而用，所以最初看到 React Class 组件时，反而觉得没有 .vue 单文件组件来的优雅和直接**。

### 函数式组件 + Hooks

通过 hooks 引入一个不受函数组件重复执行影响的外部变量作为函数组件内的状态，当这个状态变更时，函数组件随之重新渲染，将最新的状态渲染到页面。

函数组件早期有很大的不足，**就是不能留存状态与很难设计生命周期**，那 Hooks 是如何解决的呢。

### Hooks 设计

想象一下如果将一个纯函数作为组件，纯函数通过自身的重复执行来做到渲染与重复更新，需要在函数多次执行期间保存其中的状态，那我们肯定是需要这个函数之外的空间来存储状态，并且当这个状态被改变时，能监听到并触发函数组件的重新渲染。

Hooks 就是这种方式，字面意思就是钩子，Hooks 将函数钩到一个可能会变化的数据源上，当这个数据变化时，被钩在上面的函数会重新执行，生成新的结果。

### 内置 useState Hooks 解决状态的问题
useState 用法很简单，如下代码，引入后会在当前函数外声明一个变量：
*   该变量从声明、初始化赋值、值变更都不受当前函数组件重复执行的影响
*   我们可以在函数组件内通过暴露的 setState 方法修改 state 的值
*   因为当前函数钩在了这个 state 上，state 变更时就又会触发当前函数重新执行
*   函数组件作为纯函数重新执行拿到了最新的 state 值，渲染出了最新的结果

**最终复杂的视图渲染就在函数组件一遍又一遍简单的重复执行中完成了**。
而且 Hooks 虽然是将状态声明在函数外部，但写法上仍然是写在函数组件的内部的，
这让人写起来并不会有函数组件的割裂感

### 内置 useEffect Hooks 解决生命周期的问题
*   **useEffect 和生命周期无关，他是函数组件形态下的另一种设计模式，只是说他能解决我们过去认知中的使用生命周期的一些问题**。
*   **useEffect 的设计是用来执行一段和当前渲染无关的副作用代码**，因为每次函数组件重新执行都是因为最终的渲染结果要改变，每次重新执行意味着函数内部的逻辑要从头再执行一遍，如果有些逻辑与渲染结果无关仍然会被重新执行，这显然是不正常的，所以 React 设计了 useEffect 用来处理与渲染无关的副作用代码，
*   如果有些逻辑既与 state 无关又与渲染结果无关，那说明这段副作用只需要执行一次，可以不传入依赖状态，则只会在组件首次渲染时触发，
* 同时 useEffect 可以返回一个方法，该方法会在组件被销毁时执行，这样也顺便实现了类似传统生命周期中 **componentDidMount** 与 **componentWillUnmount** 的功能。

### 内置 useRef 函数组件的逃脱机制
最后还缺少一个非常重要的功能，**就是在函数重复执行渲染过程中的数据共享**，我们需要一个能从纯函数重复执行中逃脱，贯穿整个组件渲染的变量，
State不能做这个因为， state 是和渲染绑定的特殊状态，有以下绑定的特性：
1.  state 状态一定和视图渲染有关
2.  state 值的变更会触发函数组件重新执行
3.  state 变更后有一系列复杂的逻辑，要先触发渲染，再执行副作用，在最新的函数组件执行过程中才能拿到最新的 state 的值
所以需要在一个复杂的时机才能拿到 state 最新的值，而我们需要一个与渲染无关的数据，能贯穿重复的函数执行，变更后不需要触发函数重新渲染，并且不需要在意此时函数的渲染过程是非常有必要的

## useRef
useRef 就实现了这个功能(在函数重复执行渲染过程中的数据共享**)，他在函数组件首次执行时创建，你可以在函数任何逻辑中直接更改 useRef 的值，它会立即同步更改，并贯穿重复的函数执行，无需任何心理负担。

除了能存储函数组件重复执行过程的共享数据，**useRef 在存储 DOM 节点，和清理某次渲染过程产生的闭包逻辑有非常重要的意义**

```js
import { useState, useRef } from "react";
export default function Timer() {
 const [time, setTime] = useState(1)
  const timer = useRef(null);
  const domRef = useRef(null);

  const click = function(){
     // 需要再每次执行前清理掉之前的定时器，
    // 如果不使用 useRef ，函数组件重复渲染后无法找到上一次函数执行产生的定时器对象
     window.clearInterval(timer.current);
     // 延时器对象赋值给 useRef
      timer.current = window.setTimeout(() => {
      setTime(time + 1);
    }, 5000);
  }
  const getDOm = function(){
    // 我们可以毫无负担的获取到domRef节点，不受函数组件重复执行的影响
    console.log(domRef)
  }

  return (
    <div ref={domRef}>
      <p>{time}</p>
      <button onClick={click}>add</button>
      <button onClick={getDOm}>getDom</button>
    </div>
  );
}
```



自定义 Hooks 带来的逻辑复用新形态
--------------------

 React 带来的另外一个给我们开发方式带来巨大的转变的特性：**自定义 Hooks**。

在以前无论是 Vue 还是 React 组件内的逻辑复用都异常艰难，通常情况我们只能封装 js 自身的对象和方法，比如封装一个函数，但组件内部的功能却是无法封装的，比如我们只能封装一个普通方法，不可能封装出一个带有响应式的方法。

这个过程中 React 出现过一些组件内逻辑封装的设计模式，比如高阶组件 HOC、混入 Mixin，Vue 也曾采用过 Mixin ，但使用度很低现在也都被官方废弃了，因为他们的使用实在太过牵强


---
所以我们需要一个能将组件内逻辑再次封装复用的功能，自定义 Hooks 的推出就是解决了这一点。
比如我们要在多个组件中实现获取视口宽度的功能，
- 在以前如果我们不想在每个组件中都写一套事件监听程序，那就需要在父组件中写一个监听程序，监听到变化后将视口宽度通过 props 传递给子组件，子组件才能响应式更新，
- 而现在我们可以在自定义 Hooks 直接使用 useState 给组件返回一个响应式的 state。

```js
// useWindowSize.js 
export default function useWindowSize (){
  const [size, setSize] = useState(getSize());
  useEffect(() => {
  const handler = () => {
      setSize(window.innerWidth)
    };
    window.addEventListener('resize', handler);
    return () => {
      window.removeEventListener('resize', handler);
    };
  }, []);
  
  return [size];
};

// jsx中使用
export default function（）{
  const [size] = useWindowSize();
  if (size >1000 ) {
    return <SmallComponent />;
  }else{
    return <LargeComponent />;
  }
};```

从此在 React 中，又多了一种新的封装形态，自定义 Hooks，让相同业务逻辑拆分的更清晰，降低代码的冗余，提高代码的复用程度

函数式编程的意义
--------------
 在函数式编程中，函数是头等对象即头等函数，这意味着一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。
 
比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。（来自维基百科）

