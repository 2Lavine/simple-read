**2. 为什么要使用缓存（Why）**
--------------------
**1）硬件层面：如 CPU 中的高速缓存**
在 CPU 访问数据和指令遵循**计算机系统的局部性原理**：
1.  **时间局部性**：CPU 通常使用的许多数据会被多次使用。
2.  **空间局部性**：CPU 使用的许多数据通常在物理上接近以前使用的数据。
**使用高速缓存可以弥补 CPU 和内存之间的性能差异，减少 CPU 浪费计算时间等待内存数据。**

**2）软件层面**
1.  为缓解 CPU 压力而做缓存：
	1. 比如把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这可以节省 CPU 算力，顺带提升响应性能。
2.  为缓解 I/O 压力而做缓存：
	1. 比如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩组件（如缓存中间件）的访问，顺带提升响应性能。

**3）产品层面**
是否可以解决用户的痛点问题决定着用户会不会一开始尝试使用某款产品，是否有极致的用户体验影响用户会不会持续使用某款产品。
- 在业务中使用缓存的目的就是通过**扩大系统吞吐量、减少时延和响应时间来优化用户体验**，适当的性能优化可以**提升体验，增强用户粘性**。

**3. 什么时候使用缓存（When）**
---------------------
- 并非所有的业务场景都适合用缓存，**读多写少、不要求一致性、时效要求越低、访问频率越高、对最终一致性和数据丢失有一定程度的容忍的场景才适合使用缓存**，
- 缓存并不能解决所有的性能问题，倘若滥用缓存会带来额外的维护成本，使得系统架构更复杂更难以维护。

缓存前思考的问题
---
虽然缓存适用于各种各样的案例，但要充分利用缓存，需要进行一定的规划。所以在决定是否缓存一段数据时，请考虑以下问题：
*   **使用缓存值是否安全？** 相同的数据在不同的上下文中可能有**不同的一致性要求**。例如电商系统中，在线结账期间，必须知道商品的确切价格，因此不适合使用缓存
*   **对于该数据而言，缓存是否高效？** 某些应用程序会生成不适合缓存的访问模式；例如，扫描频繁变化的大型数据集的键空间。在这种情况下，保持缓存更新可能会抵消缓存带来的所有优势。
*   **数据结构是否适合缓存？**例如： 以单条数据库记录形式缓存数据通常足以提供显著的性能优势。但有些时候，数据最好以多条记录组合在一起的格式进行缓存。缓存以简单的键值形式存储，因此您可能还需要以多种不同格式缓存数据记录，以便按记录中的不同属性进行访问。  

另外把缓存当做存储来使用是一件极其致命的做法，这种错误的认识，将缓存引入系统的那一刻起就意味着已经让系统走上了危险的局面，**只有对缓存的使用边界有深刻的理解，才能尽可能减少引入缓存带来的副作用。**


# 缓存分类
1. 客户端缓存
	1. 页面缓存
	2. APP 缓存
	3. 浏览器缓存
2. 网络缓存
### **1. 客户端缓存**
**HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷**。由于每次请求都是独立的，服务端不保存此前请求的状态和资源，所以也不可避免地导致其携带有重复的数据，造成网络性能降低。HTTP 协议对此问题的解决方案便是客户端缓存。
常见的客户端缓存有如下几种：
**1) 页面缓存**
页面缓存是指将静态页面获取页面中的部分元素缓存到本地，以便下次请求不需要重复资源文件，
具体实现可通过页面指定 manifest 文件，当浏览器访问一个带有 manifest 属性的文件时，会先从应用缓存中获取加载页面的资源文件，并通过检查机制处理缓存更新的问题。
 **2) APP 缓存**
APP 可以将内容缓存到内存或者本地数据库中，例如在一些开源的图片库中都具备缓存的技术特性，当图片等资源文件从远程服务器获取后会进行缓存，以便下一次不再进行重复请求，并可以减少用户的流量费用。
 **3) 浏览器缓存**
浏览器缓存通常会专门开辟内存空间以存储资源副本，当用户后退或者返回上一步操作时可以通过浏览器缓存快速的获取数据，减少页面加载时间和带宽使用。在 HTTP 从 1.0 到 1.1，再到 2.0 版本的每次演进中，逐步形成了现在被称为 “状态缓存”、“强制缓存”（许多资料中简称为“强缓存”）和“协商缓存” 的 HTTP 缓存机制。在 HTTP 1.1 中通过引入 e-tag 标签并结合 expire、cache-control 两个特性能够很好的支持浏览器缓存。

## Etag
**对于 Etag 的补充说明：**
HTTP 服务器可以根据自己的意愿来选择如何生成这个标识，比如 Apache 服务器的 Etag 值默认是对文件的索引节点（INode），大小和最后修改时间进行哈希计算后得到的。
Etag 是 HTTP 中一致性最强的缓存机制，
Last-Modified 的问题
- 标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；
- 如果某些文件会被定期生成，可能内容并没有任何变化，但 Last-Modified 却改变了，导致文件无法有效使用缓存，
**Etag 却又是 HTTP 中性能最差的缓存机制**，体现在每次请求时，服务端都必须对资源进行哈希计算，这比起简单获取一下修改时间，开销要大了很多。Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内。


### 内容协商机制
HTTP 的协商缓存机制已经能很好地处理通过 URL 获取单个资源的场景，
为什么要强调 “单个资源” 呢？
在 HTTP 协议的设计中，一个 URL 地址是有可能能够提供多份不同版本的资源，
- 比如，一段文字的不同语言版本，一个文件的不同编码格式版本，一份数据的不同压缩方式版本，等等。
- 因此针对请求的缓存机制，也必须能够提供对应的支持。
为此，HTTP 协议设计了
- 以 Accept_（Accept、Accept-Language、Accept-Charset、Accept-Encoding）开头的一套请求 Header 
- 对应的以 Content-（Content-Language、Content-Type、Content-Encoding）开头的响应 Header，

-这些 Headers 被称为 HTTP 的内容协商机制。因此对于一个 URL 能够获取多个资源的场景中，缓存也同样也需要有明确的标识来获知根据什么内容来对同一个 URL 返回给用户正确的资源。这就是 Vary Header 的作用
- Vary 后面应该跟随一组其他 Header 的名字
```
HTTP/1.1 200 OK
Vary: Accept, User-Agent
```

以上响应的含义是应该根据 MIME 类型和浏览器类型来缓存资源，获取资源时也需要根据请求 Header 中对应的字段来筛选出适合的资源版本。



## 正向代理和反向代理
正向代理其实就是：源服务器感知不到客户端的存在，隐藏了客户端
那正向代理有什么作用呢？
*   提高访问速度：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。
*   控制对内部资源的访问：如某大学 FTP（前提是该代理地址在该资源的允许访问范围之内）使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类 FTP 下载上传，以及各类资料查询共享等服务。
*   过滤、调整内容：例如限制对特定计算机的访问、压缩请求包、改变请求包的语言格式等。
*   隐藏真实 IP：通过代理服务器隐藏自己的 IP，但更安全的方法是利用特定的工具创建代理链
*   突破网站的区域限制：通过代理服务器访问一些被限制的网站。

反向代理就是：隐藏了源服务器
反向代理
- 负载均衡：若服务器集群中有机器负荷较高，反向代理通过 URL 重写，把请求转移到低负荷机器获取与所需相同的资源。
*   对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务。
*   安全：作为应用层防火墙，为服务器提供基于 Web 的攻击行为（例如 DoS/DDoS）的防护，更容易排查恶意软件等
*   为后端服务器（集群）统一提供加密和 SSL 加速（如 SSL 终端代理）。
*   对一些内容进行压缩，以节约带宽或为带宽不佳的网络提供正常服务。
*   提供 HTTP 访问认证。  


## 网络缓存
**网络缓存位于客户端以及服务端中间，通过代理的方式解决数据请求的响应，降低数据请求的回源率**。回源率又分为以下两种：
*   **回源流量比**：回源流量是代理服务器节点请求源服务器资源时产生流量。回源流量比 = 回源流量 /（回源流量 + 用户请求访问的流量），比值越低，性能越好。
*   **回源请求数比**：指代理服务器节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。

网络缓存常见的代理形式分为两种：web 代理缓存、边缘缓存。
- web 代理缓存通常是
	- 指正向代理，会将资源文件和热点数据放在代理服务器上，当新的请求到来时，如果在代理服务器上能获取数据，则不需要重复请求到应用服务器上。
- 边缘缓存：和正向代理一样，反向代理同样可以用于缓存，例如 nginx 就提供了缓存的功能。
	- 进一步，如果这些反向代理服务器能够做到和用户请求来自同一个网络，那么获取资源的速度进一步提升，这类的反向代理服务器可以称之为边缘缓存。常见的边缘缓存就是内容分发网络（Content Delivery Network），简称 CDN。可以将图片等静态资源文件放到 CDN 上。


## DNS解析过程
1. 加一个. ,它是 “`.root`” 的含义。早期的域名必须带有这个点才能被 DNS 正确解析
2. 先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。
	1. DNS 是以[存活时间](https://en.wikipedia.org/wiki/Time_to_live)（Time to Live，TTL）来衡量缓存的有效情况的，
	2. 后续每一级 DNS 查询的过程都会有类似的缓存查询操作
3. 客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）
	1. 手工配置 or DHCP 分配
4. 会按照 “是否有 [www.wallbig.club.cn](https://www.zhihu.com/question/www.wallbig.club.cn) 的权威服务器”→“是否有 wallbig.club.cn 的权威服务器”→“是否有 club.cn 的权威服务器”→“是否有 cn 的权威服务器” 的顺序，依次查询自己的地址记录
	1. 地址记录并不一定就是指 IP 地址，在 RFC 规范中有定义的地址记录类型已经多达数十种，比如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、每种记录类型中还可以包括多条记录
	2. 权威服务器可以根据自己的策略来进行选择最优的
5. 如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。这个步骤里涉及了两个重要名词

**权威域名服务器**（Authoritative DNS）：是指负责翻译特定域名的 DNS 服务器，“权威” 意味着这个域名应该翻译出怎样的结果是由它来决定的。
**根域名服务器**（Root DNS）是指固定的、无需查询的[顶级域名](https://en.wikipedia.org/wiki/Top-level_domain)（Top-Level Domain）服务器，可以默认为它们已内置在操作系统代码之中。全世界一共有 13 组根域名服务器
	13 这个数字是由于 DNS 主要采用 UDP 传输协议来进行数据交换，未分片的 UDP 数据包在 IPv4 下最大有效值为 512 字节，最多可以存放 13 组地址记录

专门有一种被称为 “[DNS 预取](https://en.wikipedia.org/wiki/Link_prefetching)”（DNS Prefetching）的前端优化手段用来避免这类问题：如果网站后续要使用来自于其他域的资源，那就在网页加载时生成一个 link 请求，促使浏览器提前对该域名进行预解释，比如下面代码所示：

```
<link rel="dns-prefetch" href="//domain.not-wallbig.club">
```

## CDN 利用场景
主要包括路由解析、内容分发,负载均衡、CDN 的利用场景
CDN 路由提前准备
1.  架设好 “`wallbig.club`” 的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为 “源站”，注册后你会得到一个 CNAME，即本例中的 “`wallbig.club.cdn.dnsv1.com.`”。
2.  将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。
**一、路由解析**
1. 如果没有缓存的话，都会先经过 DNS 服务器的解析翻译，找到域名对应的 IP 地址
	1. 操作系统自动完成的
2. 当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。
4.  本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。
5.  浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问，此时该 IP 的 CDN 节点上可能有，也可能没有缓存过源站的资源，这点将在下面的 **“内容分发”** 小节讨论。
6.  经过内容分发后的 CDN 节点，就有能力代替源站向用户提供所请求的资源。