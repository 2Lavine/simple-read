> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7326268998490865673?utm_source=gold_browser_extension)

**0. 什么叫轮询？**
所谓的轮询就是
- 由后端维护某个状态，或是一种连续多篇的数据（如分页、分段）
- 由前端决定按序访问的方式将所有片段依次查询，直到后端给出终止状态的响应（结束状态、分页的最后一页等）
**1. 轮询的方案？**
一般有两种解决方案：
- 一种是使用`websocket`，可以让后端主动推送数据到前端；
- 一种是前端主动轮询（上网查了下细分为长轮询和短轮询），通过大家熟悉的定时器（`setInterval`和`setTimeout`）实现。

**遇到的问题：**
---
1、由于看需求文档上交互流程比较清晰，最开始没去网上查找实现方案，自己直接整了一版`setInterval`的轮询实现。在跟后台联调的过程中发现定时器每 1s 请求一次接口，发现很多接口没等响应就开启下一次的请求，很多请求都还在 pending 中，
- 可以通过`setTimeout`来优化，具体就是用`setTimeout`递归调用方式模拟`setInterval`的效果，达到只有上一次请求成功后才开启下一次的请求。

2、在自测了过程中又发现了另外一个问题，`stopPolling`方法中`clearTimeout`似乎无法阻止`setTimeout`的执行，二维码失效后请求仍在不停发出，这就很奇怪了。
虽然 clearTimeout 已经清除了定时器，但此时有请求已经在进行中，导致再次进入了循环体，重新开启了定时器。解决办法就是，需要手动声明一个标识位`isStop`来阻止循环体的执行。

```
stopPolling() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
        // 标记终止轮询(仅clearTimeout无法阻止)
        this.isStop = true;
      }
    },
```

3、解决了上面提到的问题，就在以为万事大吉，只待提测的时候。后台同事发现了一个问题（点赞后台同事的尽责之心）：他在反复切换登录方式（扫码登录 <-> 账号密码登录）的过程中，发现后台日志有一段时间打印的`qrcId`不是最新的。然后我这边试了下，确实在切换频率过高时，此时有未完成的请求仍在进行中，导致`qrcId`被重新赋值了。虽然已经在`beforeDestroy`里调用了`stopPolling`清除定时器, 但此时请求是未停止的。聪明的小伙伴们肯定想到`axios`的`cancelToken`可以取消未完成的请求
