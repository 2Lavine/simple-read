本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7239267216805838903)


所以通常我硬着头皮只能说出以下这些：
1. 开发前会花点时间梳理业务，全局视角过一遍交互和视觉，思考组件划分，找出项目中相似的部分，提取为公共组件和通用逻辑。
2. 代码开发中尽量保证写出的代码清晰、可维护，比如：清晰的目录和文件结构、添加必要的注释、提取公共函数公共组件、组件单向数据流、组件功能尽量单一等。
3. 时刻关注可能会存在性能问题的部分，比如：

缓存-frequency
- 频繁切换的组件使用 KeepAlive 进行缓存
- 缓存复杂或常用的计算结果
-  对实时性不高的接口进行缓存
	-  http 相关：
		 gzip 压缩
		强缓存、协商缓存
on demand 加载
- 路由组件异步加载，预加载
- 动态加载一些初始不需要用到的资源
- 懒加载列表，懒加载图，虚拟滚动
- 使用三方库或组件库尽量采用按需加载，减少打包体积
进程池
- 同一个接口多次请求时取消上一次没有完成的请求
- 对移出可视区的图片和 dom 进行销毁
- 对于一些频繁的操作使用防抖或节流
-  组件卸载时取消事件的监听、取消组件中的定时器、销毁一些三方库的实例
用户体验
- 对于一些确实比较慢的接口使用 loading 或骨架屏
优先级加载
- 页面中存在很多接口时进行优先级排序，优先请求页面重要信息的接口，并关注同一时刻请求的接口数量，如果过多进行分批请求
资源
- 关注页面中使用到的图片大小，推动后端进行图片压缩
- 雪碧图、使用字体图标、svg
- tree shaking，分包，代码压缩
JS 单线程
- 复杂计算使用 web worker



比如我开源的一个思维导图项目 [mind-map](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwanglin2%2Fmind-map "https://github.com/wanglin2/mind-map")，
通过`svg`实现，所以就是 DOM 节点，当节点数量非常多以后，删除节点和创建节点都是非常耗时的，
- 数据驱动视图的框架比如`Vue`会通过虚拟 DOM 的`diff`算法对比来找出最小的更新部分
- 将真实节点缓存起来，渲染时通过数据唯一的 id 来检查是否存在可复用节点，如果没有，那么代表是新增节点，那么创建新节点即可；如果有，那么就判断节点数据是否发生改变，没有改变直接复用，如果发生了改变那么判断是否可以进行更新，如果更新成本高那么直接重新创建；另外也需要和上一次的缓存进行对比，找出本次渲染不需要的节点进行删除；

当然，为了避免缓存节点数量无限膨胀，也通过 LRU 缓存算法来管理
对于不影响其他节点的操作只更新被操作的节点
通过`setTimeout`异步渲染节点，留一些中间时间来响应页面其他操作
将触发渲染的任务放到队列中，在下一帧进行处理，合并掉一些中间状态

对于鼠标移动和滚动的场景，通过节流来优化

进行一些取舍，早期节点激活时可以修改节点的所有样式，导致激活操作需要重新计算节点大小，更新节点样式，在多选和全选操作下非常耗时，所以后期改为只允许修改不改变节点大小的样式属性

其他一些细节优化：对于数据没有改变的操作不触发赋值或函数调用，一些不起眼的操作可能也是需要耗费时间的；改变了不涉及节点大小的属性不触发节点大小重新计算等

