<h1>2023-10-08</h1><h2>Python中的数组方法</h2>
<p>#python/array
删除前后空白
s = s.strip()
反转整个字符串
s = s[::-1]
列表转成字符串
&quot;-&quot;.join(sequence)
sequence表示要连接的串行，可以是列表、元组、字符串等。</p>
<hr>
<p>join()函数只能用于字符串之间的连接，如果串行中包含非字符串类型的元素，需要先将其转换为字符串才能进行连接。例如：</p>
<p>numbers = [1, 2, 3]
result = '-'.join(str(num) for num in numbers)
print(result)</p>
<p>注意 py 的join 和js 的 join 相反</p>
<h2>Python 生成器</h2>
<p>#python/generator
range 是一个很常用的内置生成器。它接受以下输入值：
“start”（包括数字本身，默认为0）
“stop”（不包括数字本身）
“step”（默认为1）</p>
<h3>生成器理解</h3>
<p>Python提供了一个轻便的用一行代码定义简单生成器的语法；这种表达式叫做生成器理解（generator comprehension）
gene=([n, l] for n in nums for l in letters if n!=1 and l!=2)for可以一直叠
相当于 js 中的generator，带有 next 和 value
可以用for i in gene遍历</p>
<h3>生成器理解</h3>
<p>是一种创建列表的语法
把生成器改成方括号</p>
<h2>python中的遍历</h2>
<p>if letter in obj:
If letter in obj.keys():
这两个是等价的</p>
<p>#English
from the very left of the array to the very right.
从最左边移动到最右边 i</p>
<p>#python/array
用 stack[-1] 来获取 top元素</p>
<p>#python/除法
a//b 结果向下取整
int(number) 结果值保留整数部分
math.ceil, math.floor</p>
<p>#python/deque
deque是一个双端队列
导入方法from collections import deque
append(x): 在deque的右侧添加元素x。
appendleft(x): 在deque的左侧添加元素x。
pop(): 移除并返回deque的最右侧的元素。
popleft(): 移除并返回deque的最左侧的元素。
rotate(n): 将deque中的元素向右循环移动n步（如果n是负数，则向左循环移动）。</p>
<p>#python/heapq
heapq 库是Python标准库之Lib，提供了构建小顶堆的方法
直接 import heapq 不用 from</p>
<p>在Python中，<code>deque</code>是<code>collections</code>模块中的一个类，而<code>heapq</code>是Python标准库中的一个模块。它们的导入方式略有不同,使用方式也不同。</p>
<pre><code class="language-python">from collections import deque
d = deque()
</code></pre>
<ol start="2">
<li>
<p><code>heapq</code>是Python标准库中的一个模块，用于实现堆（heap）数据结构。在导入时，只需要使用<code>import heapq</code>的方式即可。</p>
</li>
<li>
<p>我们可以使用<code>heapq</code>模块中提供的函数来进行堆相关的操作。</p>
<pre><code class="language-python">import heapq
heap = []
heapq.heappush(heap, 1)
</code></pre>
</li>
</ol>
<h2>#python/heapq 使用方法</h2>
<p>要创建堆，请使用初始化为[]的列表，或者您可以通过函数heapify()将填充列表转换为堆。
堆元素可以为元组。这样在第一个值（被比较的值）旁边添一个你实际要排序额值</p>
<pre><code class="language-python">pri_que = [] #小顶堆
#用固定大小为k的小顶堆，扫描所有频率的数值
for key, freq in map_.items():
	heapq.heappush(pri_que, (freq, key))
	#堆元素可以为元组。这样在第一个值（被比较的值）旁边添一个你实际要排序额值
	if len(pri_que) &gt; k: 
	#如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
		heapq.heappop(pri_que)
取出来值只要用queItem[1]
</code></pre>

<h1>2023-10-09</h1><p>#English
premises 以..基础，房产
on-premises capabilities 本地(运行)能力
&quot;Greenfield&quot; 指的是一个全新的项目或系统，没有任何既有的基础设施、代码或限制。
&quot;Brownfield&quot; 相对比，指的是已经存在的、有一定规模和复杂性的项目或系统。</p>
<ul>
<li>23:07 #typescript/type <br>声明一个数组，数组内的属性可以有<br>type Address = [number, string];<br>const address: Address = [2, &quot;Other St.&quot;]; ^a3fbit</li>
</ul>
<h1>cloud services models</h1>
<p>key differenct between IaaS PaaS Saas
<img src="file://Mac/Home/myGitHubMac/simple-read/_resources/Pasted image 20231009113615.png" /></p>
<h1>IT Architectures</h1>
<p>1 blueprint for different engineerning to see how to work
including security engineer, application engineer, IT admin, Data</p>
<p>For human it is digrams
For machine it is IaS(infrastructure ass code)</p>
<h1>cloud native  cloud hosted(enabled)</h1>
<p>cloud hosted(enabled) : develop in tradition way and up to cloud</p>
<h1>7R migration</h1>
<p>retire
rehost replatform
refractor revise rebuild</p>
<ul>
<li>变更的程度依次变大
<ul>
<li>refractor:不改变功能，不改变架构</li>
<li>revise: 可能会改变架构
如果要将一个单体Java应用程序重新设计，将其功能分解为更小的并行块 则是revise
如果不分解，直接编写，修改了架构相关部署。则是 refractor
replace</li>
</ul>
</li>
</ul>
<h2>树的种类</h2>
<p>#BalancedBinaryTree
两边树的高度差不超过 1
搜索树 是 root的点大于左子树中所有的点，小于右子树中所有的点</p>
<ul>
<li>特性是中序搜索是一个有序的数组</li>
</ul>
<p>AVL树：AVL树是最早提出的平衡二叉树之一，它是以其发明者Adelson-Velsky和Landis的姓氏命名的。在AVL树中，任意节点的左右子树的高度差不超过1，并且左右子树也都是AVL树。
红黑树：红黑树是一种自平衡的二叉搜索树，它通过在每个节点上添加额外的颜色信息来保持平衡。红黑树的特点是：根节点和叶子节点是黑色的，红色节点的两个子节点都是黑色的，从任意节点到其每个叶子的路径都包含相同数量的黑色节点。
B树：B树是一种多路搜索树，它可以拥有多个子节点。B树的特点是：每个节点可以拥有多个子节点，子节点之间的值有序排列，同时保持平衡。B树通常用于磁盘和数据库系统中，因为它能够减少磁盘I/O操作次数，提高访问效率。</p>

<h1>2023-10-10</h1><h1>#js/type</h1>
<p>js获取对象的方法 obj
typeof obj 缺点是 不能鉴定数组
obj instanceof XX 缺点是不能鉴定 number,str
Object.prototype.toString().call(obj)
return Object.prototype.toString.call(obj).slice(8,-1)</p>
<ul>
<li>返回的 Type 第一字母，如 Undefined，Object</li>
</ul>
<h2>#front/form
为什么在 form 中，button 可以直接触发 onsubmit</h2>
<p>&lt;button type=&quot;submit&quot;&gt;: By default,&lt;button&gt;s have type=&quot;submit&quot; as default and when used in &lt;form&gt;s, will trigger a form submission.
&lt;input type=&quot;submit&quot;&gt;: The element will be rendered as a button and clicking the &lt;input&gt; will trigger a form submission.</p>
<p>#English
brace花括号
bracket
parenthesis
Recursively build the left subtree on the subarray prefix  在数组前侧递归 build 左树</p>
<p>#Database/noSql</p>
<h1>NoSQL的选择</h1>
<p>KV存储: 最适合简单查询的场景，数据结构简单，通过唯一键进行访问。
文档存储: 适用于字段丰富的复杂文档，可以整体检索和处理。如医疗系统的记录,需要consistency, avoid joins
列存储: 高效进行大数据读写，特别是只访问部分信息的场景。用于取部分数据分析
图存储: 处理高度互联的数据，展现复杂关系，适用于社交网络,推荐等场景。
#Database/ACID
ACID 是</p>
<ul>
<li>Atomicity（原子性）、Consistency（前后一致性）</li>
<li>Isolation（事务隔离性）、和 Durability（影响持久性）</li>
</ul>
<h2>#Database/consistency</h2>
<p>插入一致性（Insert Consistency）：
当我们讨论&quot;插入一致性&quot;时，我们是指在插入新文档或数据时，数据库如何处理一致性。一致性是指系统的数据在全局是同步的，即系统的每一部分都有相同、最新的数据副本。
强一致性（Strong Consistency）: 在强一致性模型中，一旦写入操作返回给写入者，读取操作就会返回最新写入的值。这意味着一旦文档被插入，任何后续的读取请求都会看到这个新文档，系统不会返回旧数据。
最终一致性（Eventual Consistency）: 最终一致性是分布式数据库常用的模型之一，它在可用性和分区容忍性方面提供了更多的灵活性。在这种模型中，新插入的数据可能不会立即对所有用户可见，但系统最终会更新所有副本并达成一致状态。这种方法可能导致所谓的&quot;延迟一致性&quot;。</p>
<h2>#leetcode/二叉树返回情况</h2>
<p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<p>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先中介绍）
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（路径和=固定值的情况）</p>
<h2>#leetcode/tree/inorder</h2>
<p>中序遍历（迭代法）
为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：</p>
<p>处理：将元素放进result数组中
访问：遍历节点
分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</p>
<p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。</p>
<p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</p>

<h1>2023-10-11</h1><p>#English
XML: extensive markup language
disposability: 可弃，
decomposition: 分解</p>
<h2>array 查找元素</h2>
<h2>indexOf方法获取 index
includes 判断是否有对应元素
find 接受一个 fn 查找对应元素
array获取索引 #js/array</h2>
<ol>
<li>indexOf方法</li>
<li>findIndex方法</li>
<li>find+indexOf方法
find和 findIndex 都接受一个函数用来查找
array获取索引</li>
</ol>
<hr>
<ol start="5">
<li>使用 <code>indexOf()</code> 方法：<code>indexOf()</code> 方法返回数组中第一个匹配项的索引，如果没有找到匹配项，则返回 -1。例如：</li>
</ol>
<pre><code class="language-javascript">const arr = [1, 2, 3, 4, 5];
console.log(arr.indexOf(3)); // 输出 2
</code></pre>
<ol start="2">
<li>使用 <code>findIndex()</code> 方法：<code>findIndex()</code> 方法返回数组中符合条件的第一个元素的索引，如果没有找到符合条件的元素，则返回 -1。例如：</li>
</ol>
<pre><code class="language-javascript">const arr = [1, 2, 3, 4, 5];
const index = arr.findIndex(item =&gt; item === 3);
console.log(index); // 输出 2
</code></pre>
<ol start="3">
<li>使用 <code>find()</code> 方法结合 <code>indexOf()</code> 方法：<code>find()</code> 方法返回数组中符合条件的第一个元素，然后使用 <code>indexOf()</code> 方法获取该元素的索引。例如：</li>
</ol>
<pre><code class="language-javascript">const arr = [1, 2, 3, 4, 5];
const element = arr.find(item =&gt; item === 3);
const index = arr.indexOf(element);
console.log(index); // 输出 2
</code></pre>
<h2>Object获取特定属性 #js/obj</h2>
<p>在 JavaScript 中，可以使用不同的方法来判断一个对象是否具有某个属性。</p>
<ol>
<li>hasOwnProperty</li>
<li>in 运算符(包括原型链)</li>
<li>Object.keys遍历</li>
</ol>
<hr>
<ol start="4">
<li>使用 <code>hasOwnProperty()</code> 方法：<code>hasOwnProperty()</code> 方法用于检查对象是否具有指定的属性。它返回一个布尔值，表示对象是否具有该属性。例如：</li>
</ol>
<pre><code class="language-javascript">const obj = { a: 1, b: 2, c: 3 };
console.log(obj.hasOwnProperty('b')); // 输出 true
console.log(obj.hasOwnProperty('d')); // 输出 false
</code></pre>
<ol start="2">
<li>使用 <code>in</code> 运算符：<code>in</code> 运算符用于检查对象是否具有指定的属性，包括原型链中的属性。它返回一个布尔值，表示对象是否具有该属性。例如：</li>
</ol>
<pre><code class="language-javascript">const obj = { a: 1, b: 2, c: 3 };
console.log('b' in obj); // 输出 true
console.log('d' in obj); // 输出 false
</code></pre>
<ol start="3">
<li>使用 <code>Object.keys()</code> 方法结合 <code>includes()</code> 方法：<code>Object.keys()</code> 方法返回一个包含对象自身可枚举属性的数组，然后使用 <code>includes()</code> 方法检查属性是否存在于数组中。例如：</li>
</ol>
<pre><code class="language-javascript">const obj = { a: 1, b: 2, c: 3 };
const keys = Object.keys(obj);
console.log(keys.includes('b')); // 输出 true
console.log(keys.includes('d')); // 输出 false
</code></pre>
<h2>set 结构没有 get #js/set</h2>
<p>Set 数据结构在 JavaScript 中没有直接提供 <code>get()</code> 方法。这是因为 Set 是一种集合，其中的值是唯一的，没有与之关联的键。所以，Set 中的值是无序的，无法通过索引或键来获取特定的值。</p>
<p>如果想要获取 Set 中的值，可以使用 <code>values()</code> 方法或者使用迭代器来遍历 Set 中的值。例如：</p>
<h2>set和 map 的常见方法 #js/set</h2>
<p>他们的常见方法基本一致，除了 set 没有 get 方法</p>
<ol>
<li><code>set(key, value)</code>：向 Map 中设置一个键值对。</li>
<li><code>get(key)</code>：获取指定键对应的值。</li>
<li><code>has(key)</code>：检查 Map 中是否存在指定的键，返回一个布尔值。</li>
<li><code>delete(key)</code>：从 Map 中删除指定的键值对。</li>
<li><code>size</code>：获取 Map 中键值对的数量。</li>
</ol>
<h2>keys  values entries #js/iterator</h2>
<p>你可以用 Object.keys,values,entries对一个特定的对象返回数组，
但是 set和 map的下列方法返回的是一个迭代器，方便你在for里面循环</p>
<ol>
<li><code>keys()</code>：返回一个包含 Map 中所有键的迭代器。</li>
<li><code>values()</code>：返回一个包含 Map 中所有值的迭代器。</li>
<li><code>entries()</code>：返回一个包含 Map 中所有键值对的迭代器。
<ol>
<li>set返回的键值相同，{ [ 'name', 'name' ], [ 'age', 'age' ] }</li>
</ol>
</li>
</ol>
<h3>JS的单线程</h3>
<p>当JS代码被执行时，它会阻塞浏览器的主线程，也就是说，一旦JS代码开始执行，浏览器的其他操作，例如用户交互、页面渲染等，将会暂时被阻塞。这是因为JS是单线程的，一次只能执行一个任务。</p>
<p>具体来说，在网页中，当浏览器加载和执行JS代码时，会出现以下情况：</p>
<p>阻塞解析：当浏览器遇到&lt;script&gt;标签时，它会立即停止解析HTML文档，去下载并执行对应的JS文档。这会阻塞后续HTML内容的解析和渲染，直到JS文档加载和执行完毕。
异步加载：为了避免阻塞页面的加载和渲染，开发者可以将JS代码以异步方式加载。通过添加async或defer属性到&lt;script&gt;标签，可以告诉浏览器在加载JS文档时不阻塞HTML的解析和渲染。其中，async属性表示立即开始下载JS文档，并在下载完成后立即执行，而defer属性表示在HTML解析完毕后再执行JS文档。</p>
<h2>#python/math</h2>
<p>module 'math' has no attribute 'max'
直接用 max,min,abs</p>
<h2>#python/类型转换</h2>
<p>可以用 str() 把 int 类型转成 字符串类型
用 chr( ) 把 ASCII 码转成字母</p>
<h2>#python/nonlocal</h2>
<p>在Python中，如果你想在嵌套函数中修改嵌套作用域外的变量，你需要使用nonlocal关键字。</p>
<p>你的代码中，ans是在sumOfLeftLeaves函数的作用域中定义的，但是在dfs函数中被修改。这是不允许的，除非你在dfs函数中使用nonlocal ans来声明你想要修改的是外部作用域的ans。</p>
<h2>#python/type</h2>
<p>树节点定义class TreeNode:
链表节点定义 class ListNode</p>
<h2>#leetcode/tree/search_tree</h2>
<p>搜索二叉树是不能取等号的</p>

<h1>Handling Events – React</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://legacy.reactjs.org/docs/handling-events.html">legacy.reactjs.org</a></p>
</blockquote>
<p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences:</p>
<ul>
<li>React events are named using camelCase, rather than lowercase.</li>
<li>With JSX you pass a function as the event handler, rather than a string.
For example, the HTML:</li>
</ul>
<pre><code>&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;

</code></pre>
<p>is slightly different in React:</p>
<pre><code>&lt;button onClick={activateLasers}&gt;  Activate Lasers
&lt;/button&gt;

</code></pre>
<h2>Prevent default behavior In React and html</h2>
<p>Another difference is that you cannot return <code>false</code> to prevent default behavior in React. You must call <code>preventDefault</code> explicitly. For example, with plain HTML, to prevent the default form behavior of submitting, you can write:</p>
<pre><code>&lt;form onsubmit=&quot;console.log('You clicked submit.'); return false&quot;&gt;
  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>In React, this could instead be:</p>
<pre><code>function Form() {
  function handleSubmit(e) {
    e.preventDefault();    console.log('You clicked submit.');
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}

</code></pre>
<hr>
<p>Here, <code>e</code> is a synthetic event. React defines these synthetic events according to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/">W3C spec</a>, so you don’t need to worry about cross-browser compatibility. React events do not work exactly the same as native events. See the <a href="https://legacy.reactjs.org/docs/events.html"><code>SyntheticEvent</code></a> reference guide to learn more.</p>
<p>When using React, you generally don’t need to call <code>addEventListener</code> to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p>
<p>When you define a component using an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this <code>Toggle</code> component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
<pre><code>class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

        this.handleClick = this.handleClick.bind(this);  }

  handleClick() {    this.setState(prevState =&gt; ({      isToggleOn: !prevState.isToggleOn    }));  }
  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;        {this.state.isToggleOn ? 'ON' : 'OFF'}
      &lt;/button&gt;
    );
  }
}

</code></pre>
<h2>Passing Arguments to Event Handlers</h2>
<p>Inside a loop, it is common to want to pass an extra parameter to an event handler. For example, if <code>id</code> is the row ID, either of the following would work:</p>
<pre><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;

</code></pre>
<p>The above two lines are equivalent, and use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> respectively.</p>
<p>In both cases, the <code>e</code> argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with <code>bind</code> any further arguments are automatically forwarded.</p>

<h1>JavaScript trivia questions in front end interviews | Front End Interview Handbook</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.frontendinterviewhandbook.com/javascript-questions/">www.frontendinterviewhandbook.com</a></p>
</blockquote>
<h3>Explain event delegation<a href="#explain-event-delegation" title="Direct link to Explain event delegation">​</a></h3>
<p>Event delegation is a technique involving</p>
<ul>
<li>adding event listeners to a parent element</li>
<li>instead of adding them to the descendant elements.
The listener will fire whenever the event is triggered on the descendant elements due to event bubbling up the DOM.<br>
(use target to detect the element ;CurrentTarget is parent element)</li>
</ul>
<p>The benefits of this technique are:</p>
<ul>
<li>Memory footprint goes down because only one single handler is needed on the parent element</li>
<li>There is no need to unbind the handler from elements that are removed and to bind the event for new elements.</li>
</ul>
<h3>Explain how <code>this</code> works in JavaScript<a href="#explain-how-this-works-in-javascript" title="Direct link to explain-how-this-works-in-javascript">​</a></h3>
<p>depondes on context</p>
<ol>
<li>global context: get windows or global(node)</li>
<li>function context:
<ol>
<li>dependon how call, obj call, this refered to obj</li>
<li>arrow function is different, its this 被永久绑定到了它外层函数的 this。
<ol>
<li>not decided this</li>
<li>this dont change</li>
</ol>
</li>
</ol>
</li>
<li>contructor context:  refer to newly created obj</li>
<li>eventlistener context: refer to DOM element that trigger event</li>
</ol>
<h3>Arrow <code>this</code> not change</h3>
<p>例子如下
如果是普通函数</p>
<pre><code>class person{
  age=0
  grow=()=&gt;{
    this.age++
    return this.age
  }
}
p1 = new person()
let obj={
  age:-100,
}
obj.grow=p1.grow
console.log(p1.grow())1   
console.log(obj.grow())2  普通函数：-99
console.log(obj.grow())3  普通函数：-98
console.log(obj.grow())4
</code></pre>
<h3>Arrow <code>this</code> problems</h3>
<p>since arrow function prevent the caller from controlling context via <code>.call</code> or <code>.apply</code>—
the consequences being that a library such as <code>jQuery</code> will not properly bind <code>this</code> in your event handler functions.
Thus, it's important to keep this in mind when refactoring large legacy applications.</p>
<h3>Explain how prototypal inheritance works</h3>
<h3>函数的<code>prototype</code>和对象的<code>prototype</code>是不同的。</h3>
<ol>
<li>函数的<code>prototype</code>：每个函数都有一个<code>prototype</code>属性，它是一个对象。他是用于给通过该构造函数创建的实例对象添加共享的属性和方法。</li>
<li>对象的<code>prototype</code>：每个对象都有一个<code>__proto__</code>（或者ES6中的<code>[[Prototype]]</code>）属性，它指向该对象的原型（也就是另外一个对象）</li>
</ol>
<ul>
<li>函数的<code>prototype</code>属性是一个对象，</li>
<li>对象的<code>__proto__</code>属性是一个指向该对象的原型的引用，通过原型链的机制，对象可以访问和继承原型对象上的属性和方法。</li>
</ul>
<hr>
<pre><code>通过函数的`prototype`，我们可以给所有通过该构造函数创建的对象添加共享的属性和方法。
</code></pre>
<p>示例：</p>
<pre><code class="language-javascript">function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log(`Hello, my name is ${this.name}`);
};

const person1 = new Person('John');
person1.sayHello(); // 输出: Hello, my name is John
</code></pre>
<p><img src="file://Mac/Home/myGitHubMac/simple-read/_resources/Pasted image 20231010122134.png" /></p>
<hr>
<ol start="2">
<li>对象的<code>prototype</code>：每个对象都有一个<code>__proto__</code>（或者ES6中的<code>[[Prototype]]</code>）属性，它指向该对象的原型（也就是另外一个对象）
通过原型链的机制，我们可以访问和继承原型对象上的属性和方法。</li>
</ol>
<pre><code class="language-javascript">const parent = {
  name: 'John',
  age: 40
};

const child = Object.create(parent);
console.log(child.__proto__ \=\== parent); // 输出: true
console.log(child.name); // 输出: John
</code></pre>
<p>在这个例子中，<code>child</code>对象的原型<code>__proto__</code>指向<code>parent</code>对象，因此<code>child</code>对象可以访问和继承<code>parent</code>对象上的属性。</p>
<h3>Object.create 实现</h3>
<p>要实现一个类似于<code>Object.create()</code>的函数，可以按照以下步骤进行：</p>
<pre><code class="language-javascript">function createObject(proto) {
  // 创建一个空对象
  const obj = {};
  // 将空对象的原型指向传入的proto对象
  obj.__proto__ = proto;
  
  // ES6 方法
  const obj = Object.create(null);
  // 将空对象的原型设置为传入的proto对象
  Object.setPrototypeOf(obj, proto);
  return obj;
}
</code></pre>
<p>这个自定义的<code>createObject()</code>函数接受一个参数<code>proto</code>，表示要设置为新对象的原型对象。它执行以下操作：</p>
<ol>
<li>创建一个空对象<code>obj</code>。</li>
<li>将<code>obj</code>的<code>__proto__</code>属性设置为传入的<code>proto</code>对象，从而将新对象的原型指向<code>proto</code>对象。</li>
<li>返回新创建的对象<code>obj</code>。
注意尽管__proto__属性在大多数现代浏览器中都被支持，但它是非标准的属性。在ES6中，推荐使用Object.getPrototypeOf()和Object.setPrototypeOf()来访问和设置对象的原型。
因此可以把上面的改写</li>
</ol>
<h3>What do you think of ES moudle vs CommonJS?<a href="#what-do-you-think-of-amd-vs-commonjs" title="Direct link to What do you think of AMD vs CommonJS?">​</a></h3>
<p>加载方式：</p>
<ul>
<li>ES模块是在编译时加载，也就是在脚本开始执行之前加载所有模块。
<ul>
<li>这意味着它可以进行静态分析，并且可以在编译时进行优化。</li>
</ul>
</li>
<li>CommonJS是在运行时加载，也就是在代码执行过程中动态加载模块。
导入和导出的特性：</li>
<li>ES模块的导入和导出是静态的，意味着导入和导出的模块路径必须是字符串常量，不能使用变量。</li>
<li>CommonJS的导入和导出是动态的，可以使用变量作为模块路径。</li>
</ul>
<h3>What is a closure, and how/why would you use one?<a href="#what-is-a-closure-and-howwhy-would-you-use-one" title="Direct link to What is a closure, and how/why would you use one?">​</a></h3>
<p>A closure is the combination of a function and the lexical environment within which that function was declared.
Closures are functions that have access to the outer (enclosing) function's variables—scope chain even after the outer function has returned.</p>
<p><strong>Why would you use one?</strong></p>
<ul>
<li>Data privacy / emulating private methods with closures. Commonly used in the <a href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript">module pattern</a>.</li>
<li><a href="https://medium.com/javascript-scene/curry-or-partial-application-8150044c78b8#.l4b6l1i3x">Partial applications or currying</a>.</li>
</ul>
<h3>What's the difference between host objects and native objects?<a href="#whats-the-difference-between-host-objects-and-native-objects" title="Direct link to What's the difference between host objects and native objects?">​</a></h3>
<p>Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as <code>String</code>, <code>Math</code>, <code>RegExp</code>, <code>Object</code>, <code>Function</code>, etc.
Host objects are provided by the runtime environment (browser or Node), such as <code>window</code>, <code>XMLHTTPRequest</code>, etc.</p>
<h3>Difference between: <code>function Person(){}</code>, <code>var person = Person()</code>, and <code>var person = new Person()</code>?<a href="#difference-between-function-person-var-person--person-and-var-person--new-person" title="Direct link to difference-between-function-person-var-person--person-and-var-person--new-person">​</a></h3>
<p><code>var person = Person()</code> invokes the <code>Person</code> as a function, and not as a constructor. Invoking as such is a common mistake if the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return <code>undefined</code> and that gets assigned to the variable intended as the instance.</p>
<p><code>var person = new Person()</code> creates an instance of the <code>Person</code> object using the <code>new</code> operator, which inherits from <code>Person.prototype</code>. An alternative would be to use <code>Object.create</code>, such as: <code>Object.create(Person.prototype)</code>.</p>
<h3>What's the difference between <code>.call</code> and <code>.apply</code>?<a href="#whats-the-difference-between-call-and-apply" title="Direct link to whats-the-difference-between-call-and-apply">​</a></h3>
<p>An easy way to remember this is C for <code>call</code> and comma-separated and A for <code>apply</code> and an array of arguments.</p>
<h3>When would you use <code>document.write()</code>?<a href="#when-would-you-use-documentwrite" title="Direct link to when-would-you-use-documentwrite">​</a></h3>
<p><code>document.write()</code> writes a string of text to a document stream opened by <code>document.open()</code>.
When <code>document.write()</code> is executed after the page has loaded, it will call <code>document.open</code> which clears the whole document (<code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> removed!) and replaces the contents with the given parameter value. Hence it is usually considered dangerous and prone to misuse.</p>
<p>#interview
Please do correct me if I'm wrong about this.</p>
<h3>What's the difference between feature detection, feature inference,?<a href="#whats-the-difference-between-feature-detection-feature-inference-and-using-the-ua-string" title="Direct link to What's the difference between feature detection, feature inference, and using the UA string?">​</a></h3>
<p><strong>Feature Detection</strong>
Feature detection involves
working out whether a browser supports a certain block of code, and running different code depending on whether it does (or doesn't),
<strong>Feature Inference</strong>
Feature inference checks for a feature just like feature detection, but uses another function because it assumes it will also exist
This is not really recommended. Feature detection is more fool proof.</p>
<pre><code>if ('geolocation' in navigator) {  
// Can use navigator.geolocation} 
else {  // Handle lack of feature}
</code></pre>
<h3>UA String</h3>
<p>This is a browser-reported string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent. It can be accessed via <code>navigator.userAgent</code>. However, the string is tricky to parse and can be spoofed. For example, Chrome reports both as Chrome and Safari. So to detect Safari you have to check for the Safari string and the absence of the Chrome string. Avoid this method.</p>
<h3>What are the advantages and disadvantages of using Ajax?<a href="#what-are-the-advantages-and-disadvantages-of-using-ajax" title="Direct link to What are the advantages and disadvantages of using Ajax?">​</a></h3>
<p><strong>Advantages</strong></p>
<ul>
<li>Better interactivity. enables real-time updates and interactions on web pages,</li>
<li>Reduce connections to the server since scripts and stylesheets only have to be requested once.</li>
<li>Basically most of the advantages of an SPA.
<strong>Disadvantages</strong></li>
<li>Some webcrawlers do not execute JavaScript  hard SEO</li>
<li>low-end mobile devices might struggle with this.</li>
</ul>
<h3>What's the difference between an&quot;attribute&quot;and a&quot;property&quot;?[​](#whats-the-difference-between-an-attribute-and-a-property &quot;Direct link to What's the difference between an &quot;attribute&quot; and a &quot;property&quot;?&quot;)</h3>
<p>Attributes are defined on the HTML markup but properties are defined on the DOM.
To illustrate the difference, imagine we have this text field in our HTML: <code>&lt;input type=&quot;text&quot; value=&quot;Hello&quot;&gt;</code>.
But after you change the value of the text field by adding &quot;World!&quot; to it, this becomes:</p>
<pre><code>const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Helloconsole.log(input.value); // Hello
</code></pre>
<h3>Why is extending built-in JavaScript objects not a good idea?<a href="#why-is-extending-built-in-javascript-objects-not-a-good-idea" title="Direct link to Why is extending built-in JavaScript objects not a good idea?">​</a></h3>
<p>when  your code uses a few libraries that both extend the <code>Array.prototype</code> by adding the same <code>contains</code> method, the implementations will overwrite each other and your code will break if the behavior of these two methods is not the same.</p>
<p>The only time you may want to extend a native object is when you want to create a polyfill, essentially providing your own implementation for a method that is part of the JavaScript specification but might not exist in the user's browser due to it being an older browser.</p>
<h3>Difference between document <code>load</code> event and document <code>DOMContentLoaded</code> event?<a href="#difference-between-document-load-event-and-document-domcontentloaded-event" title="Direct link to difference-between-document-load-event-and-document-domcontentloaded-event">​</a></h3>
<p>The <code>DOMContentLoaded</code> event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.此时可能某些资源（如图像）尚未加载完成。
<code>window</code>'s <code>load</code> event is only fired after the DOM and all dependent resources and assets have loaded.</p>
<h3>Why is it called a Ternary expression, what does the word &quot;Ternary&quot; indicate?[​](#why-is-it-called-a-ternary-expression-what-does-the-word-ternary-indicate &quot;Direct link to Why is it called a Ternary expression, what does the word &quot;Ternary&quot; indicate?&quot;)</h3>
<p>&quot;Ternary&quot; indicates three, and a ternary expression accepts three operands, the test condition, the &quot;then&quot; expression and the &quot;else&quot; expression.
Ternary expressions are not specific to JavaScript and I'm not sure why it is even in this list.</p>
<h3>What is <code>&quot;use strict&quot;;</code>? What are the advantages and disadvantages to using it?<a href="#what-is-use-strict-what-are-the-advantages-and-disadvantages-to-using-it" title="Direct link to what-is-use-strict-what-are-the-advantages-and-disadvantages-to-using-it">​</a></h3>
<p>Disadvantages:</p>
<ul>
<li>No more access to <code>function.caller</code> and <code>function.arguments</code>.</li>
<li>Concatenation of scripts written in different strict modes might cause issues.</li>
</ul>
<h3>Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?<a href="#why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it" title="Direct link to Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?">​</a></h3>
<p>Every script has access to the global scope, and if everyone uses the global namespace to define their variables, collisions will likely occur. Use the module pattern (IIFEs) to encapsulate your variables within a local namespace.</p>
<h3>What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?<a href="#what-are-some-of-the-advantagesdisadvantages-of-writing-javascript-code-in-a-language-that-compiles-to-javascript" title="Direct link to What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?">​</a></h3>
<p>Disadvantages:</p>
<ul>
<li>Require a build/compile process as browsers only run JavaScript and your code will need to be compiled into JavaScript before being served to browsers.</li>
<li>Debugging can be a pain if your source maps do not map nicely to your pre-compiled source.</li>
</ul>
<p>Practically, ES2015 has vastly improved JavaScript and made it much nicer to write. I don't really see the need for CoffeeScript these days.</p>
<h3>What language constructions do you use for iterating over object properties and array items?<a href="#what-language-constructions-do-you-use-for-iterating-over-object-properties-and-array-items" title="Direct link to What language constructions do you use for iterating over object properties and array items?">​</a></h3>
<h4>For objects iterating:</h4>
<ul>
<li><code>for-in</code> loops - <code>for (var property in obj) { console.log(property); }</code>. However, this will also iterate through its inherited properties, and you will add an <code>obj.hasOwnProperty(property)</code> check before using it.</li>
<li><code>Object.keys()</code> - <code>Object.keys(obj).forEach(function (property) { ... })</code>. <code>Object.keys()</code> is a static method that will lists all enumerable properties of the object that you pass it.</li>
<li><code>Object.getOwnPropertyNames()</code> - <code>Object.getOwnPropertyNames(obj).forEach(function (property) { ... })</code>. <code>Object.getOwnPropertyNames()</code> is a static method that will lists all enumerable and non-enumerable properties of the object that you pass it.</li>
</ul>
<h4>For arrays objects:</h4>
<ul>
<li><code>for</code> loops - <code>for (var i = 0; i &lt; arr.length; i++)</code>. The common pitfall here is that <code>var</code> is in the function scope and not the block scope and most of the time you would want block scoped iterator variable. ES2015 introduces <code>let</code> which has block scope and it is recommended to use that instead. So this becomes: <code>for (let i = 0; i &lt; arr.length; i++)</code>.</li>
<li><code>forEach</code> - <code>arr.forEach(function (el, index) { ... })</code>. This construct can be more convenient at times because you do not have to use the <code>index</code> if all you need is the array elements. There are also the <code>every</code> and <code>some</code> methods which will allow you to terminate the iteration early.</li>
<li><code>for-of</code> loops - <code>for (let elem of arr) { ... }</code>. ES6 introduces a new loop, the <code>for-of</code> loop, that allows you to loop over objects that conform to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol">iterable protocol</a> such as <code>String</code>, <code>Array</code>, <code>Map</code>, <code>Set</code>, etc. It combines the advantages of the <code>for</code> loop and the <code>forEach()</code> method. The advantage of the <code>for</code> loop is that you can break from it, and the advantage of <code>forEach()</code> is that it is more concise than the <code>for</code> loop because you don't need a counter variable. With the <code>for-of</code> loop, you get both the ability to break from a loop and a more concise syntax.</li>
</ul>
<pre><code>const arr = ['a', 'b', 'c'];
for (let [index, elem] of arr.entries()) {  
	console.log(index, ': ', elem);
}
</code></pre>
<h3>Explain the difference between mutable and immutable objects.<a href="#explain-the-difference-between-mutable-and-immutable-objects" title="Direct link to Explain the difference between mutable and immutable objects.">​</a></h3>
<p>Immutability is a core principle in functional programming, and has lots to offer to object-oriented programs as well.
A mutable object is an object whose state can be modified after it is created.
An immutable object is an object whose state cannot be modified after it is created.</p>
<h4>What is an example of an immutable object in JavaScript?<a href="#what-is-an-example-of-an-immutable-object-in-javascript" title="Direct link to What is an example of an immutable object in JavaScript?">​</a></h4>
<p>In JavaScript, some built-in types (numbers, strings) are immutable, but custom objects are generally mutable.
Some built-in immutable JavaScript objects are <code>Math</code>, <code>Date</code>.</p>
<h4>How to simulateimmutability ob plain objects</h4>
<p>Here are a few ways to add/simulate immutability on plain JavaScript objects.</p>
<ul>
<li>make properties constant</li>
<li>Prevent Extensions</li>
<li>seal</li>
<li>freeize</li>
</ul>
<h4>Object Constant Properties</h4>
<p>By combining <code>writable: false</code> and <code>configurable: false</code>
you can essentially create a constant (cannot be changed, redefined or deleted) as an object property, like:</p>
<pre><code class="language-js">let myObject = {};
Object.defineProperty(myObject, 'number', {  
	value: 42,  writable: false,  configurable: false,
	});
console.log(myObject.number); // 42
myObject.number = 43;console.log(myObject.number); // 42
</code></pre>
<p>configurable（可配置性）：当configurable设为false时，</p>
<ul>
<li>表示该属性不可再次修改writable和configurable的值。</li>
<li>如果configurable设为true，则可以删除该属性，并且可以再次修改writable和configurable的值。</li>
</ul>
<h4>Prevent Extensions</h4>
<p>If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call <code>Object.preventExtensions(...)</code>:</p>
<pre><code class="language-js">var myObject = { a:2,};
Object.preventExtensions(myObject);
myObject.b = 3;
myObject.b; // undefined
</code></pre>
<p>In non-strict mode, the creation of <code>b</code> fails silently. In strict mode, it throws a <code>TypeError</code>.</p>
<h4>Seal</h4>
<p><code>Object.seal()</code> creates a &quot;sealed&quot; object, which means it takes an existing object and essentially calls <code>Object.preventExtensions()</code> on it, but also marks all its existing properties as <code>configurable: false</code>.</p>
<p>So, not only can you not add any more properties, but you also cannot reconfigure or delete any existing properties (though you can still modify their values).</p>
<h4>Freeze</h4>
<p><code>Object.freeze()</code> creates a frozen object, which means it takes an existing object and essentially calls <code>Object.seal()</code> on it,
but it also marks all &quot;data accessor&quot; properties as writable:false, so that their values cannot be changed.
This approach is the highest level of immutability that you can attain for an object itself, as it prevents any changes to the object or to any of its direct properties (though, as mentioned above, the contents of any referenced other objects are unaffected).</p>
<p>Freezing an object does not allow new properties to be added to an object and prevents from removing or altering the existing properties. <code>Object.freeze()</code> preserves the enumerability, configurability, writability and the prototype of the object. It returns the passed object and does not create a frozen copy.</p>
<h4>What are the pros and cons of immutability?<a href="#what-are-the-pros-and-cons-of-immutability" title="Direct link to What are the pros and cons of immutability?">​</a></h4>
<p><strong>Pros</strong></p>
<ul>
<li>Thread-safe - Immutable objects can be safely used between threads in a multi-threaded environment since there is no risk of them being modified in other concurrently running threads.</li>
</ul>
<ul>
<li>Easier change detection - Object equality can be determined in a performant and easy manner through referential equality. This is useful for comparing object differences in React and Redux.</li>
<li>缓存优化：不可变对象可以被安全地用作缓存的键，因为它们的哈希值不会改变。</li>
<li>简化代码逻辑：如函数式编程可以用链式操作来处理数据，而不需要使用循环或变量。</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>内存占用</li>
<li>Performance</li>
<li>Cyclic data structures such as graphs are difficult to build. If you have two objects which can't be modified after initialization, how can you get them to point to each other?</li>
</ul>
<h4>How can you achieve immutability in your own code?<a href="#how-can-you-achieve-immutability-in-your-own-code" title="Direct link to How can you achieve immutability in your own code?">​</a></h4>
<p>One way to achieve immutability is to use libraries like <a href="http://facebook.github.io/immutable-js/">immutable.js</a>, <a href="https://github.com/swannodette/mori">mori</a> or <a href="https://github.com/immerjs/immer">immer</a>.
The alternative is to use <code>const</code> declarations combined with the techniques mentioned above for creation.
For &quot;mutating&quot; objects, use the spread operator, <code>Object.assign</code>, <code>Array.concat()</code>, etc., to create new objects instead of mutate the original object.
Examples:</p>
<pre><code>var immutable = Object.freeze({});
</code></pre>
<h3>Explain the difference between synchronous and asynchronous functions.<a href="#explain-the-difference-between-synchronous-and-asynchronous-functions" title="Direct link to Explain the difference between synchronous and asynchronous functions.">​</a></h3>
<p>Synchronous functions are blocking while asynchronous functions are not.
Heavy duty operations such as loading data from a web server or querying a database should be done asynchronously so that the main thread can continue executing other operations instead of blocking until that long operation to complete (in the case of browsers, the UI will freeze).</p>
<h3>What are the differences between ES6 class and ES5 function constructors?<a href="#what-are-the-differences-between-es6-class-and-es5-function-constructors" title="Direct link to What are the differences between ES6 class and ES5 function constructors?">​</a></h3>
<p>The main difference in the constructor comes when using inheritance.
If we want to create a <code>Student</code> class that subclasses <code>Person</code> and add a <code>studentId</code> field, this is what we have to do in addition to the above.</p>
<pre><code class="language-js">// ES5 Function Constructor
function Student(name, studentId) {  
	Person.call(this, name);  
// Initialize subclass's own members.  
	this.studentId = studentId;
}
Student.prototype=Object.create(Person.prototype);
Student.prototype.constructor = Student;
// ES6 Class
class Student extends Person {  
	constructor(name, studentId) {    
	super(name);    
	this.studentId = studentId;  
}}
</code></pre>
<h3>What advantage is there for using the arrow syntax for a method in a constructor?<a href="#what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor" title="Direct link to What advantage is there for using the arrow syntax for a method in a constructor?">​</a></h3>
<p>The main advantage of using an arrow function as a method inside a constructor is that the value of <code>this</code> gets set at the time of the function creation and can't change after that.
This can be particularly helpful in React class components.
If you define a class method for something such as a click handler using a normal function, and then you pass that click handler down into a child component as a prop, you will need to also bind <code>this</code> in the constructor of the parent component.
If you instead use an arrow function, there is no need to also bind &quot;this&quot;, as the method will automatically get its &quot;this&quot; value from its enclosing lexical context. (See this article for an excellent demonstration and sample code:</p>
<pre><code class="language-js">const Person = function (firstName) {
  this.firstName = firstName;
  this.sayName1 = function () {
    console.log(this.firstName);
  };
  this.sayName2 = () =&gt; {
    console.log(this.firstName);
  };
};

const john = new Person('John');
const dave = new Person('Dave');
// The regular function can have its 'this' value changed, but the arrow function cannot
john.sayName1.call(dave); // Dave (because &quot;this&quot; is now the dave object)
john.sayName2.call(dave); // John
</code></pre>
<h3>What is the definition of a higher-order function?<a href="#what-is-the-definition-of-a-higher-order-function" title="Direct link to What is the definition of a higher-order function?">​</a></h3>
<p>A higher-order function is any function that takes one or more functions as arguments, which it uses to operate on some data, and/or returns a function as a result. Higher-order functions are meant to abstract some operation that is performed repeatedly.
Something like <code>map</code>, <code>filter</code>,<code>reduce</code></p>
<h3>Can you give an example for destructuring an object or an array?<a href="#can-you-give-an-example-for-destructuring-an-object-or-an-array" title="Direct link to Can you give an example for destructuring an object or an array?">​</a></h3>
<pre><code>const [one, two, three] = foo;
[a, b] = [b, a];
const o = {p: 42, q: true};
const {p, q} = o;
</code></pre>
<h3>ES6 Template Literals offer a lot of flexibility in generating strings, can you give an example?<a href="#es6-template-literals-offer-a-lot-of-flexibility-in-generating-strings-can-you-give-an-example" title="Direct link to ES6 Template Literals offer a lot of flexibility in generating strings, can you give an example?">​</a></h3>
<p>Template literals help make it simple to do string interpolation, or to include variables in a string. Before ES2015, it was common to do something like this:</p>
<pre><code>// Variable assignment.const o = {p: 42, q: true};
const {p, q} = o;
console.log(p); // 42console.log(q); // true
</code></pre>
<h3>What are the benefits of using spread syntax and how is it different from rest syntax?<a href="#what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax" title="Direct link to What are the benefits of using spread syntax and how is it different from rest syntax?">​</a></h3>
<p>ES6's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of arrays or objects without resorting to <code>Object.create</code>, <code>slice</code>, or a library function. This language feature is used often in Redux and RxJS projects.</p>
<pre><code class="language-js">function putDookieInAnyArray(arr) {
  return [...arr, 'dookie'];
}
const copyOfTodd = {...person};
</code></pre>
<p>ES6's rest syntax offers a shorthand for including an arbitrary number of arguments to be passed to a function. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.</p>
<pre><code class="language-js">function addFiveToABunchOfNumbers(...numbers) {
  return numbers.map((x) =&gt; x + 5);
}

const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]

const [a, b, ...rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]

const {e, f, ...others} = {
  e: 1,
  f: 2,
  g: 3,
  h: 4,
};
</code></pre>
<h3>Why you might want to create static class members?<a href="#why-you-might-want-to-create-static-class-members" title="Direct link to Why you might want to create static class members?">​</a></h3>
<p>Static class members (properties/methods) are not tied to a specific instance of a class and have the same value regardless of which instance is referring to it.
Static properties are typically configuration variables and static methods are usually pure utility functions which do not depend on the state of the instance.</p>
