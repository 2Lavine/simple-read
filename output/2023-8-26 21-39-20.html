<h1>EPAT</h1><h1>agile</h1>
<p>meanning:: mindset that give ability
why:: project require changes
origin of agile : plan-&gt;do-&gt;study-&gt;act</p>
<h2>4 period of agile</h2>
<p>1 mindset -&gt; 4 values -&gt;12 principles -&gt; unlimited practices</p>
<h3>agile mindset</h3>
<p>agile mindset = Growth Mindset+ law of custormer,small team,network
growth mindset = embrace challenges,learn from criticism...</p>
<h3>manifesto:4 values</h3>
<ul>
<li>interaction&gt;tools processes</li>
<li>working software&gt;doc</li>
<li>customers collaboration&gt;contract negotiation</li>
<li>respond to changes&gt;plan</li>
</ul>
<h3>12 principles</h3>
<h4>interaction&gt;tools</h4>
<ul>
<li>
<ol start="4">
<li>Business people and developers must work together daily throughout the project.</li>
</ol>
</li>
<li>
<ol start="6">
<li>face to face conservation efficient</li>
</ol>
</li>
</ul>
<h4>working software&gt;doc</h4>
<ul>
<li>
<ol start="3">
<li>Deliver working software frequently</li>
</ol>
</li>
<li>
<ol start="7">
<li>Working software is the primary measure of progress.</li>
</ol>
</li>
</ul>
<h4>customers collaboration&gt;contract</h4>
<ul>
<li>
<ol>
<li>Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.</li>
</ol>
</li>
</ul>
<h4>respond to changes&gt;plan</h4>
<ul>
<li>
<ol start="2">
<li>Welcome changing requirements, even late in development.</li>
</ol>
</li>
<li>
<ol start="9">
<li>Continuous attention to technical excellence and good design enhances agility.</li>
</ol>
</li>
<li>
<ol start="12">
<li>At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.</li>
</ol>
</li>
</ul>
<h4>hero team</h4>
<ol start="5">
<li>Build projects around motivated individuals.</li>
<li>Agile processes promote sustainable development,all members maintain a  constant pace indefinitely.</li>
<li>best from self-organized</li>
</ol>
<h4>other</h4>
<ol start="9">
<li>continuous attention to technical
10.simplicity art</li>
</ol>
<h3>sprint</h3>
<p>duration:: 1-4weeks
product:: deliver some value
benefit:: engage customer</p>
<h2>small team</h2>
<p>less 10
cross function
self organized</p>
<h1>Scrum 3role,5events,3product</h1>
<h3>3 role</h3>
<p>developer, srum master, product owner</p>
<h3>5 events:</h3>
<ul>
<li>Sprint,</li>
<li>Sprint Planning,</li>
<li>Daily Scrum,</li>
<li>Sprint Review =》目的是回顾过去的工作成果，与<strong>利益相关者</strong>一起讨论和评估。</li>
<li>Sprint Retrospective.=&gt;目的是回顾过去的Sprint</li>
</ul>
<h3>3 output</h3>
<p>product backlog =&gt;product goal • product backlog are Owned by the Product Owner
sprint backlog =&gt;sprint goal
product increment =&gt;definition of done is decided by PO and Team agree on what does it mean by DONE</p>
<h2>different from waterfall</h2>
<p>self-organized instead own by PM
Continuous review
Promotes single user rep as Product Owner
most teams adopt XP technical practices</p>
<h1>Extreme Programming (XP)</h1>
<p>emphasis small release, adaptive and  iterative
Use metaphor to have common language between customer and development team
share responsibility Collective Ownership
sustainable pace</p>
<h2>XP vs. Waterfall Model</h2>
<p>frequent releast=&gt;</p>
<ul>
<li>have re-prioritization</li>
<li>,believe emergent design</li>
</ul>
<h1>XP vs scrum</h1>
<p>XP prescribes some technical practices</p>
<ul>
<li>pair programming</li>
<li>code standard</li>
<li>testing</li>
<li>refactoring
Scrum prescribe the process of development</li>
</ul>
<h1>Pair programming</h1>
<p>1 driver  1 navigator switched periodically</p>
<ul>
<li>not a must for agile project</li>
<li>only worth for complex code, not rote code</li>
<li>work 15-30min with small breaks</li>
</ul>
<h2>Pair programming include</h2>
<ul>
<li>Pair Analysis and Pair Design</li>
<li>Pair implementation</li>
<li>Pair Testing</li>
</ul>
<h2>strong style</h2>
<p>idea from you head must go through other's hand</p>
<h2>Ping Pong Style</h2>
<ol>
<li>P1 writes a failing test,</li>
<li>P2 take keyboard, makes the test pass</li>
<li>P2 writes a failing test,</li>
</ol>
<h2>Pair Challenges</h2>
<ul>
<li>partner excess ego or too little ego</li>
<li>Support from stakeholder</li>
<li>out of comfort zoon</li>
</ul>
<h2>when Pair</h2>
<ul>
<li>Code that involves design decisions</li>
<li>Complex code</li>
<li></li>
</ul>
<h1>TDD</h1>
<p>A programming practice</p>
<ul>
<li>writenew code only if an automated test has failed</li>
<li>to eliminate duplication</li>
<li>using Test First and Automation to guide the coding process
The goal of TDD is ‘clean code that works’，</li>
</ul>
<h2>WHY TDD</h2>
<p>Enable sustainable growth</p>
<h2>TDD Cycle</h2>
<ul>
<li>red：a failingtest</li>
<li>green: implement code</li>
<li>refractor:improve design</li>
</ul>
<h2>TDD Challenge</h2>
<p>test management
stakeholders Support
some are difficult to test</p>
<h2>Test fixture</h2>
<p>Test fixtures are objects that tests run against
Test fixture 是指在测试过程中所需的准备工作，用于确保测试的可重复性和一致性</p>
<h3>why fixture need set up</h3>
<p>fixture Need to remain in a known, fixed state，Often use up resources
Therefore, often need to be set up before the test and taken down afterwards</p>
<h2>Test Doubles</h2>
<p>“Pretend” objects used in place of real objects
Testest doubles（测试替身）是一种用于模拟或替代系统中的其他对象的技术。
Test Doubles Also called Fake Objects</p>
<h3>Test doubles type</h3>
<ul>
<li>Dummy（哑对象）：占位符对象，没有实际的实现，通常被用作方法的参数</li>
<li>Stub（存根）：具有预定义行为的对象，通常会返回预先定义的值</li>
<li>Spy（间谍）：特殊的存根对象，除了返回预定义的值之外，还可以记录如方法的调用次数、参数等。并在测试中assert 这些次数</li>
<li>Mock（模拟对象）：更高级的间谍对象，可以预先定义方法的行为，并在测试中进行断言以验证代码的行为是否符合预期。</li>
<li>与存根和间谍不同，模拟对象通常会对方法的调用顺序和参数进行严格的验证。</li>
</ul>
<h2>Test Levels</h2>
<p>unit(isolation)<br>
integration (components interaction )
system(whole,usually done to test software quality attributes)</p>
<h2>Test Plan</h2>
<p>test plan is a detailed document which describes software testing areas and activities</p>
<h2>Test Best practice</h2>
<p>test independent of each others
Mock out all external services and state
Keep the DRY principle
meaningful name and description
Run all tests every time you modify code and every build</p>
<h2>Integrating tests into build</h2>
<p>Automated testing can be integrated into build process
Allow testing to be done every buil
Testing time should not be a hindrance to development flow</p>
<h2>Other</h2>
<p>in agile, automotion is key of test
Black Box,Just built around specs and requirements</p>
<h1>Software Architecture</h1>
<p>fundamental structure of a software system,including</p>
<ul>
<li>Components:how they organized</li>
<li>Communication</li>
<li>Constraints
not Only architects are responsible for the software architecture.</li>
</ul>
<h2>Architecture in agile</h2>
<p>build architecture  gradually by a chain of small refactoring</p>
<ul>
<li>see architecture as Big Up-Front Design      against the  effort and documentation</li>
<li>a metaphor would suffice in most cases</li>
</ul>
<h2>Agile Software Architecture</h2>
<p>supports changes,comprehension</p>
<h2>Characteristics of agile SA</h2>
<p>Don’t “craft a new architecture”</p>
<h2>Agile Architecture Lifecycle</h2>
<p>Initial requirement and Architectural(before sprint) and modeling</p>
<ul>
<li>keep simple
develop
communite stakeholder
refine</li>
</ul>
<h2>Agile Modeling</h2>
<p>not to heavy,detailed</p>
<h2>Agile Design</h2>
<p>evolves
focus on the current structure of the system</p>
<h3>SOlID 原则</h3>
<ul>
<li>单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。同时修改一个责任不会影响其他责任。</li>
<li>开放封闭原则（Open-Closed Principle，OCP）：可扩展的，但不可修改的。</li>
<li>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替代其基类</li>
<li>接口隔离原则（Interface Segregation Principle，ISP）：一个类不应该强迫实现它用不到的接口方法</li>
<li>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，应该使用抽象接口。这样能解耦高层和低层组件之间的依赖关系
<ul>
<li>比如只用接口INoitfy的 send，而不是用mailNotify和phoneNotify的 send</li>
<li>这样减少了 coupling，方便增加更多 Notify class</li>
<li></li>
</ul>
</li>
</ul>
<h1>refractor</h1>
<p>a technique used to ‘clean up’ messy code</p>
<h2>node to refractor</h2>
<p>• When the tests are NOT passing
• When we have impending deadlines</p>
<h2>Code Smells</h2>
<p>a sign that a closer look is warranted
doesn’t always indicate a problem</p>
<h2>common code smells</h2>
<p>common</p>
<ul>
<li>long method</li>
<li>long parameter</li>
<li>dead code</li>
<li>dublicate code
Conditional Complexit
:use strategy mode
Data Clump：use class</li>
</ul>
<p>Feature Envy:
- a method that seems more interested in a class other than the one it's actually in.
Refused Bequest:
inheriting code you don't want.</p>
<h1>user story</h1>
<p>User story makes up Product Backlog（main representation of the user requirement）</p>
<h2>who what why</h2>
<p>who: not user but more precise,acurate like  adult user
3C =&gt; card conversation confirmation</p>
<h2>Given-When-Then</h2>
<p>The Given-When-Then formula is a template intended to guide the writing of acceptance tests for a User Story:
(Given) pre condition
(When) some action is carried out
(Then) expected output</p>
<h2>user story responsible</h2>
<p>Product Owner is responsible to ensure that User Stories are written.
However, it is best that the team writes the user stories:(PO can reject them)</p>
<ul>
<li>PO responsible,Master teach.</li>
</ul>
<h2>good user story</h2>
<p>small:</p>
<ul>
<li>Independent</li>
<li>Negotiable: need to be negotiable not to precise</li>
<li>Valuable</li>
<li>Estimatable</li>
<li>small: can be done in a sprint; big can be reduced by crud</li>
<li>Testable</li>
</ul>
<h2>VUCA</h2>
<ul>
<li>stands for volatility, uncertainty, complexity, and ambiguity.
It describes the situation of constant, unpredictable change that is now the norm in certain industries and areas of the business world.</li>
</ul>
<h1> </h1>
<h1>TailwindCSS 的使用，看这一篇就够了！</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7200782261997338681?searchId=2023082216553056BD93B193AD0875235E">juejin.cn</a></p>
</blockquote>
<h2>安装</h2>
<p>以下方法是<code>Vite + Vue</code>模式下的安装方法，其他脚手架与框架的使用同理。</p>
<h3>创建项目</h3>
<pre><code>pnpm create vite app --template vue
# yarn create vite app --template vue
</code></pre>
<h3>安装必要依赖</h3>
<p>Vite 创建的项目默认集成了<code>PostCSS</code>，而<code>TailwindCSS</code>本身就是一个<code>PostCSS</code>插件，所以直接使用即可。</p>
<pre><code>pnpm i -D tailwindcss postcss autoprefixer
# yarn add -D tailwindcss postcss autoprefixer
# npm i -D tailwindcss postcss autoprefixer
</code></pre>
<h3>创建 TailwindCSS 配置文件</h3>
<p>使用<code>tailwindcss</code>的初始化命令创建会更快：</p>
<pre><code>npx tailwindcss init -p
</code></pre>
<p>这一步会做两件事：</p>
<ol>
<li>创建<code>postcss.config.js</code>文件，这里的配置主要是添加<code>tailwindcss</code>的插件，这样你编写的 css 才会被<code>tailwindcss</code>处理；</li>
<li>创建<code>tailwind.config.js</code>文件，主要进行扫描规则、主题、插件等配置。</li>
</ol>
<p>为了打包时 TailwindCSS 能生成对应的样式文件，需要在<code>tailwind.config.js</code>中正确配置<code>content</code>字段，如以下配置将扫描 <code>src</code> 目录下所有以 <code>vue/js/ts/jsx/tsx</code> 结尾的文件。</p>
<pre><code>/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/**/*.{vue,js,ts,jsx,tsx}'
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</code></pre>
<h3><strong>注意</strong></h3>
<p>TailwindCSS 并不会生成一个全量的样式包，而是根据具体使用到的语法生成对应的样式代码，这样可以确保打包产生的样式包是最小的。</p>
<p>参考这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fcontent-configuration" title="https://tailwindcss.com/docs/content-configuration">tailwindcss.com/docs/conten…</a></p>
<h3><strong>引入 Tailwind 的基本指令</strong></h3>
<p><code>tailwind.css</code></p>
<pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<p><code>main.js</code></p>
<pre><code>import './tailwind.css'
</code></pre>
<h2>开始使用</h2>
<p>现在，你可以开始使用 TailwindCSS 的语法了：</p>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;w-32 h-32 bg-blue-500&quot;&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>如上语法，你将在页面看到一个正方形的蓝色盒子：</p>
<p>TailwindCSS 语法检索技巧 TailwindCSS 的基本原则是将每一个 style 语法转换为一个 class，因此，在官网检索想要的样式 class 时，<strong>按照样式的语法来检索是效率最高的</strong>。如想要获取圆角的语法，只需要搜索<code>Border Radius</code>即可：</p>
<h2>自定义 class 中使用 Tailwind 语法？</h2>
<p>有时候，你可能会因为重复的元素而不得不自定义一个 class，如：</p>
<pre><code>&lt;div class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;首页&lt;/div&gt;
&lt;div class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;学习TailwindCSS&lt;/div&gt;
&lt;div class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;TailwindCSS的设计哲学&lt;/div&gt;
&lt;div class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;最佳实践&lt;/div&gt;
</code></pre>
<p>以上写法不仅在开发时会造成重复的困扰，也不利于维护，此时我们会希望给每个元素一个 class，像这样：</p>
<pre><code>&lt;div class=&quot;menu&quot;&gt;首页&lt;/div&gt;
&lt;div class=&quot;menu&quot;&gt;学习TailwindCSS&lt;/div&gt;
&lt;div class=&quot;menu&quot;&gt;TailwindCSS的设计哲学&lt;/div&gt;
&lt;div class=&quot;menu&quot;&gt;最佳实践&lt;/div&gt;
</code></pre>
<p>现在问题来了，在为<code>menu</code>定制样式时，我们该怎样使用 TailwindCSS 语法呢？</p>
<p>TailwindCSS 提供了<code>@apply</code>语法，这种语法的使用手感与在 html 模板中使用是一样的：</p>
<pre><code>.menu {
  @apply p-2 text-gray-900 font-semibold;
}
</code></pre>
<h3><strong>注意</strong></h3>
<ol>
<li>尽管使用<code>@apply</code>语法可以解决样式复用的问题，但并不推荐在早期就进行抽象，<strong>因为自定义 class 的做法会生成更多的样式代码，造成生成的 css 文件变得更大</strong>。</li>
<li>还有一个理由可以证明不使用自定义 class 会更好：你完全可以通过循环的语法来解决此问题：</li>
</ol>
<pre><code>&lt;template&gt;
  &lt;div
    v-for=&quot;menu in ['首页', '学习TailwindCSS', 'TailwindCSS的设计哲学', '最佳实践']&quot;
    :key=&quot;menu&quot;
    class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;{{{ menu }}}&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>这样未来维护时，不仅样式的修改变得更加容易，内容区也会变得更好维护。
关于样式复用的更多信息，可参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Freusing-styles" title="https://tailwindcss.com/docs/reusing-styles">tailwindcss.com/docs/reusin…</a></p>
<h3>抽象成 class的原则</h3>
<p>如果进行的是组件级别的抽象，并且有需要让他人覆盖 class 的场景，则必须使用自定义 class 的方案，别无他选。（推荐组件级别的 class 复用使用 BEM 的命名规范）</p>
<h2>自定义样式中使用 Tailwind 的变量？</h2>
<p>大多数情况下，我们完全可以组合使用 Tailwind 的原子化 class 来解决问题。但如果就是要使用自定义的样式代码，我们该如何使用到 Tailwind 配置中定义的变量呢？</p>
<ul>
<li>因为<code>TailwindCSS</code>本身是一个<code>PostCSS</code>插件，所以理论上任何有关<code>TailwindCSS</code>的配置信息都可以通过 css 的方式拿到。
比如下面的代码中，希望为某个元素添加一个上边框，但是又想要使用到 Tailwind 配置中的<code>gray-200</code>颜色，该怎么办呢？</li>
</ul>
<pre><code>div {
  border-top: 1px solid ?;
}
</code></pre>
<p><code>TailwindCSS</code>提供了一个<code>theme</code>函数，可以拿到<code>tailwind.config.js</code>中配置的<code>theme</code>的值：</p>
<pre><code>div {
  border-top: 1px solid theme('colors.gray.200');
}
</code></pre>
<p>以上代码最后会被编译为：</p>
<pre><code>div {
  border-top: 1px solid #e5e7eb;
}
</code></pre>
<h2>Tailwind 中的 theme</h2>
<pre><code>div {
  border-top: 1px solid theme('colors.gray.200');
}
</code></pre>
<p><code>TailwindCSS</code>认为，所有不使用其变量的值都为魔法值。比如上方的代码，完全可以使用<code>1px solid #e5e7eb</code>来实现，但是未来如果要对颜色进行统一调整，这行代码将无法达到预期效果。</p>
<p>具体可参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Ffunctions-and-directives%23theme" title="https://tailwindcss.com/docs/functions-and-directives#theme">tailwindcss.com/docs/functi…</a></p>
<h2>使用 Tailwind 配置之外的变量？</h2>
<p>有时候，你不得不使用一些超出 Tailwind 配置之外的值，当你接到一个需求：</p>
<blockquote>
<p>在页面绘制一个宽 139px，高 77px，颜色为 #165DFF 的盒子。</p>
</blockquote>
<p>是的！你永远可以相信 TailwindCSS！！因为这种情况，它都考虑到了：</p>
<pre><code>&lt;div class=&quot;w-[139px] h-[77px] bg-[#165DFF]&quot;&gt;&lt;/div&gt;
</code></pre>
<p>使用这种方法有两个好处：</p>
<ol>
<li>开发人员不用离开 html，手感还是那个手感，效率更高；</li>
<li>同样的 class 还是只生成一份样式（10 个<code>w-[139px]</code>最终只会生成一份样式代码），减少了打包后的样式文件大小</li>
</ol>
<blockquote>
<p>尽管这种方法可以优雅地解决问题，但这种 <strong>魔法值</strong> 的方案并不被推荐，因为事实上，这种做法会让样式体系超出规范的范围。如果项目中充斥着这种代码，会给后期的维护造成困难。
参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fadding-custom-styles%23using-arbitrary-values" title="https://tailwindcss.com/docs/adding-custom-styles#using-arbitrary-values">tailwindcss.com/docs/adding…</a></p>
</blockquote>
<h2>全面且好用的响应式方案</h2>
<p>在<code>TailwindCSS</code>中写响应式简直是福音，例如这个绿色（如果你使用 PC 访问，将是蓝色）的盒子：</p>
<pre><code>&lt;div class=&quot;w-32 h-32 bg-green-500&quot; /&gt;
</code></pre>
<p>如果要想让其在<code>768px</code>以上的屏幕上显示为蓝色，你需要这样：</p>
<pre><code>@media (min-width: 768px) {
  div {
    @apply bg-blue-500;
  }
}
</code></pre>
<p>而<code>TailwindCSS</code>只需要一行代码：</p>
<pre><code>&lt;div class=&quot;w-32 h-32 bg-green-500 md:bg-blue-500&quot; /&gt;
</code></pre>
<p>以上代码表示的含义是：默认显示绿色，在最小为<code>md(768px)</code>的屏幕下显示蓝色。</p>
<p><code>TailwindCSS</code>响应式的规则为：</p>
<ol>
<li><strong><code>mobile first</code></strong>，即<strong>手机端优先</strong>，你也可以理解为，什么断点都不设置就相当于断点为 0；</li>
<li>断点的含义是 <strong>大于等于</strong>，即<code>min-width</code>，而非<code>max-width</code>。具体可参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fresponsive-design%23targeting-mobile-screens" title="https://tailwindcss.com/docs/responsive-design#targeting-mobile-screens">tailwindcss.com/docs/respon…</a></li>
</ol>
<blockquote>
<p>具体响应式断点可参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fscreens" title="https://tailwindcss.com/docs/screens">tailwindcss.com/docs/screen…</a></p>
</blockquote>
<p><strong>高级用法</strong> 你甚至可以结合任意值语法，实现各种变态的响应式需求，如：</p>
<h2>暗黑模式</h2>
<p>使用暗黑模式前，你需要在<code>tailwind.config.js</code>中配置：</p>
<pre><code>/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  // more options...
}
</code></pre>
<p>然后，你只需要少量的代码，就可以使用暗黑模式了：</p>
<pre><code>&lt;div class=&quot;w-32 h-32 bg-blue-500 dark:bg-green-500&quot;&gt;&lt;/div&gt;
</code></pre>
<blockquote>
<p>点击右上角切换暗黑模式，上方的蓝色盒子将变成绿色盒子。</p>
</blockquote>
<p>更多使用方法可参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fdark-mode" title="https://tailwindcss.com/docs/dark-mode">tailwindcss.com/docs/dark-m…</a></p>
<h2>重写 / 覆盖 Tailwind 配置</h2>
<p>Tailwind 的默认配置与团队的 UI 规范有出入？莫担心，TailwindCSS 提供了一整套的重写、覆盖默认配置的方案，细粒度到每一个属性。</p>
<p>举个栗子，使用 Tailwind 的配置来实现<code>Arco Design</code>的字体颜色规范：</p>
<pre><code>// tailwind.config.js

/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    extend: {
      textColor: { // [!code focus:5]
        primary: '#1D2129',
        regular: '#4E5969',
        secondary: '#86909C',
        disabled: '#C9CDD4',
      }
    },
  },
  // ...
}
</code></pre>
<p>然后就可以使用了：</p>
<pre><code>&lt;span class=&quot;text-primary&quot;&gt;主色&lt;/span&gt; / 
&lt;span class=&quot;text-regular&quot;&gt;常规色&lt;/span&gt; / 
&lt;span class=&quot;text-secondary&quot;&gt;次要色&lt;/span&gt; / 
&lt;span class=&quot;text-disabled&quot;&gt;禁用色&lt;/span&gt; /
</code></pre>
<h2>放弃使用预处理器</h2>
<blockquote>
<p>Sass/Less/Stylus 等预处理器，给我们带来了什么？</p>
</blockquote>
<p>预处理器在 <code>嵌套语法</code>、<code>变量</code>、<code>常用函数</code>、<code>逻辑处理</code> 等方面相比原生 CSS 有更大的优势，它可以让编写 CSS 代码的效率变得更高。</p>
<p>但当我们使用 TailwindCSS 时，实际推崇的是 TailwindCSS 官方 的 <strong>不离开 html</strong> 、<strong>少样式代码甚至零样式代码</strong> 的价值观。</p>
<p><strong>总结</strong> 预处理器的核心优势是为了让开发人员更快书写样式代码，而 TailwindCSS 旨在消除样式代码
因此，TailwindCSS 官方极力推荐在项目中移除预处理器，具体可参考文档：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fusing-with-preprocessors" title="https://tailwindcss.com/docs/using-with-preprocessors">tailwindcss.com/docs/using-…</a></p>
<h3>在 Tailwind 使用嵌套语法</h3>
<p>TailwindCSS 封装了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fpostcss-nested" title="https://github.com/postcss/postcss-nested">postcss-nested</a> 与 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-nesting" title="https://github.com/jonathantneal/postcss-nesting">postcss-nesting</a> 插件，抛出了一个新的 postcss 插件，你只需要在<code>postcss.config.js</code>文件中加入以下代码，即可在 css 文件中使用嵌套语法了：</p>
<pre><code>module.exports = {
  plugins: {
    'tailwindcss/nesting': {}, // [!code focus]
    tailwindcss: {},
    autoprefixer: {},
  },
}
</code></pre>
<p>更多细节可参考：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftailwindcss.com%2Fdocs%2Fusing-with-preprocessors%23nesting" title="https://tailwindcss.com/docs/using-with-preprocessors#nesting">tailwindcss.com/docs/using-…</a></p>
<h3>语法冲突</h3>
<p>实际上，当你在 sass/scss/less/styl 文件中使用 Tailwind 语法时，可能会发生错误的预期甚至错误，因为 TailwindCSS 的某些语法可能会与预处理器的语法冲突，如在 sass 文件中使用<code>theme</code>函数会得到不同的预期，因为 sass 中也存在这个函数，而这种写法会让 sass 预处理器优先处理这个函数，而实际的期望是希望后处理器来处理。</p>
<p>预处理器的未来？ 参考文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhengxiaoping.xyz%2Fcss%2F%25E9%25A2%2584%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8%25E7%259A%2584%25E6%259C%25AA%25E6%259D%25A5%25EF%25BC%259F.html" title="https://zhengxiaoping.xyz/css/%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E6%9C%AA%E6%9D%A5%EF%BC%9F.html">预处理器的未来？</a></p>
<hr>
<h1> </h1>
<h1>Utility-First Fundamentals - Tailwind CSS</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://tailwindcss.com/docs/utility-first">tailwindcss.com</a></p>
</blockquote>
<h2><a href="#overview">Overview</a></h2>
<p>This approach allows us to implement a completely custom component design without writing a single line of custom CSS.</p>
<p>Now I know what you’re thinking, <em>“this is an atrocity, what a horrible mess!”</em> and you’re right, it’s kind of ugly. In fact it’s just about impossible to think this is a good idea the first time you see it — <strong>you have to actually try it</strong>.</p>
<p>But once you’ve actually built something this way, you’ll quickly notice some really important benefits:</p>
<ul>
<li><strong>You aren’t wasting energy inventing class names</strong>. No more adding silly class names like <code>sidebar-inner-wrapper</code> just to be able to style something, and no more agonizing over the perfect abstract(抽象) name for something that’s really just a flex container.</li>
<li><strong>Your CSS stops growing</strong>. Using a traditional approach, your CSS files get bigger every time you add a new feature. With utilities, everything is reusable so you rarely need to write new CSS.</li>
<li><strong>Making changes feels safer</strong>. CSS is global and you never know what you’re breaking when you make a change. Classes in your HTML are local, so you can change them without worrying about something else breaking.</li>
</ul>
<p>When you realize how productive you can be working exclusively in HTML with predefined utility classes, working any other way will feel like torture.</p>
<h2><a href="#why-not-just-use-inline-styles">Why not just use inline styles?</a></h2>
<p>But using utility classes has a few important advantages over inline styles:</p>
<ul>
<li><strong>Designing with constraints</strong>. Using inline styles, every value is a magic number. With utilities, you’re choosing styles from a predefined <a href="https://tailwindcss.com/docs/theme">design system</a>, which makes it much easier to build visually consistent UIs.</li>
<li><strong>Responsive design</strong>. You can’t use media queries in inline styles, but you can use Tailwind’s <a href="https://tailwindcss.com/docs/responsive-design">responsive utilities</a> to build fully responsive interfaces easily.</li>
<li><strong>Hover, focus, and other states</strong>. Inline styles can’t target states like hover or focus, but Tailwind’s <a href="https://tailwindcss.com/docs/hover-focus-and-other-states">state variants</a> make it easy to style those states with utility classes.</li>
</ul>
<h2>This component is fully responsive and includes a button with hover and focus styles, and is built entirely with utility classes:
<a href="#maintainability-concerns">Maintainability concerns</a></h2>
<p>The biggest maintainability concern when using a utility-first approach is managing commonly repeated utility combinations.</p>
<p>This is easily solved by <a href="https://tailwindcss.com/docs/reusing-styles#extracting-components-and-partials">extracting components and partials</a>, and using <a href="https://tailwindcss.com/docs/reusing-styles#using-editor-and-language-features">editor and language features</a> like multi-cursor editing and simple loops.</p>
<p>Aside from that, maintaining a utility-first CSS project turns out to be a lot easier than maintaining a large CSS codebase, simply because HTML is so much easier to maintain than CSS.</p>
<h1> </h1>
<h1>fiber.updateQueue</h1><p>fiber 的 updateQueue 属性在不同类型的 fiber 节点中含义不同，
主要由<code>HostRoot</code>、<code>HostComponent</code>、<code>ClassComponent</code>、<code>FunctionComponent</code>这几种类型的 fiber updateQueue 的作用。</p>
<h2>概述</h2>
<ul>
<li>在 HostRoot Fiber 中，<code>updateQueue</code>存的是<code>ReactDOM.render/ReactDOM.hydrate</code>的第三个回调参数，是个环状链表</li>
<li>在 ClassComponent Fiber 中，<code>updateQueue</code>存的是<code>this.setState</code>的更新队列，是个环状链表</li>
<li>在 FunctionComponent Fiber 中，<code>updateQueue</code>存的是<code>useEffect</code>、<code>useLayoutEffect</code>以及<code>useImperativeHandle</code>的监听函数，是个环状链表</li>
<li>在 HostComponent Fiber 中，<code>updateQueue</code>存的是在更新期间有变更的属性的键值对，是个数组
<strong>综上，updateQueue 存的是各类型 fiber 的副作用信息，在 commit 阶段会处理这些副作用信息</strong></li>
</ul>
<p>下面我会从<code>render阶段和</code>commit 阶段介绍对<code>updateQueue</code>的处理。</p>
<ul>
<li>render 阶段主要是为 updateQueue 赋值，并计算 updateQueue。</li>
<li>commit 阶段遍历 updateQueue 执行相应的操作</li>
</ul>
<h2>HostRootFiber 容器节点</h2>
<p><code>HostRootFiber</code>就是<code>root</code>容器对应的 fiber 节点。</p>
<p>对于<code>HostRootFiber</code>，<code>updateQueue</code>用于存储<code>ReactDOM.render</code>或者<code>ReactDOM.hydrate</code>的第三个参数(回调函数)。</p>
<pre><code class="language-js">ReactDOM.render(&lt;Home /&gt;, document.getElementById(&quot;root&quot;), () =&gt; {
  console.log(&quot;render 回调....&quot;);
});
// 或者
ReactDOM.hydrate(&lt;Home /&gt;, document.getElementById(&quot;root&quot;), () =&gt; {
  console.log(&quot;hydrate 回调....&quot;);
});
</code></pre>
<p><code>HostRootFiber</code>的<code>updateQueue</code>是一个环状链表。</p>
<h3>HostRootFiberc初次渲染</h3>
<p>初次渲染时，<code>updateContainer</code>方法会为<code>HostRootFiber</code>添加一个<code>update</code>对象，如下：</p>
<pre><code class="language-js">var update = {
  eventTime: eventTime,
  lane: lane,
  tag: UpdateState,
  payload: null,
  callback: null, // ReactDOM.render或者ReactDOM.hydrate方法的第三个参数
  next: null,
};
update.next = update; // 环状链表 shared.pending指向最后一个更新的对象
HostRootFiber.updateQueue = {
  baseState: null,
  effects: null,
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: {
    pending: update,
  },
};
</code></pre>
<h3>HostRootFiber render 阶段</h3>
<p>beginWork 阶段调用<code>processUpdateQueue</code>方法遍历<code>updateQueue.shared.pending</code>中的更新队列，计算 state。如果更新的对象<code>update</code>的<code>callback</code>有值，则将<code>update</code>存入<code>updateQueue.effects</code>数组中。同时将当前 fiber 标记为具有<code>Callback</code>的副作用</p>
<pre><code class="language-js">HostRootFiber.updateQueue = {
  baseState: { element },
  effects: [
    {
      callback: ƒ(),
      payload: { element },
      next: null,
    },
  ],
  shared: {
    pending: null,
  },
};
</code></pre>
<h3>HostRootFiber commit 阶段</h3>
<p>在<code>commitLayoutEffects</code>阶段调用<code>commitLifeCycles</code>方法，<code>commitLifeCycles</code>方法调用<code>commitUpdateQueue</code>执行回调方法。</p>
<pre><code class="language-js">function commitUpdateQueue(finishedWork, finishedQueue, instance) {
  // 遍历effects，执行callback回调
  var effects = finishedQueue.effects;
  finishedQueue.effects = null; // effects重置为null

  if (effects !== null) {
    for (var i = 0; i &lt; effects.length; i++) {
      var effect = effects[i];
      var callback = effect.callback;

      if (callback !== null) {
        effect.callback = null;
        callback(instance);
      }
    }
  }
}
</code></pre>
<h2>类组件</h2>
<p>对于类组件，updateQueue 存的是更新队列，即 this.setState 的更新对象链表，是一个环状链表。</p>
<p><code>this.setState</code>实际上会调用<code>this.enqueueSetState</code>方法构造一个更新对象，并添加到队列中。<code>shared.pending</code>指向最后一个更新。</p>
<pre><code class="language-js">// 更新对象
var update = {
  callback: null, // this.setState的第二个参数，即回调函数
  eventTime,
  lane: 1,
  next: null,
  payload: { count: 4 }, // this.setState的第一个参数
  tag: 0,
};
update.next = update; // 环状链表
fiber.updateQueue = {
  baseState: { count: 1 },
  effects: null,
  shared: {
    pending: update,
  },
};
</code></pre>
<h3>类组件 render 阶段</h3>
<p>beginWork 阶段，<code>updateClassInstance</code>调用<code>processUpdateQueue</code>遍历更新的队列，计算 state，最终处理后的<code>updateQueue</code>如下：</p>
<pre><code class="language-js">fiber.updateQueue = {
  baseState: { count: 2 },
  effects: [
    {
      callback, // callback存的是this.setState的第二个参数，即回调函数
      next: null,
      payload: { count: 2 },
      tag: 0,
    },
  ],
  firstBaseUpdate: null,
  lastBaseUpdate: null,
  shared: { pending: null },
};
</code></pre>
<h3>类组件 commit 阶段</h3>
<p><code>commitLayoutEffects</code>阶段调用<code>commitUpdateQueue</code>判断如果<code>updateQueue</code>不为 null，则调用<code>commitUpdateQueue</code>遍历<code>updateQueue.effects</code>，执行<code>setState</code>的回调</p>
<h2>HostComponent</h2>
<p><code>HostComponent</code> fiber，就是原生的 div、span 等 HTML 标签
<code>HostComponent</code> fiber 的<code>updateQueue</code>在初次渲染时为 null。只有在更新阶段，dom 的属性发生了变更，才不为 null。
<code>HostComponent</code> 的 updateQueue 存的是需要更新的属性键值对，此时 updateQueue 就是一个数组。
如果 dom 上的属性没有发生变化，但是事件监听函数引用发生了变化，则 updateQueue 为空数组</p>
<h3>HostComponent beginWork</h3>
<p><code>completeUnitOfWork</code>阶段调用 <code>updateHostComponent</code>对比新旧 props 的变化。</p>
<pre><code class="language-js">function updateHostComponent() {
  var updatePayload = prepareUpdate(instance, type, oldProps, newProps);

  workInProgress.updateQueue = updatePayload;

  if (updatePayload) {
    markUpdate(workInProgress);
  }
}
function prepareUpdate() {
  return diffProperties(domElement, type, oldProps, newProps);
}
</code></pre>
<p><code>updateHostComponent</code>主要逻辑如下：</p>
<ul>
<li>调用<code>prepareUpdate</code>比较属性，找出有差异的属性键值对存储在 <code>updatePayload</code>中</li>
<li>如果 <code>updatePayload</code> 不为 null，则将当前 fiber 标记为具有更新的副作用
<code>diffProperties</code>会比较 <code>oldProps</code> 和 <code>newProps</code>，找出有差异的属性，比如：</li>
</ul>
<pre><code class="language-js">// 更新前
&lt;div id=&quot;1&quot; test1=&quot;2&quot;&gt;1&lt;/div&gt;
// 更新后
&lt;div id=&quot;2&quot; test1=&quot;3&quot; test2=&quot;4&quot;&gt;2&lt;/div&gt;
</code></pre>
<p>旧的 <code>id = 1</code>，而新的<code>id = 2</code>，则<code>id</code>发生了变更，因此需要添加到<code>updatePayload</code>中，此时<code>updatePayload = ['id', 2]</code>。</p>
<p>这里需要注意，如果我们的属性没有变更，但是 onClick 等监听函数的引用发生了变更，则<code>diffProperties</code>会返回一个空数组以标记该节点需要更新</p>
<pre><code class="language-js">// 更新前
&lt;div onClick={() =&gt; { console.log('onclick')}}&gt;1&lt;/div&gt;
// 更新后
&lt;div onClick={() =&gt; { console.log('onclick')}}&gt;1&lt;/div&gt;
</code></pre>
<p>虽然 <code>div</code> 节点更新前后属性没有发生变化，但是 <code>onClick</code> 的引用发生了变化，则 <code>updatePayload = []</code></p>
<h3>HostComponent commit 阶段</h3>
<p>commitMutationEffects 阶段，如果<code>updateQueue</code>不为 null，则调用<code>commitUpdate</code>更新 dom 属性</p>
<h2>FunctionComponent 函数组件</h2>
<p>函数组件的<code>updateQueue</code> 存的是 <code>useEffect</code> 以及 <code>useLayoutEffect</code> 的监听函数，并且是一个环状链表。<code>lastEffect</code>指向最后一个<code>effect</code>。函数组件每次执行时，都会重新初始化 <code>updateQueue</code></p>
<ul>
<li>tag = 3。对应的是 useLayoutEffect</li>
<li>tag = 5。对应的是 useEffect</li>
</ul>
<h3>FunctionComponent beginWork 阶段</h3>
<p><code>renderWithHooks</code>函数在执行函数组件时，构造 effect 对象，并添加到<code>updateQueue</code>队列中</p>
<pre><code class="language-js">// effect对象
var effect = {
  tag: tag, // useLayoutEffect的tag等于3。useEffect的tag等于5
  create: create, // useEffect或者useLayoutEffect的第一个参数，即监听函数，
  destroy: destroy, // useEffect或者useLayoutEffect的清除函数
  deps: deps, // 依赖。即useEffect或者useLayoutEffect的第二个参数，即依赖
  // Circular
  next: null,
};
effect.next = effect;
fiber.updateQueue = {
  lastEffect: effect,
};
</code></pre>
<h3>FunctionComponent commit 阶段</h3>
<ul>
<li><code>commitMutationEffects</code>阶段调用<code>commitHookEffectListUnmount</code> 执行 <code>useLayoutEffect</code>的清除函数</li>
<li><code>commitLayoutEffects</code> 阶段调用 <code>commitHookEffectListMount</code> 执行 <code>useLayoutEffect</code>的监听函数。然后调用<code>schedulePassiveEffects</code>将<code>useEffect</code>的监听函数和清除函数放入微任务队列执行，<code>useEffect</code>是异步执行的</li>
</ul>
<pre><code class="language-js">// 执行useLayoutEffect的清除函数
function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      // useLayoutEffect
      if ((effect.tag &amp; 3) === 3) {
        var destroy = effect.destroy; // 清除函数
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
// 执行useLayoutEffect的监听函数
function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag &amp; 3) === 3) {
        // useLayoutEffect的监听函数
        var create = effect.create;
        effect.destroy = create();
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
// 调度useEffect。将useEffect的监听函数以及清除函数放入微任务队列等待异步执行
function schedulePassiveEffects(finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      const { next, tag } = effect;
      if ((tag &amp; 5) === 5) {
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect); // 将useEffect的清除函数放入微任务队列
        enqueuePendingPassiveHookEffectMount(finishedWork, effect); // 将useEffect的监听函数放入微任务队列
      }

      effect = next;
    } while (effect !== firstEffect);
  }
}
</code></pre>
<h1> </h1>
<h1>fiber双缓冲树</h1><h3>大纲</h3>
<ul>
<li>双缓冲树机制</li>
<li>删除节点时如何释放内存，即如何删除旧的 fiber 节点</li>
<li>为什么需要重用 alternate 节点，重新创建不行吗？</li>
</ul>
<h3>背景</h3>
<p>在<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/render/%E6%B7%B1%E5%85%A5%E6%A6%82%E8%BF%B0%20React%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E4%B8%BB%E6%B5%81%E7%A8%8B.md">React 初次渲染及更新流程</a>一文介绍过 React 渲染更新主要分为两个阶段：
render 阶段和 commit 阶段。</p>
<h2>render 阶段任务</h2>
<p>render 阶段主要是将新的 element tree 和 当前页面对应的 fiber 树(即 curent tree)比较，并构建一棵 workInProgress 树以及收集有副作用的 fiber 节点。
render 阶段完成后，我们将得到一棵 finishedWork 树以及一个副作用链表。render 阶段是异步可以中断的</p>
<h2>commit 阶段任务</h2>
<p>在 commit 阶段主要就是遍历副作用链表，并执行相应的 dom 操作等。
commit 阶段是同步且不可中断的</p>
<h3>why 双缓冲树</h3>
<p>由于 render 阶段构建 workInProgress 树的过程是可以中断的，同时，workInProgress 树最终又会在 commit 阶段渲染到浏览器页面上，</p>
<ul>
<li>这就决定了在 render 阶段，必须要保持浏览器页面不变直到 render 阶段完成。</li>
<li>也就是说我们在 render 阶段需要保持 current tree 不变，然后用另一棵树来承载 workInProgress 树。
为了实现这个目标，React 借鉴了<a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BC%93%E5%86%B2/10953356?fr=aladdin">双缓冲</a>技术。</li>
</ul>
<h3>双缓冲树</h3>
<p>Fiber 双缓冲树包括一棵 current tree 和一棵 workInProgress tree(render 阶段完成后的 workInProgress 树也叫 finishedWork 树)。
current tree 保存的是当前浏览器页面对应的 fiber 节点。
workInProgress tree 是在 render 阶段，react 基于 current tree 和新的 element tree 进行比较而构建的一棵树，这棵树是在内存中构建，在 commit 阶段将被绘制到浏览器页面上。</p>
<p>current 树保存在容器节点的 <code>root._reactRootContainer._internalRoot.current</code> 属性上。
在 render 阶段构建 workInProgress 树的过程中，我们可以通过<code>root._reactRootContainer._internalRoot.current.alternate</code> 访问到 workInProgress 树。</p>
<h2>各个阶段的 current tree 和 workInProgress tree 的状态</h2>
<p>render 阶段完成，commit 阶段开始前，我们会得到一棵 finishedWork 树，</p>
<ul>
<li>实际上这就是 render 过程结束后得到的 workInProgress 树，</li>
<li>finishedWork 树可以通过<code>root._reactRootContainer._internalRoot.finishedWork</code>属性获取。</li>
</ul>
<h4>render 阶段的两棵树</h4>
<p>在这个阶段，浏览器页面对应的 fiber 树仍然是 current 树，workInProgress 树正在构建
在 render 阶段构建 workInProgress 树的过程主要逻辑在 <code>performUnitOfWork</code>，因此我们可以在这个函数处打个断点查看 render 阶段的 workInProgress 树。</p>
<p>workInProgress 表示当前正在工作的 fiber 节点，这些 workInProgress 节点构成了一棵 workInProgress 树。我们可以通过<code>root._reactRootContainer._internalRoot.current.alternate</code>属性访问当前工作中的 workInProgress 树</p>
<pre><code class="language-js">function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-01.jpg" alt="image"></p>
<h4>render 阶段完成，commit 阶段开始前</h4>
<p>在这个阶段，浏览器页面对应的 fiber 树仍然是 current 树，workInProgress 树已经构建完毕，得到 finishedWork 树</p>
<p>render 阶段完成，commit 阶段开始前，workInProgress 树构建完成，我们得到一棵 finishedWork 树，此时将 workInProgress 树复制给容器的 finishedWork 属性，这段逻辑在 <code>performSyncWorkOnRoot</code> 函数中</p>
<pre><code class="language-js">function performSyncWorkOnRoot(root) {
  //...
  renderRootSync(root, lanes); // render阶段，构建workInProgress树
  // ...render阶段结束
  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork; // 将workInProgress树赋值给finishedWork属性
  commitRoot(root); // commit阶段，将finishedWork树更新到浏览器页面
  // ...
}
</code></pre>
<p>可以在 <code>performSyncWorkOnRoot</code> 处打断点查看这个过程
<img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-02.jpg" alt="image"></p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-03.jpg" alt="image"></p>
<h4>commit 阶段</h4>
<p>这个阶段完成后，finishedWork 树就变成了 current 树</p>
<p>可以看出<code>commitRoot</code>函数调用的是<code>commitRootImpl</code>函数，在 <code>commitRootImpl</code> 函数执行的一开始，<code>root.finishedWork</code>就已经被置空，所以<code>finishedWork</code>属性存在的时间是非常短的。</p>
<ul>
<li>commitBeforeMutationEffects。DOM 变更前，主要是调用类组件的<code>getSnapshotBeforeUpdate</code>、函数组件的<code>useEffect</code>的清除函数等</li>
<li>commitMutationEffects。DOM 变更，<strong>这个函数主要是将 finishedWork 树绘制到浏览器页面!!!</strong></li>
<li>commitLayoutEffects。DOM 变更后。</li>
</ul>
<p>关于 <code>commitBeforeMutationEffects</code>、<code>commitMutationEffects</code>以及<code>commitLayoutEffects</code>这三个函数的主要作用，在<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/render/%E6%B7%B1%E5%85%A5%E6%A6%82%E8%BF%B0%20React%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E4%B8%BB%E6%B5%81%E7%A8%8B.md">深入概述 React 初次渲染以及 setState 状态更新主流程</a>一文中已经有详细介绍，有兴趣的可以看看。</p>
<h3>finishedWork 树就变成current 树</h3>
<p>从下面的函数执行可以看出，在<code>commitMutationEffects</code>函数执行之前，浏览器页面对应的依旧是 current 树，在<code>commitMutationEffects</code>执行完成后，React 已经将 finishedWork 树渲染到浏览器页面上，此时 finishedWork 树就变成了 current 树！！</p>
<pre><code class="language-js">function commitRoot(root) {
  var renderPriorityLevel = getCurrentPriorityLevel();
  runWithPriority$1(
    ImmediatePriority$1,
    commitRootImpl.bind(null, root, renderPriorityLevel)
  );
  return null;
}
function commitRootImpl(root, renderPriorityLevel) {
  // 暂存finishedWork树
  var finishedWork = root.finishedWork;
  // 注意，在commitRootImpl函数执行的开始，finishedWork属性已经被置空
  root.finishedWork = null;

  root.callbackNode = null;

  if (firstEffect !== null) {
    nextEffect = firstEffect;

    commitBeforeMutationEffects();

    nextEffect = firstEffect;
    commitMutationEffects(root, renderPriorityLevel);
    // commitMutationEffects执行完成后，将finishedWork树赋值给current tree。
    root.current = finishedWork;
    commitLayoutEffects(root, lanes);
  }

  return null;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-04.jpg" alt="image"></p>
<p><strong>如果你看完上面介绍的几个阶段中 Fiber 双缓冲树的状态，还是很蒙的话，那一定是我写的太烂了。下面我会用几个 demo 详细介绍双缓冲树的创建过程。在此之前，你只需要记住 render 阶段和 commit 阶段双缓冲树的状态就行了</strong></p>
<h2>构建 workInProgress 树主要的源码</h2>
<p>本节介绍 render 阶段构建 workInProgress 树的主要源码，在阅读本文时，可以在下面介绍的各个函数入口处打断点调试。</p>
<h2>render 阶段主要涉及的入口函数</h2>
<pre><code class="language-js">// render阶段
var __DEBUG_RENDER_COUNT__ = 0;
//这个变量在 `createWorkInProgress` 使用，方便区分当前的 fiber 以及 workInProgress
function renderRootSync(root, lanes) {
  __DEBUG_RENDER_COUNT__++;
  prepareFreshStack(root, lanes);
  workLoopSync();
  return workInProgressRootExitStatus;
}

</code></pre>
<h2>render阶段中的beginWork</h2>
<pre><code class="language-js">function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  var current = unitOfWork.alternate;
  next = beginWork$1(current, unitOfWork, subtreeRenderLanes);
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
  if (current === null) {
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren
    );
  }
}
</code></pre>
<h2>beginWork</h2>
<p><code>beginWork</code>主要是负责处理各类型 fiber 节点，并调用 <code>reconcileChildren</code> 协调子元素。
在 <code>reconcileChildren</code>的过程中，调用 <code>useFiber</code>复用旧的节点或者</p>
<p><code>createFiberFromElement</code> 创建新的节点。
fiber 根节点，即 rootFiber 的创建或者复用在<code>prepareFreshStack</code>函数中完成。</p>
<pre><code class="language-js">function useFiber(fiber, pendingProps) {
  // We currently set sibling to null and index to 0 here because it is easy
  // to forget to do before returning it. E.g. for the single child case.
  var clone = createWorkInProgress(fiber, pendingProps);
  clone.index = 0;
  clone.sibling = null;
  return clone;
}
</code></pre>
<h2>createWorkInProgress</h2>
<p>useFiber中用了createWorkInProgress来复用节点
他使用 current 的属性覆盖旧的属性。</p>
<ul>
<li>注意在创建新的 fiber 节点时，<code>alternate</code>相互指向。</li>
</ul>
<pre><code class="language-js">// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    );
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;
  }
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.AAA__DEBUG_RENDER_COUNT__ = __DEBUG_RENDER_COUNT__;
  return workInProgress;
}
</code></pre>
<pre><code class="language-js">workInProgress.alternate = current;
current.alternate = workInProgress;
</code></pre>
<h3>第一次渲染</h3>
<p>下面的 Demo 用来演示在 render 阶段如何基于当前的 current 树创建新的 fiber 节点或者复用旧的 fiber 节点，从而构建一棵 workInProgress 树。</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

class Home extends React.Component {
  constructor(props) {
    super(props);
    this.state = { step: 0 };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({
      step: this.state.step + 1,
    });
  }
  render() {
    const { step } = this.state;
    return step &lt; 3 ? (
      &lt;div id={step} onClick={this.handleClick}&gt;
        {step}
      &lt;/div&gt;
    ) : (
      &lt;p id={step} onClick={this.handleClick}&gt;
        {step}
      &lt;/p&gt;
    );
  }
}

ReactDOM.render(&lt;Home /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h4>创建 Fiber 树的容器以及 HostRootFiber</h4>
<p>第一次渲染时，current 树为空，React 需要构造一棵全新的树。</p>
<ul>
<li>React 在第一次渲染时，首先给 root 容器创建一个<code>FiberRootNode</code>节点，该节点用于承载<code>current</code>树以及<code>finishedWork</code>树，是整个 fiber 树的容器。</li>
<li>同时为 root 节点创建<code>HostRootFiber</code>，这也是整个 fiber 树的根节点</li>
</ul>
<pre><code class="language-js">function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) {
  var root = new FiberRootNode(containerInfo, tag, hydrate);
  // stateNode is any.
  var uninitializedFiber = createHostRootFiber(tag);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  initializeUpdateQueue(uninitializedFiber);
  return root;
}
</code></pre>
<p><code>createFiberRoot</code>执行完成，此时 fiber 树的容器已经创建完毕。
进入 <code>renderRootSync</code> 函数，render 阶段开始。</p>
<h4>prepareFreshStack：为 HostRootFiber 创建对应的 workInProgress 节点</h4>
<p>在 <code>renderRootSync</code> 中， <code>prepareFreshStack</code>函数调用<code>createWorkInProgress(root.current, null)</code> 开始为 HostRootFiber(即容器 root 的 fiber 节点)创建对应的 workInProgress fiber。
由于此时的 HostRootFiber 还没有备用节点，即 <code>root.current.alternate</code> 为空，因此<code>createWorkInProgress</code>会新建一个 fiber 节点，并互相关联 <code>alternate</code> 属性
接下来进入 <code>workLoopSync</code> render 工作循环。</p>
<pre><code class="language-js">function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
</code></pre>
<h4>performUnitOfWork(HostRootFiber)：为 Home 节点创建 workInProgress 节点</h4>
<p>第一个开始工作的 workInProgress 节点就是新创建的 HostRootFiber 节点。<code>performUnitOfWork</code> 为 HostRootFiber 节点协调子元素。
在本例中，HostRootFiber 的子元素就是<code>Home</code>类对应的元素。
第一次渲染时，Home 没有备用的 fiber 节点，因此需要调用 <code>createFiberFromElement</code> 为 Home 创建全新的 fiber 节点</p>
<h4>performUnitOfWork(HomeFiber)：为 div 节点创建对应的 workInProgress 节点</h4>
<p>HostRootFiber 的<code>performUnitOfWork</code>执行完成，开始为<code>Home</code>执行<code>performUnitOfWork</code>，<code>Home</code>开始工作。调用 <code>new Home()</code> 初始化类组件，并挂载到 <code>Home fiber</code> 的<code>stateNode</code>属性上。同时为 Home 协调子元素，在本例中，Home 的子元素是 div，为 div 创建 fiber 节点
<img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-09.jpg" alt="image"></p>
<p>由于 div 没有子节点，因此在为 div 调用<code>performUnitOfWork</code>开始工作时，没有子元素协调，至此，workInProgress 树的构建完毕，render 阶段结束</p>
<h4>render 阶段结束，commit 阶段开始前</h4>
<p>render 阶段结束，workInProgress 树构建完成，此时我们得到一棵 finishedWork 树，将其保存到容器中</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-10.jpg" alt="image"></p>
<p>主要逻辑在这里：</p>
<pre><code class="language-js">function performSyncWorkOnRoot(root) {
  //...
  renderRootSync(root, lanes); // render阶段，构建workInProgress树
  // ...render阶段结束
  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork; // 将workInProgress树赋值给finishedWork属性
  commitRoot(root); // commit阶段，将finishedWork树更新到浏览器页面
  // ...
}
</code></pre>
<h4>commit 阶段结束</h4>
<p><code>commitMutationEffects</code>函数执行完成后，finisheWork 树已经更新到浏览器屏幕上，finishedWork 树就变成了 current 树，因此将 finishedWork 树赋值给 root.current，同时重置 root.finishedWork 为 null</p>
<pre><code class="language-js">function commitRootImpl(root, renderPriorityLevel) {
  // 暂存finishedWork树
  var finishedWork = root.finishedWork;
  // 注意，在commitRootImpl函数执行的开始，finishedWork属性已经被置空
  root.finishedWork = null;

  root.callbackNode = null;

  if (firstEffect !== null) {
    nextEffect = firstEffect;

    commitBeforeMutationEffects();

    nextEffect = firstEffect;
    commitMutationEffects(root, renderPriorityLevel);
    // commitMutationEffects执行完成后，将finishedWork树赋值给current tree。
    root.current = finishedWork;
    commitLayoutEffects(root, lanes);
  }

  return null;
}
</code></pre>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-11.jpg" alt="image"></p>
<h3>第二次渲染</h3>
<p>在第一次渲染完成后，我们已经有一棵 current 树。现在让我们点击按钮，触发页面更新。由于是第二次渲染，不需要在创建 Fiber 树的容器。render 阶段直接从 <code>renderRootSync</code>函数开始</p>
<h4>prepareFreshStack：为 current HostRootFiber 创建对应的 workInProgress 节点</h4>
<p><code>prepareFreshStack</code> 调用 <code>createWorkInProgress</code> 为 <code>HostRootFiber</code> 创建 workInProgress 节点。<code>createWorkInProgress</code>中发现当前的 HostRootFiber 存在备用的节点，即<code>current.alternate</code>存在，则直接复用备用节点</p>
<pre><code class="language-js">var workInProgress = current.alternate;
</code></pre>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-12.jpg" alt="image"></p>
<h4>performUnitOfWork(New HostRootFiber)：为 current Home 节点创建 workInProgress 节点</h4>
<p>首先进入工作循环的是新创建的 workInProgress HostRootFiber。在 performUnitOfWork 执行期间，React 为 HostRootFiber 的子元素 Home 创建对应的 workInProgress 节点，这一步工作在 <code>bailoutOnAlreadyFinishedWork</code> 函数中的 <code>cloneChildFibers</code> 完成。<code>cloneChildFibers</code> 调用 <code>createWorkInProgress</code>
方法为 Home 创建对应的 workInProgress 节点。由于 current Home fiber 没有备用节点，即 current home fiber 的 alternate 不存在，因此 <code>createWorkInProgress</code>为 Home 创建全新的 workInProgress 节点。创建完成后，HostRootFiber 的 child 指针指向新的 Home fiber。</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-13.jpg" alt="image"></p>
<h4>performUnitOfWork(New HomeFiber)：为 current div 节点创建对应的 workInProgress 节点</h4>
<p>下一步就是为新创建的 HomeFiber 执行工作。在为 HomeFiber 协调子元素的过程中，发现 新的 element(即 div)的 tag 及 type 和 current div 节点的相同，因此可以调用<code>useFiber</code>复用当前的 fiber 节点</p>
<pre><code class="language-js">function useFiber(fiber, pendingProps) {
  // We currently set sibling to null and index to 0 here because it is easy
  // to forget to do before returning it. E.g. for the single child case.
  var clone = createWorkInProgress(fiber, pendingProps);
  clone.index = 0;
  clone.sibling = null;
  return clone;
}
</code></pre>
<p>调用 <code>createWorkInProgress</code> 为新的子元素 div 创建新的 workInProgress 节点。由于 current div fiber 的 alternate 属性为 null，没有备用的节点，因此创建一个全新的 fiber 节点，并互相关联 <code>alternate</code></p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-14.jpg" alt="image"></p>
<p>由于新的 div 没有子节点，因此 render 阶段结束</p>
<h4>render 阶段结束，commit 阶段开始前</h4>
<p>render 阶段结束，workInProgress 树构建完成，此时我们得到一棵 finishedWork 树。在 <code>performSyncWorkOnRoot</code> 函数中，我们将 finishedWork 树保存到容器的 finishedWork 属性上。</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-15.jpg" alt="image"></p>
<h4>commit 阶段结束</h4>
<p><code>commitMutationEffects</code>函数执行完成后，finisheWork 树已经更新到浏览器屏幕上，finishedWork 树就变成了 current 树，因此将 finishedWork 树赋值给 root.current，同时重置 root.finishedWork 为 null</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-16.jpg" alt="image"></p>
<p><strong>第二次渲染完成后，第二次渲染 render 阶段构建的 finishedWork 树就变成了 current 树，第一次渲染的树就变成了备用树，因此上图我将第一次渲染的树全部用虚线表示。此时内存中同时存在两棵树，一棵 current 树，一棵旧的备用树</strong></p>
<h3>第三次渲染</h3>
<p>在第二次渲染完成后，内存中同时存在一棵 current 树和一棵旧的 alternate 备用树。现在让我们点击按钮，触发页面更新，看看第三次渲染，React 是如何复用旧的 alternate 备用树上的节点。同样的，由于是第三次渲染，不需要在创建 Fiber 树的容器。render 阶段直接从 <code>renderRootSync</code>函数开始</p>
<p><strong>注意，右图中，虚线表示还没复用的旧的 fiber 节点。实现表示当前复用的节点</strong></p>
<h4>prepareFreshStack：为 current HostRootFiber 创建对应的 workInProgress 节点</h4>
<p><code>prepareFreshStack</code> 调用 <code>createWorkInProgress</code> 为 <code>HostRootFiber</code> 创建 workInProgress 节点。<code>createWorkInProgress</code>中发现当前的 HostRootFiber 存在备用的节点，即<code>current.alternate</code>存在，则直接复用备用节点</p>
<pre><code class="language-js">var workInProgress = current.alternate;
</code></pre>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-17.jpg" alt="image"></p>
<h4>performUnitOfWork(New HostRootFiber)：为 current Home 节点创建 workInProgress 节点</h4>
<p>和第二次渲染一样，React 也是在 <code>cloneChildFibers</code> 中调用 <code>createWorkInProgress</code> 为当前的 Home fiber 创建新的 workInProgress 节点。
由于 current Home fiber 的 alternate 属性不为空，存在旧的备用节点，因此 <code>createWorkInProgress</code> 直接复用旧的备用节点，并将当前 current home fiber 的属性全部复制到旧的备用节点。</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-18.jpg" alt="image"></p>
<h4>performUnitOfWork(New HomeFiber)：为 current div 节点创建对应的 workInProgress 节点</h4>
<p>和第二次渲染一样，在协调 Home Fiber 子元素时，React 发现可以复用 current div 节点，因此调用 <code>useFiber</code> 复用 current div 节点。
<img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-19.jpg" alt="image"></p>
<h4>render 阶段结束，commit 阶段开始前</h4>
<p>render 阶段结束，workInProgress 树构建完成，此时我们得到一棵 finishedWork 树。在 <code>performSyncWorkOnRoot</code> 函数中，我们将 finishedWork 树保存到容器的 finishedWork 属性上。</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-20.jpg" alt="image"></p>
<h4>commit 阶段结束</h4>
<p><code>commitMutationEffects</code>函数执行完成后，finisheWork 树已经更新到浏览器屏幕上，finishedWork 树就变成了 current 树，因此将 finishedWork 树赋值给 root.current，同时重置 root.finishedWork 为 null</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-21.jpg" alt="image"></p>
<h3>小结</h3>
<p>从前面三次渲染更新过程可以看出，内存中最多存在两棵树，一棵 current 树，一棵备用的 alternate 树，备用的树在 render 阶段用于构造 workInProgress 树。一个元素最多存在两个版本的 fiber 节点，一个 current 版本，和当前浏览器页面对应，一个 alternate 版本，alternate 版本是备用节点，用于在 render 阶段复用，以构建 workInProgress 节点。</p>
<p><strong>那为什么 React 要复用备用的节点，而不是新创建一个呢？最大的原因是节省内存开销，通过复用旧的备用节点，React 不需要额外申请内存空间，在复用时可以直接将 current fiber 的属性复制到旧的备用节点</strong></p>
<p>通过上面三次渲染更新过程也可以看出，React 在渲染时，会在 current 树和 alternate 树之间交替进行，倒来倒去。比如第四次渲染时，第二次渲染完成的 alternate 树又变成了 current 树，而第三次渲染完成的树又变成了 alternate 树。</p>
<p>看完了渲染更新流程，下面我们看下删除节点的情况又是怎样的。</p>
<h3>第四次渲染：节点删除的场景</h3>
<p>继续点击按钮，触发第四次渲染。根据我们的 demo，此时 div 节点将会被删除，新的 p 节点将被插入。我们看下这个过程，React 是如何删除节点、创建新的 p 节点以及复用旧的 home 节点的。</p>
<pre><code class="language-jsx">  render() {
    const { step } = this.state;
    return step &lt; 3 ? (
      &lt;div id={step} onClick={this.handleClick}&gt;
        {step}
      &lt;/div&gt;
    ) : (
      &lt;p id={step} onClick={this.handleClick}&gt;
        {step}
      &lt;/p&gt;
    );
  }
</code></pre>
<p>同样的，由于是第四次渲染，不需要再创建 Fiber 树的容器。render 阶段直接从 <code>renderRootSync</code>函数开始</p>
<h4>prepareFreshStack：为 current HostRootFiber 创建对应的 workInProgress 节点</h4>
<p><code>prepareFreshStack</code> 调用 <code>createWorkInProgress</code> 为 <code>HostRootFiber</code> 创建 workInProgress 节点。<code>createWorkInProgress</code>中发现当前的 HostRootFiber 存在备用的节点，即<code>current.alternate</code>存在，则直接复用备用节点</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-22.jpg" alt="image"></p>
<h4>performUnitOfWork(New HostRootFiber)：为 current Home 节点创建 workInProgress 节点</h4>
<p>和第三次渲染一样，React 也是在 <code>cloneChildFibers</code> 中调用 <code>createWorkInProgress</code> 为当前的 Home fiber 创建新的 workInProgress 节点。
由于 current Home fiber 的 alternate 属性不为空，存在旧的备用节点，因此 <code>createWorkInProgress</code> 直接复用旧的备用节点，并将当前 current home fiber 的属性全部复制到旧的备用节点。</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-23.jpg" alt="image"></p>
<h4>performUnitOfWork(New HomeFiber)：删除 div 节点，新建 p 节点</h4>
<p>轮到为新的 home fiber 协调子元素。这次，我们需要删除 div fiber 节点，新建一个 p 节点</p>
<ul>
<li>调用 deleteRemainingChildren 删除当前的 div fiber 节点，将 div 添加到父节点，即 home fiber 的副作用链表中</li>
<li>调用 createFiberFromElement 为 p 元素创建对应的 fiber 节点。</li>
<li>将新的 home fiber 的 child 指针指向 p 节点。</li>
</ul>
<p>到这里，home fiber 的工作就已经完成，此时 div 处于被即将被删除的状态，这里使用虚线表示
<img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-24.jpg" alt="image"></p>
<h4>render 阶段结束，commit 阶段开始前</h4>
<p>render 阶段结束，workInProgress 树构建完成，此时我们得到一棵 finishedWork 树，以及一个副作用链表。在 <code>performSyncWorkOnRoot</code> 函数中，我们将 finishedWork 树保存到容器的 finishedWork 属性上。</p>
<p>实际上，React 在每次 render 阶段都会收集副作用节点，并构建副作用链表，我在前三次渲染中省略了这个步骤。第四次渲染介绍一下副作用链表的构建，因为这涉及到后面 commit 阶段遍历副作用链表，删除节点，插入节点的情况，可以查看<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/reconciler/%E6%9E%84%E5%BB%BA%E5%89%AF%E4%BD%9C%E7%94%A8%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95.md">React 构建副作用链表算法</a>了解 React 如何构建副作用链表</p>
<p>render 阶段结束后，我们最终得到的 finishedWork 树和辅作用链表(图中红线所示)如下图：</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-25.jpg" alt="image"></p>
<h4>commit 阶段</h4>
<p>commit 阶段遍历副作用节点，根据对应的副作用标志<code>fiber.flags</code>执行对应的操作。在我们的案例中，相应的副作用就是删除 div 节点，插入 p 节点。这两个过程都发生在<code>commitMutationEffects</code>阶段，这个阶段操作真实的 dom 节点，并释放掉 fiber 的内存。</p>
<p><code>commitMutationEffects</code>遍历副作用链表，第一个节点是 div 节点，这个节点需要删除，调用 <code>commitDeletion</code> 删除节点</p>
<p><code>commitDeletion</code>主要工作如下：</p>
<ul>
<li>调用 <code>unmountHostComponents</code> 删除真实的 dom 节点</li>
<li>其次调用<code>detachFiberMutation</code>重置 div 节点(AAA_DEBUG_RENDER_COUNT 属性为 3)的各种属性，以释放内存。重点关注 div fiber 的 return、child、alternate 指针的重置，同时需要注意，sibling 属性和 stateNode 属性不是在这个时候释放掉的。</li>
<li>然后调用 <code>detachFiberMutation</code>重置 div 节点(AAA_DEBUG_RENDER_COUNT 属性为 3)的备用节点，即 AAA_DEBUG_RENDER_COUNT 属性为 2 的 div 节点的属性，以释放内存。此时内存中已经没有节点引用这个备用节点，但是这个备用节点还是会引用 stateNode，</li>
</ul>
<p><code>detachFiberMutation</code> 函数如下：</p>
<pre><code class="language-js">function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;
}
</code></pre>
<p>至此，对于 div 节点的删除工作已经完成，下一个需要执行的副作用节点是 p 节点，调用<code>commitPlacement</code>插入真实的 p dom 节点。</p>
<p><code>commitMutationEffects</code> 函数执行完成后，此时的双缓冲树如下：</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-26.jpg" alt="image"></p>
<p><code>commitMutationEffects</code> 函数执行完成，finishedWork 树已经变成了 current 树</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-27.jpg" alt="image"></p>
<h3>commitRootImpl</h3>
<p><code>commitLayoutEffects</code> 执行完成后，此时副作用链表已经没有用处，需要释放掉副作用链表的内存，这段逻辑在 <code>commitRootImpl</code> 函数中</p>
<pre><code class="language-js">function commitRootImpl(root, renderPriorityLevel) {
  var finishedWork = root.finishedWork;
  root.finishedWork = null;
  //....
  commitBeforeMutationEffects();
  //....
  commitMutationEffects(root, renderPriorityLevel);
  //....
  commitLayoutEffects(root, lanes);
  //....
  // We are done with the effect chain at this point so let's clear the
  // nextEffect pointers to assist with GC. If we have passive effects, we'll
  // clear this in flushPassiveEffects.
  nextEffect = firstEffect;
  while (nextEffect !== null) {
    var nextNextEffect = nextEffect.nextEffect;
    nextEffect.nextEffect = null;
    if (nextEffect.flags &amp; Deletion) {
      detachFiberAfterEffects(nextEffect);
    }
    nextEffect = nextNextEffect;
  }
  //...
}
function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}
</code></pre>
<ul>
<li>首先重置副作用节点的 nextEffect 为 null</li>
<li>其次判断如果节点是被删除的，则调用 detachFiberAfterEffects 函数重置 sibling 和 stateNode 为 null</li>
</ul>
<h2>commit 阶段结束</h2>
<p>整个 commit 阶段已经结束，此时内存中的双缓冲树状态如下：</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-28.jpg" alt="image"></p>
<p><strong>根据图中可以看出，左边的 div fiber 节点(AAA_DEBUG_RENDER_COUNT 属性为 2)已经没有任何节点引用它了，可以被 GC 回收内存。
但是我们看右边的 div fiber 节点(AAA_DEBUG_RENDER_COUNT 属性为 3)的节点还有 child 以及 firstEffect 指针引用着，因此这个节点不会在本次 GC 期间被回收，而是等下一次渲染更新完成后才会被 GC 回收</strong></p>
<h3>子树删除的场景</h3>
<p>这次我们使用下面的 demo，看看删除子树的时候，React 是怎么释放内存的</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;

class Home extends React.Component {
  constructor(props) {
    super(props);
    this.state = { step: 0 };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({
      step: this.state.step + 1,
    });
  }
  render() {
    const { step } = this.state;
    return step &lt; 3 ? (
      &lt;div id={step} onClick={this.handleClick}&gt;
        &lt;div id=&quot;test&quot;&gt;{step}&lt;/div&gt;
      &lt;/div&gt;
    ) : (
      &lt;p id={step} onClick={this.handleClick}&gt;
        {step}
      &lt;/p&gt;
    );
  }
}

ReactDOM.render(&lt;Home /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<p>这里我们直接从第四次点击按钮出发页面更新开始，当 render 阶段结束，commit 阶段开始前，我们将得到下面一棵 finishedWork 树以及副作用链表。这里我使用蓝色标记需要释放内存的 fiber 节点</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-29.jpg" alt="image"></p>
<p><code>commitMutationEffects</code>阶段调用 <code>commitDeletetion</code> 方法删除 div fiber 节点，并重置 div fiber 的属性为 null</p>
<h4>内存泄漏风险分析</h4>
<p>下面就是整个 commit 阶段完成后，内存中双缓冲树的状态</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/double-fiber-30.jpg" alt="image">
从图中可以看出，A，B，C，D 都是需要被删除的节点。</p>
<p>再来看 A 节点， A 节点(stateNode 属性)还引用着已经被删除的 div 真实 dom，这个 div 真实 dom 的<code>__reactFiber</code> 属性还引用着 A 节点。因此这里有一对循环引用，即</p>
<pre><code class="language-js">fiberA.stateNode = div。
div.__reactFiber = fiberA
</code></pre>
<p>先来看 B，B 节点所有的属性已经被重置为 null，但是此时还有 home 的 child 以及 firstEffect 等属性引用着 B 节点。在本次更新完成，可想而知 B 节点的内存不会被释放。等到下一次更新完成时，由于 child 及 firstEffect 不再指向 B 节点，B 节点内存得到释放</p>
<p>再来看 C 和 D，C 和 D 的 stateNode 都没有被清空，同时 div#test 这个真实的 dom 节点的<code>__reactFiber</code>属性还引用着 C，C 和 D 通过 alternate 属性相互引用，这里的引用情况如下：</p>
<pre><code class="language-js">fiberC.stateNode = div#test
fiberC.return = fiberB
div#test.__reactFiber = fiberC

fiberD.stateNode = div#test
fiberD.return = fiberA

fiberD.alternate = fiberC.alternate
</code></pre>
<p><strong>综上可以看出，如果在采用引用计数的浏览器中，由于这些节点之间存在循环引用的情况，在垃圾回收期间不会被回收，因此有内存泄漏的风险。
而在采用标记清除法的浏览器中，这些节点内存会被回收。这也是为什么在谷歌浏览器中并没有内存泄漏的风险</strong></p>
<p>第四次渲染后内存中的 FiberNode 节点
第五次渲染后内存中的 FiberNode 节点
第六次渲染后，被删除的节点的内存已经被全部回收，因此从第六次开始，FiberNode 节点的数量都保持在 6 个
综上也可以看出，被删除的节点至少要在后续两轮渲染更新完成后才能全部回收完毕**</p>
<h1> </h1>
<h1>git branch</h1><h2>git branch -f</h2>
<p><code>git branch -f</code> 命令用于强制移动或重置分支的指针位置。它通常用于以下情况：</p>
<ol>
<li>移动分支指针：可以使用 <code>git branch -f &lt;branch&gt; &lt;commit&gt;</code> 将分支 <code>&lt;branch&gt;</code> 的指针移动到指定的 <code>&lt;commit&gt;</code> 上。这对于修复错误或重新设置分支位置非常有用。</li>
<li>重置分支位置：可以使用 <code>git branch -f &lt;branch&gt; HEAD</code> 将分支 <code>&lt;branch&gt;</code> 的指针重置到当前所在的提交上。这对于撤销错误的合并或重置分支状态非常有用。</li>
</ol>
<p>需要注意的是，<code>git branch -f</code> 命令会强制移动分支指针，可能会导致丢失未提交的更改。因此，在使用该命令之前，请确保已经备份或提交了所有重要的更改。</p>
<h2>git branch -m</h2>
<p><code>git branch -m</code> 是 Git 命令的一部分，用于重命名分支。</p>
<p>具体来说，<code>git branch -m &lt;old_branch_name&gt; &lt;new_branch_name&gt;</code> 用于将旧的分支名 <code>&lt;old_branch_name&gt;</code> 改为新的分支名 <code>&lt;new_branch_name&gt;</code>。</p>
<p>例如，如果要将分支 <code>feature1</code> 改名</p>
<h2>git push -u  origin Branc1:branch2</h2>
<p>含义为将本地branch1 推送到origin 的 branch2</p>
<h2>git revert HEAD</h2>
<p>git revert HEAD的含义是撤销当前提交的更改。HEAD是指向当前分支最新提交的指针，通过执行git revert HEAD命令，可以创建一个新的提交，该提交会撤销当前分支最新的提交所做的更改。
是 HEAD 而不是 HEAD^1</p>
<h2>git cherry-pick   c1 c3</h2>
<p>跳过来c2,pick 了p1和p2</p>
<h1> </h1>
<h1>how_setstate_works</h1><h2>setState 主流程及源码</h2>
<p>本篇文章介绍以下知识点：</p>
<ul>
<li><code>setState</code> 主流程及源码</li>
<li>类组件和函数组件 <code>fiber.memoizedState</code> 的区别</li>
<li>类组件编译后也是一个函数，<code>React</code> 是如何区分函数组件和类组件的</li>
</ul>
<h3>demo</h3>
<p>准备工作</p>
<ul>
<li>在 <code>constructor</code> 中第一行添加 <code>debugger</code>，类组件 <code>Counter</code> 初始化时会调用构造函数</li>
<li>在 <code>handleClick</code> 中第一行添加 <code>debugger</code>，当我们点击按钮时，<code>setState</code> 主流程便从这里开始</li>
</ul>
<pre><code class="language-jsx">import React, { Component } from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
class Counter extends Component {
  constructor(props) {
    debugger;
    super(props);
    this.state = {
      number: 0,
    };
  }
  handleClick = (event) =&gt; {
    debugger;
    this.setState({ number: 1 });
    this.setState({ number: 2 });
  };

  render() {
    console.log(&quot;render===&quot;, this.state);
    return &lt;button onClick={this.handleClick}&gt;{this.state.number}&lt;/button&gt;;
  }
}

ReactDOM.render(&lt;Counter /&gt;, document.getElementById(&quot;root&quot;));
</code></pre>
<h3>React.Component</h3>
<p>我们知道类组件一定要继承于 <code>React.Component</code> 或者 <code>React.PureComponent</code>，这两个类位于 <code>packages/react/src/ReactBaseClasses.js</code> 文件中，
<code>React.Component</code> 做的事情很简单。下面一步一步 debug 一下</p>
<p>刷新页面，首先进入我们的构造函数断点处</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-02.jpg" alt="">注意这个函数调用栈的顺序，可以在每个函数都打一个断点，多看几次类组件初始化的过程</p>
<p>点击下一步，进入 <code>super(props)</code> 函数，实际上就是我们的 <code>React.Component</code></p>
<hr>
<p><code>React.Component</code>这里有三个需要注意的地方：</p>
<ul>
<li><code>this.updater = updater || ReactNoopUpdateQueue;</code>。当我们调用 <code>this.setState</code> 时，使用的就是 <code>this.updater.enqueueSetState</code>。这里只是简单的将 <code>this.updater</code> 初始化为空的 <code>ReactNoopUpdateQueue</code>。实际上真正的 <code>this.updater</code> 在 <code>react-dom</code> 中初始化。<code>react-dom</code>、<code>react-native</code> 等对于 <code>this.updater</code> 的实现都不尽相同。</li>
<li><code>Component.prototype.isReactComponent = {};</code> isReactComponent 用于后续在创建 <code>fiber</code> 节点时判断是不是类组件。如果函数原型存在 <code>isReactComponent</code> 则说明是类组件</li>
<li><code>Component.prototype.setState</code> 这是我们调用 <code>this.setState</code> 时的逻辑</li>
</ul>
<p><code>React.Component</code> 的简单实现如下：</p>
<pre><code class="language-js">const ReactNoopUpdateQueue = {
  isMounted: function (publicInstance) {
    return false;
  },
  enqueueForceUpdate: function (publicInstance, callback, callerName) {},
  enqueueReplaceState: function (
    publicInstance,
    completeState,
    callback,
    callerName
  ) {},
  enqueueSetState: function (
    publicInstance,
    partialState,
    callback,
    callerName
  ) {},
};
class Component {
  constructor(props, context, updater) {
    this.props = props;
    this.updater = updater || ReactNoopUpdateQueue;
    this.isReactComponent = {};
  }
  setState(partialState, callback) {
    this.updater.enqueueSetState(this, partialState);
  }
  forceUpdate(callback) {
    this.updater.enqueueForceUpdate(this, callback, &quot;forceUpdate&quot;);
  }
}
</code></pre>
<h2>实际上真正的 <code>this.updater</code> 的初始化在 <code>adoptClassInstance</code> 方法中：</h2>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-06.jpg" alt="image"></p>
<h3>类组件和函数组件的 fiber.memoizedState 的区别</h3>
<p>我们在<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/hooks/how_useReducer_work.md">React.useReducer 原理及源码主流程</a>章节中已经知道，函数组件对应的 <code>fiber.memoizedState</code> 是用来保存 <code>hook</code> 链表的。</p>
<p>在类组件中，其对应的 <code>fiber.memoizedState</code> 保存的是上一次更新的 <code>this.state</code> 的值</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-07.jpg" alt="image"></p>
<h3>类组件的更新队列</h3>
<p>在<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/hooks/how_useReducer_work.md">React.useReducer 原理及源码主流程</a>中我们知道如果多次调用 <code>setCount</code>，更新的队列会保存在 <code>hook.queue</code> 链表中</p>
<p>在类组件中，如果我们连续调用多次</p>
<pre><code class="language-js">this.setState({ number: 1 });
this.setState({ number: 2 });
this.setState({ number: 3 });
</code></pre>
<p>实际上更新队列保存在 <code>fiber.updateQueue</code>中，<code>fiber.updateQueue.shared.pending</code> 指向最后一个 <code>this.setState()</code> 生成的更新对象</p>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-08.jpg" alt="image"></p>
<p><code>fiber.updateQueue.shared</code> 和 <code>hook.queue</code> 一样也是环状链表</p>
<h3>类组件初始化流程</h3>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-09.jpg" alt="image"></p>
<h3>setState 主流程及源码</h3>
<p>调用 <code>this.setState</code> 时，实际上调用的是 <code>this.updater.enqueueSetState</code></p>
<pre><code class="language-jsx">function get(key) {
  return key._reactInternals;
}
function createUpdate(eventTime, lane) {
  var update = {
    eventTime: eventTime,
    lane: lane,
    tag: UpdateState,
    payload: null,
    callback: null,
    next: null,
  };
  return update;
}
</code></pre>
<h2>class setState enqueueUpdate构造环状列表</h2>
<pre><code class="language-js">// enqueueUpdate构造环状列表
function enqueueUpdate(fiber, update) {
  var updateQueue = fiber.updateQueue;

  if (updateQueue === null) {
    return;
  }

  var sharedQueue = updateQueue.shared;
  var pending = sharedQueue.pending;

  if (pending === null) {
    update.next = update;
  } else {
    update.next = pending.next;
    pending.next = update;
  }

  sharedQueue.pending = update;
}
function requestEventTime() {
  // 任务是有优先级的，优先级高的会打断优先级低的
  // 如果低优先级任务超时了，则优先级高的不能再打断优先级低的任务
  return performance.now(); // 程序从启动到现在的时间，是用来计算任务的过期时间的
}
</code></pre>
<h2>classComponentUpdater</h2>
<pre><code class="language-js">var classComponentUpdater = {
  isMounted: isMounted,
  enqueueSetState: function (inst, payload, callback) {
    var fiber = get(inst);
    var eventTime = requestEventTime();
    var lane = requestUpdateLane(fiber);
    var update = createUpdate(eventTime, lane);
    update.payload = payload;

    if (callback !== undefined &amp;&amp; callback !== null) {
      update.callback = callback;
    }
    enqueueUpdate(fiber, update);
    scheduleUpdateOnFiber(fiber, lane, eventTime);
  },
};

class Component {
  constructor() {
    // 这里为了简化流程，直接初始化this.updater为classComponentUpdater
    this.updater = classComponentUpdater;
  }
  setState(partialState, callback) {
    this.updater.enqueueSetState(this, partialState);
  }
}
</code></pre>
<h2>setState主流程图：</h2>
<p><img src="https://raw.githubusercontent.com/lizuncong/mini-react/master/imgs/setstate-10.jpg" alt="image"></p>
<p><code>fiber.updateQueue</code> 会在下一个微任务中在 <code>processUpdateQueue</code> 函数中处理</p>
<h1> </h1>
<h1>setState同步异步更新的问题</h1><h3>setState</h3>
<p>由于 React 没有实现 类似于 Vue 的依赖收集来监听数据的变化，因此我们不能直接通过 <code>this.state.count = 2</code> 修改 state 的值来更新界面。</p>
<p>我们必须手动调用 <code>this.setState</code> 触发更新过程</p>
<h3>setState 同步更新还是异步更新？</h3>
<ul>
<li>
<p>React17 稳定版本或者 React17 以前的版本中，在 react 能够接管的地方，比如生命周期或者合成事件中，setState 是异步更新的。</p>
<ul>
<li>即 legacy 模式下，</li>
</ul>
<p>但是在 setTimeout 或者通过 window.addEventListener 添加的原生事件中，setState 则是同步的。</p>
</li>
</ul>
<pre><code class="language-jsx">// Legacy同步模式
const container = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;App /&gt;, container);
</code></pre>
<ul>
<li>在 React 开发版本中，即 concurrent 模式下，setState 的更新统一是异步的</li>
</ul>
<pre><code class="language-jsx">// Concurrent异步模式，在这个模式下，任何情况下setState都是异步更新的。
const container = document.getElementById(&quot;root&quot;);
// ReactDOM.render(&lt;App /&gt;, container);
ReactDOM.createRoot(container).render(&lt;App /&gt;);
</code></pre>
<h4>setState 更新 demo</h4>
<p>以下面的代码为例，以下示例均在react@17.0.1，react-dom@17.0.1版本的 legacy 模式下实现</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;

class App extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      number: 0,
    };
  }

  handleClick = (event) =&gt; {
    // todo
  };

  render() {
    console.log(&quot;render...&quot;, this.state);
    return (
      &lt;div&gt;
        计数器：{this.state.number}
        &lt;div&gt;
          &lt;button onClick={this.handleClick}&gt;add&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  }
}
export default App;
</code></pre>
<h5>demo1</h5>
<pre><code class="language-jsx">handleClick = (event) =&gt; {
  this.setState({ number: this.state.number + 1 }, () =&gt; {
    console.log(&quot;setState1 callback&quot;, this.state);
  });
  console.log(&quot;after setState1&quot;, this.state); // number: 0
  this.setState({ number: this.state.number + 1 }, () =&gt; {
    console.log(&quot;setState2 callback&quot;, this.state);
  });
  console.log(&quot;after setState2&quot;, this.state); // number: 0
};
</code></pre>
<p>点击按钮，打印顺序：<br>
after setState1 {number: 0}<br>
after setState2 {number: 0}<br>
render... {number: 1}<br>
setState1 callback {number: 1}<br>
setState2 callback {number: 1}</p>
<p>可以得出以下结论：</p>
<ul>
<li>状态是异步更新的</li>
<li>setState 的回调函数是在状态更新后批量执行的</li>
</ul>
<h5>demo2 setTimeout 中同步更新</h5>
<pre><code class="language-jsx">handleClick = (event) =&gt; {
  setTimeout(() =&gt; {
    this.setState({ number: this.state.number + 1 }, () =&gt; {
      console.log(&quot;setState1 callback&quot;, this.state);
    });
    console.log(&quot;after setState1&quot;, this.state); // number: 0
    this.setState({ number: this.state.number + 1 }, () =&gt; {
      console.log(&quot;setState2 callback&quot;, this.state);
    });
    console.log(&quot;after setState2&quot;, this.state); // number: 0
  }, 4);
};
</code></pre>
<p>打印顺序：<br>
render... {number: 1}<br>
setState1 callback {number: 1}<br>
after setState1 {number: 1}<br>
render... {number: 2}<br>
setState2 callback {number: 2}<br>
after setState2 {number: 2}</p>
<p>可以得出以下结论</p>
<ul>
<li>状态是同步更新的，因此 setState 的回调也是同步执行的</li>
</ul>
<p><strong><em>注意观察 render 的打印时机以及次数！！！！</em></strong></p>
<h6>demo3 setState 接收一个函数</h6>
<pre><code class="language-jsx">handleClick = (event) =&gt; {
  this.setState(
    (prevState) =&gt; {
      console.log(&quot;setState1...&quot;, prevState);
      return { number: prevState.number + 1 };
    },
    () =&gt; {
      console.log(&quot;setState1 callback&quot;, this.state);
    }
  );

  console.log(&quot;after setState1&quot;, this.state);

  this.setState(
    (prevState) =&gt; {
      console.log(&quot;setState2...&quot;, prevState);
      return { number: prevState.number + 1 };
    },
    () =&gt; {
      console.log(&quot;setState2 callback&quot;, this.state);
    }
  );
  console.log(&quot;after setState2&quot;, this.state);
};
</code></pre>
<p>打印顺序：<br>
after setState1 {number: 0}<br>
after setState2 {number: 0}<br>
setState1... {number: 0}<br>
setState2... {number: 1}<br>
render... {number: 2}<br>
setState1 callback {number: 2}<br>
setState2 callback {number: 2}</p>
<p>结论：</p>
<ul>
<li>状态是异步更新的</li>
<li>可以发现在批量输出<code>setState1...</code> <code>setState2...</code> 后，即刻打印<code>render...</code>，最后打印 <code>setState1 callback</code> 以及 <code>setState2 callback</code>，这也正是说明 setState 的回调函数是在 render 更新之后执行的</li>
</ul>
<h6>demo4 settimeout 中 setState 接收函数的情况</h6>
<pre><code class="language-jsx">handleClick = (event) =&gt; {
  setTimeout(() =&gt; {
    this.setState(
      (prevState) =&gt; {
        console.log(&quot;setState1...&quot;, prevState);
        return { number: prevState.number + 1 };
      },
      () =&gt; {
        console.log(&quot;setState1 callback&quot;, this.state);
      }
    );

    console.log(&quot;after setState1&quot;, this.state);

    this.setState(
      (prevState) =&gt; {
        console.log(&quot;setState2...&quot;, prevState);
        return { number: prevState.number + 1 };
      },
      () =&gt; {
        console.log(&quot;setState2 callback&quot;, this.state);
      }
    );

    console.log(&quot;after setState2&quot;, this.state);
  }, 4);
};
</code></pre>
<p>打印顺序：<br>
setState1... {number: 0}<br>
render... {number: 1}<br>
setState1 callback {number: 1}<br>
after setState1 {number: 1}<br>
setState2... {number: 1}<br>
render... {number: 2}<br>
setState2 callback {number: 2}<br>
after setState2 {number: 2}</p>
<p>结论</p>
<ul>
<li>状态是同步更新的</li>
<li><strong><em>一定要仔细品味 setState、render、 setState callback、after setState 打印顺序之间的关系!!!!</em></strong></li>
</ul>
<h6>demo5 ReactDOM.unstable_batchedUpdates 强制异步更新状态</h6>
<pre><code class="language-jsx">handleClick = (event) =&gt; {
  setTimeout(() =&gt; {
    ReactDOM.unstable_batchedUpdates(() =&gt; {
      this.setState(
        (prevState) =&gt; {
          console.log(&quot;setState1...&quot;, prevState);
          return { number: prevState.number + 1 };
        },
        () =&gt; {
          console.log(&quot;setState1 callback&quot;, this.state);
        }
      );

      console.log(&quot;after setState1&quot;, this.state);

      this.setState(
        (prevState) =&gt; {
          console.log(&quot;setState2...&quot;, prevState);
          return { number: prevState.number + 1 };
        },
        () =&gt; {
          console.log(&quot;setState2 callback&quot;, this.state);
        }
      );

      console.log(&quot;after setState2&quot;, this.state);
    });
  }, 4);
};
</code></pre>
<p>打印顺序：<br>
after setState1 {number: 0}<br>
after setState2 {number: 0}<br>
setState1... {number: 0}<br>
setState2... {number: 1}<br>
render... {number: 2}<br>
setState1 callback {number: 2}<br>
setState2 callback {number: 2}</p>
<p>结论：</p>
<ul>
<li>在同步模式(legacy)下，如果需要在 setTimeout 等中启用异步更新，可以使用 React17 新增的<code>ReactDOM.unstable_batchedUpdates</code>API</li>
</ul>
<h1> </h1>
<h1>一次就能看懂的 Tailwind CSS 介绍</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7042901516499288077?searchId=2023082216553056BD93B193AD0875235E">juejin.cn</a></p>
</blockquote>
<h2>什么是 tailwind CSS</h2>
<p>Tailwind CSS 是一个利用公用程序类（<code>Utilize Class</code>）的 CSS 框架。</p>
<ul>
<li>Bootstrap 和 Bulma 等框架利用预先准备好的组件（例如按钮、菜单和面包屑）进行设计。</li>
<li>在 Tailwind CSS 中，没有准备任何组件，而是使用<code>Utilize Class</code>来创建和设计自己的组件。</li>
</ul>
<h2>Headless UI</h2>
<p>Tailwind CSS 还提供了一个 Headless UI，如果你想创建复杂的组件（例如下拉菜单和对话框），你可以使用</p>
<h2>原创性</h2>
<p>原来 Bootstrap 等框架可以通过提前准备组件集合来高效地设计网站，但是有一个缺点，就是因为使用了相同的设计，所以没有原创性。
相比之下，Tailwind CSS 没有组件集合，所以即使你创建一个名为相同按钮的组件，每个人都会应用不同的<code>Utilize Class</code>创建它，可以创建出一个高度原创的网站。</p>
<h3>什么是 Utilize Class？</h3>
<p>这里设置的<code>Utilize Class</code>在类本身中没有特定的含义（不像<code>Bootstrap</code>的 class <code>btn</code>代表的就是按钮）可以用在各种地方（有时用于按钮），
所以它被命名为实用程序类（<code>Utilize Class</code>）。也就是说<code>Utilize Class</code>是 Tailwind CSS 中预先配置的类。
在解释 Tailwind 的<code>Utilize Class</code>时，社区中使用了低级别一词，例如低级别样式、低级别实用程序类和低级别框架。</p>
<h3>创建一个按钮</h3>
<p>例如，如果要使用 Bootstrap 创建按钮，请将<code>class</code>设置为<code>btn</code>
但在 Tailwind 中，并没有 <code>btn</code> 等用于创建按钮的 class，你可以通过编写如下所示的<code>Utilize Class</code>来创建按钮。</p>
<p><code>bg-indigo-700</code> 设置颜色，<code>font-semibold</code> 设置字体粗细，<code>text-white</code> 设置文本颜色，<code>py-2</code> 设置左右填充，<code>px</code> 设置上下填充，<code>rounded</code> 设置圆角。
你可能会觉得要设置的类太多了，但是学习成本很低，可以通过搜索 <code>Tailwind CSS 文档</code>轻松找到要用的类名。</p>
<pre><code>&lt;button class=&quot;bg-indigo-700 font-semibold text-white py-2 px-4 rounded&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h2>使用未注册颜色</h2>
<p>有 9 种不同的字体大小和相当多的颜色的<code>Utilize Class</code>，因此你可以通过仅更新 html 文件进行设计，而无需编写自己的 css 样式
如果你想使用未在 Tailwind CSS 的<code>Utilize Class</code>中注册的颜色，你可能想知道该怎么做。在这种情况下，你可以通过在 Tailwind CSS 配置文件中注册它，以与其他 Tailwind CSS <code>Utilize Class</code>相同的方式使用它。</p>
<blockquote>
<p>在当前版本中，即使未在<code>Utilize Class</code>中注册，也可以使用括号设置<code>text-[#121212]</code>和<code>w-[100px]</code>等固定值，而无需在配置文件中对其进行描述。对于经常使用的那些，继续在配置文件中进行设置会更有效率。</p>
</blockquote>
<h3>为什么选择 Tailwind CSS？</h3>
<p>与 style 属性相比，使用 Tailwind CSS 是有一些优势的。</p>
<p>使用 Tailwind CSS，你可以使用<code>Utilize Class</code>轻松设置响应式设计，因此您无需设置媒体查询。
此外，作为伪类的悬停和焦点等设置无法通过 style 属性进行设置，但在 Tailwind CSS 中，可以通过利用类设置伪类。你还可以使用<code>Utilize Class</code>通过 CSS 设置动画和渐变颜色。</p>
<h2>搭建环境</h2>
<h3>使用 cdn 的方法</h3>
<p>使用 cdn 时，请将以下链接标签粘贴到 html 中。</p>
<pre><code>&lt;link href=&quot;https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css&quot; rel=&quot;stylesheet&quot;&gt;
</code></pre>
<p>请注意，如果你使用 cdn，你将无法自定义 Tailwind CSS，这将在本文档后面介绍，例如添加颜色。</p>
<h3>使用 npm/yarn 安装 Tailwind css</h3>
<pre><code>$ npm install tailwindcss@latest
</code></pre>
<p>接下来，创建一个 style.css 文件。将以下三个 <code>tailwind 指令</code>添加到 style.css 文件中。
这个 style.css 不能直接从 html 中读取。因此，我们稍后会构建它，并将其转换为熟悉的 html 可以读取的 css 文件。
通过构建，Tailwindcss 使用的<code>Utilize Class</code>将从基础、组件和实用程序中提取。</p>
<pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;
</code></pre>
<h3>构建 Tailwind css 文件</h3>
<p>创建一个<code>public/css</code>目录来存放构建后创建的 css 文件。
让我们实际构建并创建一个 css 文件，以从添加了 Tailwind 指令的 style.css 文件中读取 html。</p>
<pre><code>$  % npx tailwind build ./css/style.css -o ./public/css/style.css
   🚀 Building: css/style.css
</code></pre>
<p>使用 npx 命令构建，可以将 build 命令添加到 package.json 文件中</p>
<pre><code>&quot;scripts&quot;: {
  &quot;build&quot;: &quot;tailwind build css/style.css -o public/css/style.css&quot;
},
</code></pre>
<h2>build 之后的 css 文件</h2>
<p>你可以看到创建的 css 文件包含普通的 CSS。
由于 Twailwind 预先创建的所有<code>Utilize Class</code>都有描述，因此文件很大，行数为 50,000 或更多。
你还可以看到在创建的 style.css 文件的顶部应用了现代规范化。</p>
<pre><code>/*! tailwindcss v2.1.2 | MIT License | https://tailwindcss.com */

/*! modern-normalize v1.1.0 | MIT License | https://github.com/sindresorhus/modern-normalize */

</code></pre>
<p>你还可以看到在创建的 style.css 文件的顶部应用了现代规范化。</p>
<h3>字符大小设置</h3>
<p>要设置字体大小，请使用 <code>text- {size}</code>。大小可以取 13 个值。相应的 CSS 样式在括号中。</p>
<pre><code>.text-xs（字体大小：.75rem；）
.text-sm（字体大小：.875rem；）
.text-base（字体大小：1rem;）
.text-lg（字体大小：1.125rem；）
.text-xl（字体大小：1.25rem；）
.text-2xl（字体大小：1.5rem；）
.text-3xl（字体大小：1.875rem；）
.text-4xl（字体大小：2.25rem；）
.text-5xl（字体大小：3rem；）
.text-6xl（字体大小：4rem；）
.text-7xl（字体大小：4.5rem；）
.text-8xl（字体大小：6rem；）
.text-9xl（字体大小：8rem；）
</code></pre>
<h3>字符粗细设置</h3>
<p>要设置字符粗细，请使用 <code>font- {thickness}</code>。厚度可以取 9 个值。相应的 CSS 样式在括号中。</p>
<pre><code>.font-thin (font-weight: 100;)
.font-extralight (font-weight: 200;)
.font-light (font-weight: 300;)
.font-normal (font-weight: 400;)
.font-medium (font-weight: 500;)
.font-semibold (font-weight: 600;)
.font-bold（font-weight：700；）
.font-extrabold（font-weight：800；）
.font-black（font-weight：900；）
</code></pre>
<h3>文字颜色设置</h3>
<p>要设置文本颜色，请使用 <code>text- {color}-{color depth}</code>。颜色强度可以取 <strong>9</strong> 个值。例如，在绿色的情况下，如下所示。</p>
<pre><code>text-green-100（颜色：# f0fff4;）
text-green-200（颜色：#c6f6d5；）
text-green-300（颜色：#9ae6b4；）
text-green-400（颜色：#68d391；）
text-green-500（颜色：#48bb78；）
text-green-600（颜色：#38a169；）
text-green-700（颜色：#2f855a；）
text-green-800（颜色：#276749；）
text-green-900（颜色：#22543d；）
</code></pre>
<h2>创建按钮</h2>
<p>现在你知道<code>Utilize Class</code>的样子，让我们使用<code>Utilize Class</code>来创建一个按钮。</p>
<pre><code>&lt;button class=&quot;bg-indigo-700 font-semibold text-white py-2 px-4 rounded&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<p>在<code>py-2</code>中，上下设置了<code>.5rem padding</code>，在<code>px-4</code>中，左右设置了<code>1rem padding</code>。在圆形中，边界半径 .25rem 被应用并且角被圆化。</p>
<h3>Tailwind CSS 自定义</h3>
<p>由于按钮是一个很有可能被重用的组件，并且你希望在应用程序中统一设计，你可以注册<code>Utilize Class</code>集来创建按钮作为另一个类。</p>
<p>打开预构建的 <code>css / style.css</code> 文件并在 <code>@components</code> 和 <code>@utility</code> 指令之间添加以下内容。</p>
<pre><code>@tailwind base;

@tailwind components;

.btn{
    @apply font-semibold text-white py-2 px-4 rounded;
}

@tailwind utilities;
</code></pre>
<p>然后重新构建一下，<code>npm run build</code>,</p>
<p>会覆盖构建完后的<code>public/css/style.css</code>，所以打开<code>style.css</code>文件，搜索<code>btn</code></p>
<p>可以看到刚才用<code>@apply</code> 添加的内容已经作为 css 添加到<code>style.css</code>文件中了,</p>
<pre><code>.btn{
  font-weight: 600;
  color: #fff;
  padding-top: 0.5rem;
  padding-bottom: 0.5rem;
  padding-left: 1rem;
  padding-right: 1rem;
  border-radius: 0.25rem;
}
</code></pre>
<h3>伪类设置悬停</h3>
<p>了解如何通过悬停在 Tailwind 中执行伪类，以在光标悬停在按钮上时更改按钮的颜色。如果要更改颜色，请在悬停后设置颜色，设置将可以体现出来。</p>
<pre><code>&lt;button class=&quot;bg-red-700 btn hover:bg-red-500&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h3>伪类设置焦点</h3>
<p>单击按钮时还要设置焦点。为了清晰起见，从圆角变为圆形以强调按钮的圆度。修改<code>@apply</code></p>
<pre><code>@tailwind base;

@tailwind components;
.btn{
    @apply font-semibold text-white py-2 px-4 rounded-full;
}
@tailwind utilities;
</code></pre>
<p>当选择按钮（使用选项卡）时，将显示一个方框。单击时会出现一个方框，因此我们通过设置焦点以擦除方框。</p>
<p>当我将焦点设置为无轮廓时，外框消失，但我不知道按钮是否被选中。</p>
<pre><code>&lt;button class=&quot;bg-red-700 btn hover:bg-red-500 focus:outline-none&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<p>设置阴影轮廓，以便您可以看到按钮被选中。如果你设置它，会沿着按钮创建一个阴影，所以用户不会感到任何不适。</p>
<pre><code>&lt;button class=&quot;bg-red-700 btn hover:bg-red-500 focus:outline-none focus:shadow-outline&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h3>过渡设置</h3>
<p>我确认通过设置伪类的悬停可以在光标移到按钮上时更改按钮的颜色。当光标悬停在按钮上时，你可以看到颜色。你可以通过使用过渡慢慢改变按钮的颜色。下
面通过设置 duration-1000，颜色会在 1 秒内缓慢变化。持续时间的多个值从 duration-75 到 duration-1000 注册。</p>
<pre><code>&lt;button class=&quot;bg-indigo-700 font-semibold text-white py-2 px-4 rounded hover:bg-red-700 duration-1000&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h3>变换设置</h3>
<p>如果你想让按钮本身变大并通过悬停更改按钮的颜色，
您可以使用<code>transform</code> 和<code>scaling</code> 的<code>Utilize Class</code>来实现。</p>
<pre><code>&lt;button class=&quot;bg-indigo-700 font-semibold text-white py-2 px-4 rounded transform hover:scale-110 hover:bg-red-700 duration-1000&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h3>群组设置</h3>
<p>到目前为止的 hover 设置中，当光标经过目标元素时，hover 的变化就会发生在元素上，但是在 group 设置中，当光标经过父元素时，设置 hover 的子元素中就可以呈现 hover 效果。</p>
<p>在下面的示例中，当光标经过设置了 group 的父元素时，由于为子元素设置的悬停设置，一个 p 标签元素的文本颜色变为红色，另一个变为蓝色。</p>
<pre><code>&lt;div class=&quot;group m-10 p-10 border hover:bg-gray-100&quot;&gt;
  &lt;p class=&quot;font-black group-hover:text-red-900&quot;&gt;前端晚间课&lt;/p&gt;
  &lt;p class=&quot;font-black group-hover:text-blue-900&quot;&gt;前端晚间课&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<h3>动画设置</h3>
<p>只需将 <code>animate-bounce</code> 和 <code>animate-pulse</code> 设置为 class，您就可以轻松设置动画，而无需设置复杂的 CSS。</p>
<h2>tailwind.confing.js 配置文件</h2>
<h3>创建配置文件</h3>
<p>使用 Tailwind CSS，你可以通过添加 Tailwind CSS <code>Utilize Class</code>中未包含的颜色、边距、宽度等进行自定义。自定义需要配置文件，但默认情况下不会创建，所以使用命令创建。</p>
<pre><code>% npx tailwind init
   ✅ Created Tailwind config file: tailwind.config.js
</code></pre>
<p>上面的命令将创建一个 <code>tailwind.config.js</code> 文件。</p>
<h3>添加颜色</h3>
<pre><code>module.exports = {
  theme: {
    extend: {
      colors: {
        cyan: '#9cdbff',
      }
    }
  },
  variants: {},
  plugins: []
}
</code></pre>
<p>添加后，构建，<code>npm run build</code>
将按钮颜色从红色更改为青色。由于加入青色时没有设置色深，所以设置为<code>bg-cyan</code>（从<code>bg-red-700</code>改为<code>bg-cyan</code>）。</p>
<pre><code>&lt;button class=&quot;bg-cyan btn hover:bg-red-500 focus:outline-none focus:shadow-outline&quot;&gt;前端晚间课&lt;/button&gt;
</code></pre>
<h3>添加最大宽度并添加间距</h3>
<p>你可以使用 <code>max-width</code> 设置浏览器上元素的最大宽度，但你可能希望将其设置为与 Tailwind CSS 中默认注册的宽度不同的宽度。
在这种情况下，请在 tailwind.config.js 以及颜色中进行其他设置。</p>
<pre><code>theme: {
    extend: {
        colors:{
            'cyan':'#9cdbff',
        },
        maxWidth:{
            custom:'60rem',
        },
    },
    variants: {},
    plugins: []
},
</code></pre>
<p>在 class 属性中使用时，设置<code>max-w-custom</code>。
可以使用间距设置宽度。</p>
<pre><code>theme: {
    extend: {
        colors:{
            'cyan':'#9cdbff',
        },
        maxWidth:{
            custom:'60rem',
        },
        spacing:{
            76: '19rem',
        },
    },
    variants: {},
    plugins: []
},
</code></pre>
<p>在 class 属性中使用时，设置为<code>w-76</code>。
即使你不使用配置文件，你也可以为那些不经常使用的样式设置一个诸如<code>p-[19rem]</code>之类的描述。</p>
<h3>添加字体大小</h3>
<p>最小的字体大小类是<code>text-xs</code>，但是如果你想添加一个更小的字体大小类，你可以这样做。</p>
<pre><code>theme: {
    extend: {
        fontSize:{
            xxs:['0.625em',{lineHeight:'1rem'}],
        },
    },
    variants: {},
    plugins: []
},
</code></pre>
<p>如果要使用它，请在 class 属性中设置 <code>text-xxs</code> 。</p>
<h3>如何自定义其他值</h3>
<h2>我解释了如何添加颜色、最大宽度、宽度和字体大小，但是当我想添加框阴影时，我应该在哪里查看设置方法，例如？
首先，转到官方 <code>Tailwind CSS</code> 文档并进行搜索。
在文档中搜索 搜索时，将显示 Box Shadow 页面。
盒子阴影页面
滚动时，您会找到<code>自定义</code>。Tailwind CSS 中默认注册的值会显示在那里，所以如果你想用一个没有包含的值来设置它，请根据显示的设置方法将它添加到 <code>tailwind.config.js</code> 文件中。
Tailwind CSS 插件设置</h2>
<p>Tailwind CSS 提供了一些官方插件。
让我们检查一下如何设置<code>tailwindcss / line-clamp</code>，这是插件之一。
当在浏览器上显示像下面这样的长句时，它也会在浏览器上显示多行。
如果你只想查看前几行而不是所有行，则可以使用插件 <code>tailwindcss / line-clamp</code>。</p>
<pre><code>% npm install @tailwindcss/line-clamp
</code></pre>
<p>安装完成后，需要在<code>tailwind.config.js</code>中注册安装包的信息。</p>
<pre><code>plugins: [require('@tailwindcss/line-clamp'),],
</code></pre>
<p>进行设置构建完成后，使用插件的设置就完成了。
<code>line-clamp</code> 设置 <code>line-clamp</code> 后要显示的行数，如下所示。</p>
<pre><code>&lt;div class=&quot;m-20&quot;&gt;
  &lt;div class=&quot;line-clamp-3&quot;&gt;
    Lorem ipsum dolor sit amet//略
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>只能显示设置了 line-clamp-3 的 3 行。</p>
<h1> </h1>
<h1>学习的本质是不是 “能理解就理解，不能理解的就硬背”？ - 知乎</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.zhihu.com/question/613033850/answer/3179099793">www.zhihu.com</a></p>
</blockquote>
<p>理解和记忆是相辅相成的。</p>
<h2>构建 - 整合模型</h2>
<p>认知心理学家 Walter Kintsch 提出了广受研究的构建 - 整合模型，将文本理解分为两部分：</p>
<ol>
<li>对文本构建内在表征：阅读单词，解析句法，理解名词的指代和动词的歧义等等。Kintsch 把这种心理表征称为<strong>文本基础</strong></li>
<li>通过整合来理解含义，形成文章里<strong>没有</strong>直接描述的联系。你会把文章里的词语和观点，和你自己已经知道的东西联系起来，同时你会推断出作者意有所指但没有成文的细节。Kintsch 将将这种完整而联系丰富的心理表征称为<strong>情境模型</strong></li>
</ol>
<h2>构建 - 整合模型得出的结论：</h2>
<ul>
<li>更好的整合能够产生更好的记忆</li>
<li>更好的记忆能带来更好的整合</li>
<li>注意力影响理解程度</li>
<li>整合程度控制知识迁移</li>
</ul>
<h2>我们是如何理解文字解释的呢？</h2>
<p>「理解」究竟是什么呢？
从现实中的宏观行为-「理解就是能够明智且有效地在上下文中使用——迁移——我们所学到的知识，在现实任务和环境中，能够有效地运用知识和技能。」
从大脑的底层机制——感知，注意力，处理，记忆——开始
「理解」并不是单一的概念，而指代了许多协作的过程，是一个不准确的术语。</p>
<p>认知心理学家把这种理解称为「文本理解」
具体来说，你得搞清楚作者句子的意思；你得能解释文本中描述和暗示的特性和关系；你得能基于这些细节和已有的相关知识，做出简单的推理。至于熟练度或长期记忆，我们暂时不考虑。</p>
<p>Walter Kintsch 提出了广受研究的构建 - 整合模型，该模型将这个过程分为两部分 。</p>
<h3><strong>更好的整合能够产生更好的记忆</strong>。</h3>
<p>回忆和记忆巩固在于关联。</p>
<ul>
<li>如果新的文本信息只能通过单一线索<strong>连接</strong>到你已有的知识，那你可能会很难回忆起来，而且在之后的认知过程中，这些信息也不太可能得到强化。</li>
<li>将新的文本信息和你原有的知识钩连起来，形成更丰富的情境模型。钩连越多，记忆效果越好。
这也验证了我们的直觉，即在我们已经精通的领域，更容易记住新的信息。</li>
</ul>
<h3><strong>更好的记忆能带来更好的整合</strong>。</h3>
<p>如同我们之前所见，文本基础中信息点之间的联系和推理，往往需要「通过」你已有知识节点间的路径。这暗示着记忆强化在机制中的角色：你无法通过你已经忘记的节点。</p>
<ul>
<li>如果第二章的内容依赖于第一章不太熟悉的信息，我们就需要确保在你需要理解第二章的内容之前，你能够记住第一章的信息。</li>
</ul>
<h3><strong>「用你自己的话说出来。」</strong></h3>
<p>在学习过程中，如果你<strong>不用</strong>自己的话来阐述文本（即使这可能在你的潜意识里进行），你基本学不到任何东西。</p>
<p>想要形成一个整合良好的情境模型，你得把作者用词<strong>所指</strong>的概念，跟你已有知识中的概念关联起来。也就是说，你在此过程中处理的是概念，而不是语词。</p>
<p>比如，一个作者说的「通过肺部排出二氧化碳」，另一个作者说的「呼出二氧化碳」，你通常需要把这两个短语解读为同一概念。否则你就无法把这两篇文本所形成的情境模型联系起来。</p>
<h3><strong>注意力影响理解程度</strong>。</h3>
<p>有一种显然的失败经历大家都很熟悉：有时候，某句话你看得太快了，甚至都没来得及解读它里面的词。或者，你读了句子里的词，但注意力太分散，无法解析其中复杂的句子结构。在这些情况下，你根本无法对文本形成文本理解。你可能只是处理了文本的「表面特征」，</p>
<p>例如注意到这部分文字中出现了某个关键词，但你无法利用这些信息，即使是直接照搬都不行。</p>
<ul>
<li>文本的选取会影响这里的行为：在 Kintsch 的一个实验中，如果文本太啰嗦或太熟悉，参与者们会依赖他们已有的情境模型，并形成有损的文本基础表征。</li>
</ul>
<h3><strong>整合程度控制知识迁移</strong>。</h3>
<p>如果你发现你能复述作者的话，但在用你自己的话阐述这些观点，或实践这些观点时，却颇感吃力，那么这说明你的情境模型过于依赖于你的文本基础。
也就是说，构成你的心理表征的，主要是与作者的词汇和短语对应的节点。
所以，当接收到与文本形状不完全一样的线索时，你无法将它们和你已经学到的东西联系起来。
你需要多与文本打交道，把它与你已知的知识联系起来，提出问题，进行推理。</p>
<h1> </h1>
<h1>盘点fiber中常见的副作用标志flags</h1><p>在 React 的渲染流程中，render 阶段从根节点开始处理所有的 fiber 节点，收集有副作用的 fiber 节点(即 fiber.flags 大于 1 的节点)，并构建副作用链表。
commit 阶段并不会处理所有的 fiber 节点，而是遍历副作用链表，根据 fiber.flags 的标志进行对应的处理。
React 在 render 阶段给有副作用的节点添加标志，并在 commit 阶段根据 fiber flags 执行对应的副作用操作，比如调用生命周期方法，或者操作真实的 DOM 节点。</p>
<h2>位操作</h2>
<p>在开始介绍 fiber flags 前，先来看下位操作</p>
<h3>按位非(~)</h3>
<p>按位非运算符（~），反转操作数的位。</p>
<pre><code class="language-js">const a = 5; // 00000000000000000000000000000101
const b = -3; // 11111111111111111111111111111101

console.log(~a); // 11111111111111111111111111111010，即-6

console.log(~b); // 00000000000000000000000000000010， 即2
</code></pre>
<p>按位非运算时，任何数字 x 的运算结果都是 -(x + 1)。例如，〜-5 运算结果为 4。</p>
<h3>按位异或(^)</h3>
<p>有且仅有一个为 1 时，结果才为 1，否则为 0:</p>
<pre><code class="language-js">const a = 5; // 00000000000000000000000000000101
const b = 3; // 00000000000000000000000000000011

console.log(a ^ b); // 00000000000000000000000000000110，即6
</code></pre>
<h2>React 为什么采用二进制表示副作用</h2>
<p>原因可以归类为以下两点：</p>
<ul>
<li>位运算快速</li>
<li>可以方便的给一个 fiber 节点添加多个副作用，同时内存开销小。
当然，代价是代码可读性差，谨慎在业务代码中使用此类操作</li>
</ul>
<h2>其他方式表示副作用会有什么问题</h2>
<p>假设我们使用 2 表示插入，在 render 阶段，如果这个 fiber 节点是新的，我们就给这个 fiber 节点添加一个副作用：<code>fiber.flags = 2</code>。
然后在 commit 阶段使用 <code>fiber.flags === 2</code> 判断节点是否需要插入。</p>
<p><strong>这会带来一个问题，React 中一个 fiber 节点会有多个副作用，比如，既可以是插入，又可以是更新(类组件实现了 componentDidMount 方法，就是更新的副作用)</strong>，
如果使用十进制，我们可以很容易想到这样实现：</p>
<pre><code class="language-js">fiber.flags = [];
fiber.flags.push(2); // 插入
fiber.flags.push(4); // 更新，此时 fiber.flags有两个副作用：[2, 4]
</code></pre>
<p>在 commit 阶段就可以这样判断：</p>
<pre><code class="language-js">if (fiber.flags.includes(2)) {
  // 执行插入的逻辑
}
if (fiber.flags.includes(4)) {
  // 执行更新的逻辑
}
</code></pre>
<p>这样做理论上是可以的，但是数组操作比较麻烦，还会冗余，比如，如果多次 <code>fiber.flags.push(2)</code> 就会有多个重复的 2。同时如果需要先删除插入的副作用，并添加一个更新的副作用，操作起来较繁琐</p>
<p>因此 React 采用了二进制标记这些副作用。不仅占用内存小，运算迅速，同时还能表示多个副作用</p>
<h2>react二进制flag演示</h2>
<p>如果一个 fiber 节点，既要插入又要更新，可以这样标记：</p>
<pre><code class="language-js">fiber.flags |= Placement | Update; // Placement 0b000000000000000010  Update  0b000000000000000100
</code></pre>
<p>如果需要删除一个插入的副作用，并且添加一个更新的副作用，那么可以这样标记：</p>
<pre><code class="language-js">fiber.flags = (fiber.flags &amp; ~Placement) | Update;
</code></pre>
<p>可以说是相当的方便了</p>
<h2>Fiber flags</h2>
<p><code>PerformedWork</code> 是专门提供给 React Dev Tools 读取的。
fiber 节点的副作用从 2 开始。0 表示没有副作用。
对于原生的 HTML 标签，如果需要修改属性，文本等，就视为有副作用。
对于类组件，如果类实例实现了 <code>componentDidMount</code>、<code>componentDidUpdate</code> 等生命周期方法，则视为有副作用。
对于函数组件，如果实现了 <code>useEffect</code>、<code>useLayoutEffect</code> 等 hook，则视为有副作用。以上这些都是副作用的例子。</p>
<h3>React 支持的所有 flags</h3>
<pre><code class="language-js">// 下面两个运用于 React Dev Tools，不能更改他们的值
const NoFlags = 0b000000000000000000;
const PerformedWork = 0b000000000000000001;

// 下面的 flags 用于标记副作用
const Placement = 0b000000000000000010; // 2 移动，插入
const Update = 0b000000000000000100; // 4
const PlacementAndUpdate = 0b000000000000000110; // 6
const Deletion = 0b000000000000001000; // 8
const ContentReset = 0b000000000000010000; // 16
const Callback = 0b000000000000100000; // 32 类组件的 update.callback
const DidCapture = 0b000000000001000000; // 64
const Ref = 0b000000000010000000; // 128
const Snapshot = 0b000000000100000000; // 256
const Passive = 0b000000001000000000; // 512
const Hydrating = 0b000000010000000000; // 1024

const HydratingAndUpdate = 0b000000010000000100; // 1028 Hydrating | Update

// 这是所有的生命周期方法(lifecycle methods)以及回调(callbacks)相关的副作用标志，其中 callbacks 指的是 update 的回调，比如调用this.setState(arg, callback)的第二个参数
const LifecycleEffectMask = 0b000000001110100100; // 932 Passive | Update | Callback | Ref | Snapshot

// 所有 host effects 的集合
const HostEffectMask = 0b000000011111111111; // 2047

// 下面这些并不是真正的副作用标志
const Incomplete = 0b000000100000000000; // 2048
const ShouldCapture = 0b000001000000000000; // 4096
const ForceUpdateForLegacySuspense = 0b000100000000000000; // 16384
</code></pre>
<h3>flags 位操作</h3>
<p>这里简单列举一下 fiber flags 中一些位操作的含义。</p>
<pre><code class="language-js">// 1.移除所有的生命周期相关的 flags
fiber.flags &amp;= ~LifecycleEffectMask;

// 2.只保留 host effect 相关的副作用，移除其他的副作用位
fiber.flags &amp;= HostEffectMask;

// 3.只保留 &quot;插入&quot; 副作用
fiber.flags &amp;= Placement;

// 4.添加一个 “更新” 副作用，注意和第3点保留 “插入” 副作用的区别
fiber.flags |= Update;

// 5.移除 &quot;插入&quot; 副作用，添加 &quot;更新&quot; 副作用
fiber.flags = (fiber.flags &amp; ~Placement) | Update;
</code></pre>
<p><strong>下面会详细介绍常见的 fiber flags 在 render 阶段是如何被标记的，在 commit 阶段又执行了哪些对应的操作</strong></p>
<h2>Placement 副作用</h2>
<p>Placement 用于标记新的节点创建并插入，旧的节点移动。这个标记作用于所有类型的 fiber 节点</p>
<h3>render 阶段的Placement</h3>
<ul>
<li>新的节点插入，旧的节点移动都属于 Placement 副作用。<code>reconcile children</code> 过程中，如果节点需要移动，插入，则在 <code>placeChild</code> 或者 <code>placeSingleChild</code> 方法中将 fiber 标记为 <code>Placement</code></li>
</ul>
<pre><code class="language-js">newFiber.flags = Placement;
</code></pre>
<hr>
<ul>
<li>创建新的 fiber 节点，本质上也是属于新的节点插入，因此也属于 Placement 副作用。在类组件第一次渲染时执行的 <code>updateClassComponent</code> 方法、懒加载组件第一次渲染时执行的 <code>mountLazyComponent</code> 方法、函数组件第一次渲染时执行的 <code>mountIndeterminateComponent</code> 方法中，判断 fiber 节点如果是新创建的，则标记为 <code>Placement</code>。当然还有 Suspense 组件相关的方法执行时也会判断，不在本次讨论的范围</li>
</ul>
<pre><code class="language-js">if (instance === null) {
  if (current !== null) {
    // Since this is conceptually a new fiber, schedule a Placement effect
    workInProgress.flags |= Placement;
  }
}
</code></pre>
<h3>commit 阶段Placement</h3>
<p>commit 阶段执行 Placement 副作用对应的操作：<code>commitPlacement</code>。commitPlacement 负责插入新节点以及移动旧的 DOM 节点。<code>commitMutationEffects</code> 是一个基于 fiber flags 的 switch 语句，根据 fiber flags 执行对应的操作</p>
<pre><code class="language-js">function commitMutationEffects(root, renderPriorityLevel) {
  while (nextEffect !== null) {
    var primaryFlags = flags &amp; (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case Placement: {
        commitPlacement(nextEffect);
        // 插入逻辑执行完成后，移除 Placement 副作用标记
        nextEffect.flags &amp;= ~Placement;
        break;
      }

      case PlacementAndUpdate: {
        // Placement
        commitPlacement(nextEffect);
        nextEffect.flags &amp;= ~Placement;
        // Update
        commitWork(_current, nextEffect);
        break;
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitPlacement(finishedWork) {
  // 执行节点的插入逻辑
  if (isContainer) {
    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);
  } else {
    insertOrAppendPlacementNode(finishedWork, before, parent);
  }
}
</code></pre>
<h2>Update 副作用</h2>
<p>Update 副作用主要用来标记某些生命周期方法，DOM 属性及文本内容变更等。
这个标记作用于所有类型的 fiber 节点</p>
<h3>render 阶段Update 副作用</h3>
<ul>
<li><code>mountClassInstance</code>、<code>resumeMountClassInstance</code> 方法中判断类组件如果实现了 componentDidMount 方法</li>
<li><code>updateClassInstance</code> 方法中判断如果类组件实现了 <code>componentDidUpdate</code>方法</li>
<li><code>updateHostComponent</code> 方法中调用 <code>prepareUpdate</code> 方法判断 HostComponent 的属性如果发生了变更</li>
<li><code>updateHostText</code> 方法中判断如果新旧文本不同</li>
<li><code>completeWork</code> 方法中，判断如果 HostComponent 需要聚焦</li>
<li>函数组件如果调用了 <code>useEffect</code>、 <code>useLayoutEffect</code>、<code>useImperativeHandle</code> 这几个 hook</li>
<li>beginWork 方法中的 <code>updateProfiler</code>，以及 completeWork 方法中与 <code>hydrated</code> 有关的，也会被标记为 Update 副作用，不在本次讨论范围</li>
</ul>
<pre><code class="language-js">workInProgress.flags |= Update;
</code></pre>
<h3>commit 阶段Update 副作用</h3>
<ul>
<li>在 <code>commitMutationEffects</code> 阶段，如果 fiber 节点具有 Update 副作用，则调用 <code>commitWork</code> 方法执行对应的操作
<ul>
<li>调用函数组件 useLayoutEffect 的清除函数</li>
<li>更新真实的 DOM 节点的属性</li>
<li>更新真实 DOM 节点的文本内容。textInstance.nodeValue = newText</li>
</ul>
</li>
<li>在 <code>commitLayoutEffects</code> 阶段，如果 fiber 节点具有 Update 副作用，则调用 commitLifeCycles 执行对应的操作。
<ul>
<li>调用类组件的生命周期方法 <code>componentDidMount</code> 以及 <code>componentDidUpdate</code></li>
<li>调用函数组件 useLayoutEffect 的监听函数，同时将函数组件的 useEffect 的监听函数放入微任务队列执行</li>
<li>判断 HostComponent 元素是否需要自动聚焦，如果元素需要自动聚焦，则调用 dom.focus()方法实现自动聚焦</li>
</ul>
</li>
</ul>
<h2>commitMutationEffects 阶段Update 副作用</h2>
<pre><code class="language-js">function commitMutationEffects(root, renderPriorityLevel) {
  while (nextEffect !== null) {
    var primaryFlags = flags &amp; (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case PlacementAndUpdate: {
        // Placement
        commitPlacement(nextEffect);
        // Clear the &quot;placement&quot; from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        nextEffect.flags &amp;= ~Placement; // Update
        var _current = nextEffect.alternate;
        commitWork(_current, nextEffect);
        break;
      }
      case HydratingAndUpdate: {
        nextEffect.flags &amp;= ~Hydrating; // Update
        var _current2 = nextEffect.alternate;
        commitWork(_current2, nextEffect);
        break;
      }
      case Update: {
        var _current3 = nextEffect.alternate;
        commitWork(_current3, nextEffect);
        break;
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitWork(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      // 调用函数组件 useLayoutEffect 的清除函数
      commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
      return;
    }
    case HostComponent: {
      if (instance != null) {
        var updatePayload = finishedWork.updateQueue;
        if (updatePayload !== null) {
          // 更新真实的DOM节点的属性
          commitUpdate(instance, updatePayload, type, oldProps, newProps);
        }
      }
      return;
    }
    case HostText: {
      var oldText = current !== null ? current.memoizedProps : newText;
      // 更新文本内容。textInstance.nodeValue = newText
      commitTextUpdate(textInstance, oldText, newText);
      return;
    }
  }
}
</code></pre>
<h2>commitLayoutEffects 阶段Update 副作用</h2>
<pre><code class="language-js">function commitLayoutEffects(root, committedLanes) {
  while (nextEffect !== null) {
    if (flags &amp; (Update | Callback)) {
      var current = nextEffect.alternate;
      commitLifeCycles(root, current, nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      // 调用函数组件 useLayoutEffect 的监听函数
      commitHookEffectListMount(Layout | HasEffect, finishedWork);
      // 将函数组件的 useEffect 的监听函数放入微任务队列执行
      schedulePassiveEffects(finishedWork);
      return;
    }
    case ClassComponent: {
      if (finishedWork.flags &amp; Update) {
        if (current === null) {
          instance.componentDidMount();
        } else {
          instance.componentDidUpdate(
            prevProps,
            prevState,
            instance.__reactInternalSnapshotBeforeUpdate
          );
        }
      }
      return;
    }
    case HostComponent: {
      if (current === null &amp;&amp; finishedWork.flags &amp; Update) {
        // commitMount方法用于判断元素是否需要自动聚焦，如果元素需要自动聚焦，则调用dom.focus()方法实现自动聚焦
        commitMount(_instance2, type, props);
      }
      return;
    }
  }
}
</code></pre>
<h2>Deletion 副作用</h2>
<p>Deletion 主要用于标记需要被删除的节点。这个标记作用于所有类型的 fiber 节点</p>
<h3>render 阶段</h3>
<ul>
<li>在 <code>reconcile children</code> 过程中， <code>deleteChild</code> 方法判断节点如果需要被删除，则标记为 Deletion</li>
</ul>
<pre><code class="language-js">childToDelete.flags = Deletion;
</code></pre>
<h3>commit 阶段</h3>
<p>commit 阶段，如果节点具有 Deletion 副作用，则删除节点，并释放节点的引用属性，比如重置 fiber.sibling，fiber.stateNode 等属性为空，方便垃圾回收，否则会有内存泄漏的风险。</p>
<ul>
<li>commitMutationEffects 阶段，删除 fiber 节点，释放引用属性。</li>
<li>在 <code>commitLayoutEffects</code> 阶段执行完成后，需要判断如果 fiber 包含 Deletion 副作用，说明需要删除。调用 <code>detachFiberAfterEffects</code> 重置 fiber.sibling 以及 fiber.stateNode</li>
</ul>
<h2>commit deletion代码</h2>
<pre><code class="language-js">function commitRootImpl(root, renderPriorityLevel) {
  commitBeforeMutationEffects();
  commitMutationEffects(root, renderPriorityLevel);
  commitLayoutEffects(root, lanes);
  nextEffect = firstEffect;

  while (nextEffect !== null) {
    if (nextEffect.flags &amp; Deletion) {
      detachFiberAfterEffects(nextEffect);
    }
    nextEffect = nextNextEffect;
  }
}
function detachFiberAfterEffects(fiber) {
  fiber.sibling = null;
  fiber.stateNode = null;
}

function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var current = nextEffect.alternate;
    if (!shouldFireAfterActiveInstanceBlur &amp;&amp; focusedInstanceHandle !== null) {
      // 这里面Deletion没做啥操作
      if ((nextEffect.flags &amp; Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
        }
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitMutationEffects(root, renderPriorityLevel) {
  while (nextEffect !== null) {
    var primaryFlags = flags &amp; (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case Deletion: {
        commitDeletion(root, nextEffect); // 删除节点
        break;
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitDeletion(finishedRoot, current, renderPriorityLevel) {
  // 从当前节点开始，递归删除其所有的子节点，并调用 componentWillUnmount 生命周期方法
  unmountHostComponents(finishedRoot, current);
  // 释放引用
  var alternate = current.alternate;
  detachFiberMutation(current);
  if (alternate !== null) {
    detachFiberMutation(alternate);
  }
}

function detachFiberMutation(fiber) {
  // Cut off the return pointers to disconnect it from the tree. Ideally, we
  // should clear the child pointer of the parent alternate to let this
  // get GC:ed but we don't know which for sure which parent is the current
  // one so we'll settle for GC:ing the subtree of this child. This child
  // itself will be GC:ed when the parent updates the next time.
  // Note: we cannot null out sibling here, otherwise it can cause issues
  // with findDOMNode and how it requires the sibling field to carry out
  // traversal in a later effect. See PR #16820. We now clear the sibling
  // field after effects, see: detachFiberAfterEffects.
  //
  // Don't disconnect stateNode now; it will be detached in detachFiberAfterEffects.
  // It may be required if the current component is an error boundary,
  // and one of its descendants throws while unmounting a passive effect.
  // 重置 fiber.return 断开与父节点的联系。本来应该要同时重置parentFiber.child属性，以断开父节点和当前节点的联系。但由于还不确定当前的父节点，因此只需要释放当前节点的子节点。注意这里并没有继续遍历当前节点的所有子节点并释放这些引用。
  // 注意，这里目前还不能释放 sibling 以及 stateNode，这两个属性都是在最后的detachFiberAfterEffects方法中释放
  fiber.alternate = null;
  fiber.child = null;
  fiber.dependencies = null;
  fiber.firstEffect = null;
  fiber.lastEffect = null;
  fiber.memoizedProps = null;
  fiber.memoizedState = null;
  fiber.pendingProps = null;
  fiber.return = null;
  fiber.updateQueue = null;
}
</code></pre>
<h2>ContentReset 副作用</h2>
<p>ContentReset 用于标记需要重置文本的 HostComponent 节点。这个标记只作用于 HostComponent</p>
<h3>render 阶段</h3>
<ul>
<li>updateHostComponent 方法判断是否需要重置 HostComponent 文本内容为空字符串，即在下面的情况下，需要清空节点的文本内容。这也是需要清空文本内容的唯一情况</li>
</ul>
<pre><code class="language-js">// 旧的节点，只包含一个子节点，并且是文本内容
&lt;div id=&quot;test&quot;&gt;this is old text&lt;/div&gt;
// 新的子节点，子节点不再是单一的文本内容，因此需要复用div#test这个DOM节点，但是前提是需要先清空它旧的文本内容
&lt;div id=&quot;test&quot;&gt;
  &lt;span&gt;new&lt;/span&gt;
  &lt;span&gt;text&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">function shouldSetTextContent(type, props) {
  return (
    type === &quot;textarea&quot; ||
    type === &quot;option&quot; ||
    type === &quot;noscript&quot; ||
    typeof props.children === &quot;string&quot; ||
    typeof props.children === &quot;number&quot; ||
    (typeof props.dangerouslySetInnerHTML === &quot;object&quot; &amp;&amp;
      props.dangerouslySetInnerHTML !== null &amp;&amp;
      props.dangerouslySetInnerHTML.__html != null)
  );
}
function updateHostComponent(current, workInProgress, renderLanes) {
  var prevProps = current !== null ? current.memoizedProps : null;
  var isDirectTextChild = shouldSetTextContent(type, nextProps);
  if (isDirectTextChild) {
    // We special case a direct text child of a host node. This is a common
    // case. We won't handle it as a reified child. We will instead handle
    // this in the host environment that also has access to this prop. That
    // avoids allocating another HostText fiber and traversing it.
    nextChildren = null;
  } else if (prevProps !== null &amp;&amp; shouldSetTextContent(type, prevProps)) {
    // If we're switching from a direct text child to a normal child, or to
    // empty, we need to schedule the text content to be reset.
    workInProgress.flags |= ContentReset;
  }
  return workInProgress.child;
}
</code></pre>
<h3>commit 阶段</h3>
<p>重置 DOM 节点的 nodeValue 或者 textContent 属性为空字符串</p>
<pre><code class="language-js">function commitMutationEffects(root, renderPriorityLevel) {
  while (nextEffect !== null) {
    if (flags &amp; ContentReset) {
      // 重置当前DOM节点文本内容为空字符串
      commitResetTextContent(nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
}

function commitPlacement(finishedWork) {
  if (parentFiber.flags &amp; ContentReset) {
    // Reset the text content of the parent before doing any insertions
    // 重置 父节点的 文本内容为空字符串：parent.textContent = '' 或者 parent.firstChild.nodeValue = ''
    resetTextContent(parent);
    // Clear ContentReset from the effect tag
    parentFiber.flags &amp;= ~ContentReset;
  }
}
</code></pre>
<h2>Callback 副作用</h2>
<p>Callback 用于标记创建了更新对象并且更新对象有 callback 回调的类组件或者 HostRoot。这个标记只作用于类组件和 HostRoot 节点(即容器 root 节点)</p>
<h3>render 阶段</h3>
<p>对于类组件，如果我们调用了 <code>this.setState(arg, callback)</code> 传递了第二个参数 callback，则创建的更新对象 update 就会有 update.callback 回调，对应的 fiber flags 就需要被标记为有 Callback 副作用</p>
<p>对于 HostRoot，即容器节点，如果我们调用的 <code>ReactDOM.render(element, container, callback)</code> 传递了第三个参数 callback，那么在创建更新对象时，update.callback 就有回调，HostRoot 就需要被标记为有 Callback 副作用</p>
<ul>
<li><code>processUpdateQueue</code> 方法中判断如果 update.callback 不为 null。类组件以及 HostRoot 都会调用 processUpdateQueue 方法。</li>
</ul>
<pre><code class="language-js">function processUpdateQueue(workInProgress, props, instance, renderLanes) {
  if (callback !== null) {
    workInProgress.flags |= Callback;
  }
}
</code></pre>
<h3>commit 阶段Callback flag code</h3>
<pre><code class="language-js">function commitLayoutEffects(root, committedLanes) {
  while (nextEffect !== null) {
    if (flags &amp; (Update | Callback)) {
      commitLifeCycles(root, current, nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitLifeCycles(finishedRoot, current, finishedWork, committedLanes) {
  switch (finishedWork.tag) {
    case ClassComponent: {
      var updateQueue = finishedWork.updateQueue;
      if (updateQueue !== null) {
        // 执行update.callback，其实就是执行我们调用this.setState(arg, callback)传递的第二个回调参数
        commitUpdateQueue(finishedWork, updateQueue, instance);
      }
      return;
    }
    case HostRoot: {
      if (_updateQueue !== null) {
        // 执行update.callback，其实就是执行的 ReactDOM.render(element,root, callback) 第三个参数传递的callback回调
        commitUpdateQueue(finishedWork, _updateQueue, _instance);
      }
      return;
    }
  }
}
</code></pre>
<h2>Snapshot 副作用</h2>
<p>Snapshot 用于标记实现了 getSnapshotBeforeUpdate 方法的类组件对应的 fiber 节点。这个标记只作用于类组件以及 HostRoot(即容器 root 节点)</p>
<h3>render 阶段</h3>
<ul>
<li>updateClassInstance 方法判断类组件实例如果实现了 getSnapshotBeforeUpdate 方法</li>
<li>completeWork 方法中，对于 HostRoot，如果是页面第一次渲染，则给 HostRoot 添加一个 Snapshot 副作用</li>
</ul>
<pre><code class="language-js">workInProgress.flags |= Snapshot;
</code></pre>
<h3>commit 阶段</h3>
<ul>
<li>类组件对应的 fiber flag 有 Snapshot 标记，说明需要调用 getSnapshotBeforeUpdate 生命周期方法。</li>
<li>对于 HostRoot，如果 HostRootFiber 带有 Snapshot 标记，说明是页面第一次渲染，需要先清空 root： root.textContent = ''</li>
</ul>
<h2>commit 阶段SnapshotCode flag code</h2>
<pre><code class="language-js">function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    if ((flags &amp; Snapshot) !== NoFlags) {
      commitBeforeMutationLifeCycles(current, nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
}
function commitBeforeMutationLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case FunctionComponent: {
      return;
    }
    case ClassComponent: {
      if (finishedWork.flags &amp; Snapshot) {
        if (current !== null) {
          var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
        }
      }
      return;
    }
    case HostRoot: {
      if (finishedWork.flags &amp; Snapshot) {
        var root = finishedWork.stateNode;
        // 在插入我们的页面内容之前，先清空root容器 root.textContent = ''
        clearContainer(root.containerInfo);
      }
      return;
    }
  }
}
</code></pre>
<h2>Passive 副作用</h2>
<p>Passive 用于标记调用了 useEffect 的函数组件。这个标记只作用于函数组件。</p>
<h3>render 阶段 Passive</h3>
<ul>
<li>函数组件如果实现了 <code>useEffect</code>(注意，useLayoutEffect 并不属于 Passive 的副作用)</li>
</ul>
<pre><code class="language-js">fiber.flags |= Passive;
</code></pre>
<h3>commit 阶段 Passive</h3>
<pre><code class="language-js">function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    var flags = nextEffect.flags;
    if ((flags &amp; Passive) !== NoFlags) {
      // 启动一个微任务刷新 useEffect 的监听函数以及清除函数
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalPriority$1, function () {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
</code></pre>
<h1> </h1>