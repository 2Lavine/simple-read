<h1>300 行代码实现 React 的调度器 Scheduler</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7171728961473347614?searchId=20230722164549C90E0B97E39FDD8357CF">juejin.cn</a></p>
</blockquote>
<h2>源码 Schedule.js</h2>
<hr>
<p>// 浏览器提供的 API，获取从 time origin（当前文档生命周期的开始节点时间） 之后到当前调用时经过的时间，它以一个恒定的速率慢慢增加的，不会受到系统时间的影响，具体参考：https://juejin.cn/post/7171633315336683528
let getCurrentTime = () =&gt; performance.now();</p>
<hr>
<p>// 引入最小堆封装代码
import {push, pop, peek} from './ScheduleMinHeap.js';</p>
<p>// Scheduler 优先级划分，数字越小优先级越高，0 表示没有优先级
const NoPriority = 0;
const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;</p>
<p>// Scheduler 根据优先级设置的对应 timeout 时间，越小越紧急</p>
<hr>
<p>在 React 中，任务是可以被打断的，但是任务不能一直被打断，所以要设置一个超时时间，过了这个时间就必须立刻执行
// timeout 就表示超时时间
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
// 为什么是 1073741823，用了 31（30+1） 位来保存
var IDLE_PRIORITY_TIMEOUT = 1073741823;</p>
<hr>
<p>// 普通任务队列，它是一个最小堆结构
var taskQueue = [];
// 延时任务队列，它同样是一个最小堆结构
var timerQueue = [];
// taskId
var taskIdCounter = 1;</p>
<hr>
<p>// 任务队列是否正在被遍历执行，workLoop 执行前为 true，执行完成后改为 false
var isPerformingWork = false;
// 是否有正在执行的 requestHostCallback，它会在 requestHostCallback 调用前设为 true，workLoop 执行前改为 false
var isHostCallbackScheduled = false;
// 是否有正在执行的 requestHostTimeout，它会在 requestHostTimeout 执行前设为 true，cancenlHostTimeout 和 handleTimeout 中设为 false
var isHostTimeoutScheduled = false;
// message loop 是否正在执行，它会在 schedulePerformWorkUntilDeadline 前设为 true，在任务队列执行完毕后设为 false
let isMessageLoopRunning = false;</p>
<p>// 记录 requestHostCallback 执行时传入的 callback 函数，也就是 flushWork
let scheduledHostCallback = null;
// 用于 cancelHostTimeout 取消 requestHostTimeout
let taskTimeoutID = -1;</p>
<p>// 记录当前正在执行的任务
var currentTask = null;
var currentPriorityLevel = NormalPriority;</p>
<hr>
<p>// 这里是调度的开始
function unstable_scheduleCallback(priorityLevel, callback, options) {
var currentTime = getCurrentTime();</p>
<p>// 任务被安排调度的时间，相当于去银行时的点击排号机器的那个时间
var startTime;
if (typeof options === 'object' &amp;&amp; options !== null) {
var delay = options.delay;
if (typeof delay === 'number' &amp;&amp; delay &gt; 0) {
startTime = currentTime + delay;
} else {
startTime = currentTime;
}
} else {
startTime = currentTime;
}</p>
<p>// 任务不能一直被打断，timeout 表示这个任务的超时时间
var timeout;
switch (priorityLevel) {
case ImmediatePriority:
timeout = IMMEDIATE_PRIORITY_TIMEOUT;
break;
case UserBlockingPriority:
timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
break;
case IdlePriority:
timeout = IDLE_PRIORITY_TIMEOUT;
break;
case LowPriority:
timeout = LOW_PRIORITY_TIMEOUT;
break;
case NormalPriority:
default:
timeout = NORMAL_PRIORITY_TIMEOUT;
break;
}</p>
<hr>
<p>// 任务的过期时间 = 开始调度的时间 + 超时时间
var expirationTime = startTime + timeout;</p>
<p>// 这就是储存在任务队列（taskQueue 和 timerQueue）中的任务对象
var newTask = {
id: taskIdCounter++,
callback,
priorityLevel,
startTime,
expirationTime,
sortIndex: -1,
};</p>
<p>// 如果 startTime &gt; currentTime，说明是延时任务，将其放到 timerQueue
if (startTime &gt; currentTime) {
newTask.sortIndex = startTime;
// 这个 push 是封装的最小堆 push 方法，将元素追加到数组后，它会再进行一个排序，保证最小值在数组的第一个
push(timerQueue, newTask);
// peek(taskQueue) 获取 taskQueue 的第一个任务，因为是最小堆结构，获取的是最紧急的任务
// 这个逻辑是在 taskQueue 为空的情况下才会调用，这是因为 taskQueue 不为空的情况下，它会在每个任务执行的时候都会遍历一下 timerQueue，将到期的任务移到 taskQueue
// newTask === peek(timerQueue) 表示新创建的任务就是最早的要安排调度的延时任务
if (peek(taskQueue) === null &amp;&amp; newTask === peek(timerQueue)) {
// 保证最多只有一个 requestHostTimeout 在执行
if (isHostTimeoutScheduled) {
cancelHostTimeout();
} else {
isHostTimeoutScheduled = true;
}
// requestHostTimeout 本质是一个 setTimeout，时间到后，执行 handleTimeout
requestHostTimeout(handleTimeout, startTime - currentTime);
}
}
// 如果是正常任务，将其放到 taskQueue
else {
newTask.sortIndex = expirationTime;
push(taskQueue, newTask);
// 如果没有正在执行的 requestHostCallback 并且任务队列也没有被执行
if (!isHostCallbackScheduled &amp;&amp; !isPerformingWork) {
isHostCallbackScheduled = true;
requestHostCallback(flushWork);
}
}</p>
<p>return newTask;
}</p>
<hr>
<p>// 你可以把这个函数理解为 requestIdleCallback，都实现了空闲时期执行代码
function requestHostCallback(callback) {
// 将 callback 函数存为全局变量，传入的是 flushWork 这个函数
scheduledHostCallback = callback;
if (!isMessageLoopRunning) {
isMessageLoopRunning = true;
schedulePerformWorkUntilDeadline();
}
}</p>
<p>const channel = new MessageChannel();
const port = channel.port2;
channel.port1.onmessage = performWorkUntilDeadline;
// 借助 Message Channel，让出线程，告诉浏览器登空闲了再执行任务队列
function schedulePerformWorkUntilDeadline() {
port.postMessage(null);
};</p>
<hr>
<p>// 批量任务的开始时间
// React 并不是每一个任务执行完都执行 schedulePerformWorkUntilDeadline 让出线程的，而是执行完一个任务，看看过了多久，如果时间不超过 5ms，那就再执行一个任务，等做完一个任务，发现过了 5ms，这才让出线程，所以 React 是一批一批任务执行的，startTime 记录的是这一批任务的开始时间，而不是单个任务的开始时间。
var startTime = -1;
function performWorkUntilDeadline() {
// scheduledHostCallback 就是 flushWork 这个函数
if (scheduledHostCallback !== null) {
const currentTime = getCurrentTime();
startTime = currentTime;
const hasTimeRemaining = true;
let hasMoreWork = true;
try {
hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
} finally {
if (hasMoreWork) {
// 如果在一个时间切片里没有完成所有任务，那就执行 schedulePerformWorkUntilDeadline，让出线程，等浏览器空闲了再继续执行
schedulePerformWorkUntilDeadline();
} else {
isMessageLoopRunning = false;
scheduledHostCallback = null;
}
}
} else {
isMessageLoopRunning = false;
}
};</p>
<hr>
<p>function flushWork(hasTimeRemaining, initialTime) {
isHostCallbackScheduled = false;
// 定时器的目的表面上是为了保证最早的延时任务准时安排调度，实际上是为了保证 timerQueue 中的任务都能被执行。定时器到期后，我们会执行 advanceTimers 和 flushWork，flushWork 中会执行 workLoop，workLoop 中会将 taskQueue 中的任务不断执行，当 taskQueue 执行完毕后，workLoop 会选择 timerQueue 中的最早的任务重新设置一个定时器。所以如果 flushWork 执行了，定时器也就没有必要了，所以可以取消了。
if (isHostTimeoutScheduled) {
isHostTimeoutScheduled = false;
cancelHostTimeout();
}</p>
<p>isPerformingWork = true;
const previousPriorityLevel = currentPriorityLevel;
try {
return workLoop(hasTimeRemaining, initialTime);
} finally {
currentTask = null;
currentPriorityLevel = previousPriorityLevel;
isPerformingWork = false;
}
}</p>
<hr>
<p>// 遍历 taskQueue，执行任务
function workLoop(hasTimeRemaining, initialTime) {
console.log('workLoop start')
let currentTime = initialTime;
// 检查 timerQueue 中的任务，将到期的任务转到 taskQueue 中
advanceTimers(currentTime);
currentTask = peek(taskQueue);
while (currentTask !== null) {
// 如果任务还没有到过期时间并且 shouldYieldToHost 返回 true
if (currentTask.expirationTime &gt; currentTime &amp;&amp; shouldYieldToHost()) {
break;
}
// 获取任务执行函数
const callback = currentTask.callback;
if (typeof callback === 'function') {
currentTask.callback = null;
currentPriorityLevel = currentTask.priorityLevel;
// 该任务执行的时候是否已经过期
const didUserCallbackTimeout = currentTask.expirationTime &lt;= currentTime;
// 任务函数执行
const continuationCallback = callback(didUserCallbackTimeout);
currentTime = getCurrentTime();
// React 中单个任务在执行的时候，也是可以被打断的，如果单个任务执行的时候被打断，会返回一个函数
// 这个任务被打断了
if (typeof continuationCallback === 'function') {
currentTask.callback = continuationCallback;
}
// 这个任务执行完毕
else {
if (currentTask === peek(taskQueue)) {
pop(taskQueue);
}
}
// 检查任务队列
advanceTimers(currentTime);
}
// 说明任务执行完毕
else {
pop(taskQueue);
}
// 执行下一个任务
currentTask = peek(taskQueue);
}</p>
<p>if (currentTask !== null) {
return true;
} else {
// 如果 taskQueue 空了，timerQueue 中的最先执行的任务还没有到时间，那就执行一个 requestHostTimeout 定时器，保证准时执行
const firstTimer = peek(timerQueue);
if (firstTimer !== null) {
requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
}
return false;
}
}</p>
<hr>
<p>// 检查 timerQueue 中的任务，将到期的任务转到 taskQueue 中
function advanceTimers(currentTime) {
let timer = peek(timerQueue);
while (timer !== null) {
// 任务被取消了
if (timer.callback === null) {
pop(timerQueue);
}
// //任务到期就转到 taskQueue 中
else if (timer.startTime &lt;= currentTime) {
pop(timerQueue);
timer.sortIndex = timer.expirationTime;
push(taskQueue, timer);
} else {
return;
}
timer = peek(timerQueue);
}
}</p>
<hr>
<p>// 默认时间切片为 5ms
let frameInterval = 5;</p>
<p>// 判断是否让出线程，主要看这批任务自开始过了多久，超过了切片时间，就让出线程
function shouldYieldToHost() {
const timeElapsed = getCurrentTime() - startTime;
if (timeElapsed &lt; frameInterval) {
return false;
}</p>
<p>return true;
}</p>
<hr>
<p>function requestHostTimeout(callback, ms) {
taskTimeoutID = setTimeout(() =&gt; {
callback(getCurrentTime());
}, ms);
}</p>
<p>function cancelHostTimeout() {
clearTimeout(taskTimeoutID);
taskTimeoutID = -1;
}</p>
<p>function handleTimeout(currentTime) {
isHostTimeoutScheduled = false;
advanceTimers(currentTime);</p>
<p>if (!isHostCallbackScheduled) {
if (peek(taskQueue) !== null) {
isHostCallbackScheduled = true;
requestHostCallback(flushWork);
}
// 延时任务可能被取消了
else {
const firstTimer = peek(timerQueue);
if (firstTimer !== null) {
requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
}
}
}
}</p>
<h2>源码 ScheduleMinHeap.js</h2>
<pre><code class="language-js">// 源码地址：https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerMinHeap.js

export function push(heap, node) {
  const index = heap.length;
  heap.push(node);

  siftUp(heap, node, index);
}

export function peek(heap) {
  return heap.length === 0 ? null : heap[0];
}

export function pop(heap) {
  if (heap.length === 0) {
    return null;
  }
  const first = heap[0];
  // JavaScript 的 pop 方法删除并返回数组的最后一个元素
  const last = heap.pop();
  if (last !== first) {
    heap[0] = last;
    siftDown(heap, last, 0);
  }
  return first;
}

function siftUp(heap, node, i) {
  let index = i;
  while (index &gt; 0) {
    // 获取父节点的索引位置
    const parentIndex = (index - 1) &gt;&gt;&gt; 1;
    const parent = heap[parentIndex];
    if (compare(parent, node) &gt; 0) {
      // 如果父节点更大，就交换位置
      heap[parentIndex] = node;
      heap[index] = parent;
      index = parentIndex;
    } else {
      // 直到父节点更小，就退出
      return;
    }
  }
}

function siftDown(heap, node, i) {
  let index = i;
  const length = heap.length;
  const halfLength = length &gt;&gt;&gt; 1;
  while (index &lt; halfLength) {
    const leftIndex = (index + 1) * 2 - 1;
    const left = heap[leftIndex];
    const rightIndex = leftIndex + 1;
    const right = heap[rightIndex];
    
    // 如果 left 比 node 小
    if (compare(left, node) &lt; 0) {
      // 如果 right 比 left 还小，说明 right 最小，right 与 node 交换
      if (rightIndex &lt; length &amp;&amp; compare(right, left) &lt; 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      }
      // 说明 left 最小，left 与 node 交换
      else {
        heap[index] = left;
        heap[leftIndex] = node;
        index = leftIndex;
      }
    }
    // 如果 left node 大，但 right 比 node 小，right 与 node 交换
    else if (rightIndex &lt; length &amp;&amp; compare(right, node) &lt; 0) {
      heap[index] = right;
      heap[rightIndex] = node;
      index = rightIndex;
    } else {
      // 子元素都比 node 大
      return;
    }
  }
}

function compare(a, b) {
  // 首先比较 sortIndex，其次是 id
  const diff = a.sortIndex - b.sortIndex;
  return diff !== 0 ? diff : a.id - b.id;
}
</code></pre>
<h2>测试代码</h2>
<pre><code>// 模拟函数的执行
const sleep = delay =&gt; {
  for (let start = Date.now(); Date.now() - start &lt;= delay;) {}
}

unstable_scheduleCallback(3, () =&gt; {console.log(1)})

unstable_scheduleCallback(3, () =&gt; {
  console.log(2)
  sleep(10)
}, {
  delay: 10
})

unstable_scheduleCallback(3, () =&gt; {console.log(3)}, {
  delay: 10
})

unstable_scheduleCallback(3, () =&gt; {
  console.log(4)
  sleep(10)
})

unstable_scheduleCallback(3, () =&gt; {console.log(5)})
</code></pre>
<p>它的执行结果如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a04414af9954279bbd1e2e6a41b72c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<h1> </h1>
<h1>React Scheduler 原理及手写源码</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7140642609806082061">juejin.cn</a></p>
</blockquote>
<h2>学习目标</h2>
<ul>
<li>同步更新 &amp; 异步更新</li>
<li>为啥采用 MessageChannel 而不是 setTimeout 等 api 实现异步任务调度</li>
<li>任务切片</li>
<li>时间切片</li>
</ul>
<h2>同步更新页面</h2>
<p>老板说了，他有一组任务，点击按钮的时候，需要遍历执行完这组任务，统计全部任务执行完成的耗时，然后更新到页面。每个任务执行耗时差不多 2ms，如下：</p>
<pre><code>let works = [];
for (let i = 0; i &lt; 3000; i++) {
  works.push(() =&gt; {
    const start = new Date().getTime();
    while (new Date().getTime() - start &lt; 2) {}
  });
}
</code></pre>
<p>小李看了看，老板的需求总是这么简单，不到 2 秒，小李已经实现了如下：</p>
<pre><code>btn.onclick = () =&gt; {
  const startTime = new Date().getTime();
  flushWork();
  const endTime = new Date().getTime();
  animate.innerHTML = endTime - startTime;
};

function flushWork() {
  works.forEach((w) =&gt; w());
}
</code></pre>
<hr>
<p>点了下按钮。结果，过了差不多 6 秒页面才更新，同时页面卡死，再次点击按钮都点不了。
因为这组任务是同步执行的，所有任务执行完成，总共耗时差不多 6 秒，而在这个过程中，js 引擎一直占用着控制权，浏览器无法绘制页面，也无法响应用户，用户体验相当不好
所以，这组耗时长的任务不应该同步执行</p>
<h2>使用 setTimeout 异步更新页面</h2>
<p>为了不长时间占用主线程，阻塞浏览器渲染，小李将任务拆分到定时器执行，每个定时器执行一个任务。
每执行一次都判断 works 是否全部执行完成，如果全部执行完成，则更新页面。
每执行完一次任务，都主动将控制权让出给浏览器。</p>
<pre><code>btn.onclick = () =&gt; {
  startTime = new Date().getTime();
  flushWork();
};

function flushWork() {
  setTimeout(workLoop, 0);
}

function workLoop() {
  const work = works.shift();
  if (work) {
    work();
    setTimeout(workLoop, 0);
  } else {
    const endTime = new Date().getTime();
    animate.innerHTML = endTime - startTime;
  }
}
</code></pre>
<p>点击按钮，这次页面动画终于不卡顿了，然而等了差不多 19 秒的时间，页面才更新。</p>
<hr>
<p>为啥这次执行耗时 19266 毫秒，远比之前多出了 13266 毫秒？
小李看了下 Performance。
虽然使用了<code>setTimeout(workLoop, 0)</code>0 毫秒的时间间隔，但是浏览器依然会有 4 到 5 毫秒的间隔时间。如果两次 setTimeout 之间最少间隔 4 毫秒，都有至少 3000 * 4 = 12000 毫秒的耗时了。
显然，setTimeout 由于 4 毫秒间隔的原因，不适用于我们的场景。</p>
<hr>
<p>不使用 Promise 或者 MutationObserver 等微任务 API 的原因是，微任务是在页面更新前全部执行完成的，效果和同步执行任务差不多。</p>
<h2>使用 MessageChannel 异步更新页面</h2>
<p>使用 <code>MessageChannel</code> 触发一个宏任务，在宏任务事件中执行工作。
每执行完一个工作，判断是否已经执行完全部的工作，如果是，则更新页面，否则调用<code>port.postMessage(null)</code>触发下一个宏任务，继续执行剩余的工作。</p>
<pre><code>var channel = new MessageChannel();
var port = channel.port2;
channel.port1.onmessage = workLoop;

let startTime;
btn.onclick = () =&gt; {
  startTime = new Date().getTime();
  port.postMessage(null);
};

function workLoop() {
  const work = works.shift();
  if (work) {
    work();
    port.postMessage(null);
  } else {
    const endTime = new Date().getTime();
    animate.innerHTML = endTime - startTime;
  }
}
</code></pre>
<p>自测了下，发现耗时只用了 6090 毫秒！
为什么会多出了 90 毫秒？观察 performance 可以看出，虽然两次宏任务之间间隔非常短，但也会导致额外的开销，累积起来就有了几毫秒的差异。不过，这已经很贴近 6000 毫秒的执行耗时了，优势远胜于 setTimeout</p>
<h3>MessageChannel问题分析</h3>
<p>这次，小李能够同时兼顾页面动画流畅、不卡顿以及快速响应用户输入，尽早更新页面。
但是还有一点小瑕疵，由于两次任务之间还是会有一点点的时间间隔，执行数量众多的任务时，这些间隔的时间就会累加起来，就会有几毫秒的额外开销。</p>
<h2>任务切片：一次宏任务事件尽可能执行更多的任务</h2>
<p>在上一节中，额外消耗的时间等于两次宏任务之间的时间间隔 * 工作的数量：
显然，我们无法控制两次宏任务之间的时间间隔，但是我们可以减少触发宏任务事件的次数。
可以通过在一次宏任务事件中执行更多的任务来达到这个目的。
同时，一次宏任务事件的执行耗时又不能超过 1 帧的时间 (16.6ms)，毕竟我们需要留点时间给浏览器绘制页面
为了达到这个目的，小李将任务拆分成几小段执行，即<strong>任务切片</strong>。</p>
<hr>
<p>既然一帧 16.6 毫秒，执行一次任务需要 2 毫秒，那只需要在一次宏任务事件中执行 7 个任务就好，这样浏览器还有 2.6 毫秒绘制页面。</p>
<pre><code>var channel = new MessageChannel();
var port = channel.port2;
channel.port1.onmessage = workLoop;

let startTime;
btn.onclick = () =&gt; {
  startTime = new Date().getTime();
  port.postMessage(null);
};
function workLoop() {
  let i = 0;
  while (i &lt; 7) {
    let work = works.shift();
    if (work) {
      work();
      i++;
    } else {
      const endTime = new Date().getTime();
      animate.innerHTML = endTime - startTime;
      i = 7; // 没有剩余工作就直接退出循环
    }
  }
  if (works.length) {
    port.postMessage(null);
  }
}
</code></pre>
<h3>任务切片问题分析</h3>
<h2>采用任务切片的方法极大减少了触发 message channel 的次数，减少了宏任务之间调度的额外消耗。
但任务切片的一个前提是，每个任务执行耗时是确定的，比如这里是 2 毫秒，但真实的业务场景是无法知道任务的执行耗时的
我们来探讨一种时间切片的方式
时间切片</h2>
<p>我们知道浏览器一帧只有 16.6ms，同时我们的工作执行耗时又不是确定的。
那我们可以，将一次宏任务的执行时间尽可能的控制在一定的时间内，比如 5ms。
每完成一个工作任务，都判断执行时间是否超出了 5 毫秒，如果超出了 5 毫秒，则不继续执行下一个工作任务，结束本轮宏任务事件，<strong>主动让出控制权</strong>给浏览器绘制页面。
如果没有超过 5 毫秒，则继续执行下一个工作任务。</p>
<hr>
<p>时间切片实现如下：</p>
<pre><code>let works = [];
for (let i = 0; i &lt; 3000; i++) {
  works.push(() =&gt; {
    const start = new Date().getTime();
    while (new Date().getTime() - start &lt; 2) {}
  });
}
const btn = document.getElementById(&quot;btn&quot;);
const animate = document.getElementById(&quot;animation&quot;);

var channel = new MessageChannel();
var port = channel.port2;
channel.port1.onmessage = workLoop;

let endTime;
let startTime;
btn.onclick = () =&gt; {
  startTime = new Date().getTime();
  port.postMessage(null);
};
const yieldInterval = 5; // 单位毫秒
function workLoop() {
  const currentEventStartTime = new Date().getTime();
  let work = works.shift();
  while (work) {
    work();
    // 执行完当前工作，则判断时间是否超过5ms，如果超过，则退出while循环
    if (new Date().getTime() - currentEventStartTime &gt; yieldInterval) {
      // 执行耗时超过了5ms，结束本轮事件，主动让出控制权给浏览器绘制页面或者执行其他操作
      break;
    }
    work = works.shift();
  }
  // 如果还有剩余的工作，则放到下一个事件中处理
  if (works.length) {
    port.postMessage(null);
  } else {
    const endTime = new Date().getTime();
    animate.innerHTML = endTime - startTime;
  }
}
</code></pre>
<h2>小结</h2>
<p>到目前为止，效果还是很不错的。小李收获了以下知识：</p>
<ul>
<li>耗时长的同步任务会长时间占用浏览器导致无法响应用户输入，页面卡顿等问题</li>
<li>setTimeout 由于有至少 4 毫秒的延迟，因此不适合用于异步任务的调度</li>
<li>MessageChannel 在一帧的时间内调用频率超高，两次 message channel 宏任务事件之间的间隔开销极少，适合用于异步任务的调度。</li>
<li>由于无法提前得知任务执行时间，从而无法计算一帧之内应该执行几个任务，所以任务切片不太适用于一帧内调度异步任务。</li>
<li>时间切片是比较理想的选择</li>
</ul>
<h2>开源第一步</h2>
<p>小李决定将这个小工具开源</p>
<hr>
<ol>
<li>将 Message Channel 抽成一个公用的调度方法</li>
</ol>
<p>通过 requestHostCallback 触发一个 message channel 事件，
同时在 performWorkUntilDeadline 接收事件</p>
<p>如果 scheduledHostCallback 返回 true，说明还有剩余的工作没完成，则调度下一个宏任务事件执行剩余的工作。</p>
<pre><code>const yieldInterval = 5;
let deadline = 0;
const channel = new MessageChannel();
let port = channel.port2;
channel.port1.onmessage = performWorkUntilDeadline;
function performWorkUntilDeadline() {
  if (scheduledHostCallback) {
    // 当前宏任务事件开始执行
    let currentTime = new Date().getTime();
    // 计算当前宏任务事件结束时间
    deadline = currentTime + yieldInterval;
    const hasMoreWork = scheduledHostCallback(currentTime);
    if (!hasMoreWork) {
      scheduledHostCallback = null;
    } else {
      // 如果还有工作，则触发下一个宏任务事件
      port.postMessage(null);
    }
  }
}
function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  port.postMessage(null);
}
</code></pre>
<hr>
<p>这里需要注意，我们必须在 performWorkUntilDeadline (用来接受事件)开始时获取到当前的时间 currentTime，然后计算出本次事件执行的截止时间，performWorkUntilDeadline 的执行时间控制在 5 毫秒内，因此截止时间就是 deadline = currentTime + yieldInterval;</p>
<hr>
<ol start="2">
<li>我们需要一个 scheduleCallback 方法给用户添加任务，
我们将用户添加的任务保存在 taskQueue 中。然后触发一个 message channel 事件，异步执行任务。</li>
</ol>
<pre><code>let taskQueue = [];
let isHostCallbackSchedule = false;
function scheduleCallback(callback) {
  var newTask = {
    callback: callback,
  };
  taskQueue.push(newTask);
  if (!isHostCallbackScheduled) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
  return newTask;
}
</code></pre>
<hr>
<ol start="3">
<li>最后需要实现 flushwork 方法，在 workLoop 方法中，每执行一个工作，都需要判断当前 performWorkUntilDeadline 事件执行时间是否超过 5ms</li>
</ol>
<pre><code>let currentTask = null;
function flushWork(initialTime) {
  return workLoop(initialTime);
}

function workLoop(initialTime) {
  currentTask = taskQueue[0];

  while (currentTask) {
    if (new Date().getTime() &gt;= deadline) {
      // 每执行一个任务，都需要判断当前的performWorkUntilDeadline执行时间是否超过了截止时间
      break;
    }
    var callback = currentTask.callback;
    callback();

    taskQueue.shift();
    currentTask = taskQueue[0];
  }
  if (currentTask) {
    // 如果taskQueue中还有剩余工作，则返回true
    return true;
  } else {
    return false;
  }
}
</code></pre>
<hr>
<p>schedule 实现的使用</p>
<pre><code>const btn = document.getElementById(&quot;btn&quot;);
const animate = document.getElementById(&quot;animation&quot;);
let startTime;
btn.onclick = () =&gt; {
  startTime = new Date().getTime();
  for (let i = 0; i &lt; 3000; i++) {
    if (i === 2999) {
      scheduleCallback(() =&gt; {
        const start = new Date().getTime();
        while (new Date().getTime() - start &lt; 2) {}
        const endTime = new Date().getTime();
        animate.innerHTML = endTime - startTime;
      });
    } else {
      scheduleCallback(() =&gt; {
        const start = new Date().getTime();
        while (new Date().getTime() - start &lt; 2) {}
      });
    }
  }
};
</code></pre>
<p>以上就是 schedule 的简单实现。下一篇文章会继续实现优先级、延迟任务。</p>
<h1> </h1>
<h1>React 之 Scheduler 源码中的三个小知识点，看看你知不知道？</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7171633315336683528">juejin.cn</a></p>
</blockquote>
<h2>getCurrentTime</h2>
<p>Scheduler 中有一个 getCurrentTime 函数，它的具体实现如下：</p>
<ul>
<li>判断performance可以使用</li>
<li>不能用使用 date来获得时间</li>
</ul>
<h2>判断performance可以使用</h2>
<h2>const hasPerformanceNow =
typeof performance === 'object' &amp;&amp; typeof performance.now === 'function';
获得时间</h2>
<p>let getCurrentTime;
if (hasPerformanceNow) {
const localPerformance = performance;
getCurrentTime = () =&gt; localPerformance.now();
} else {
const localDate = Date;
const initialTime = localDate.now();
getCurrentTime = () =&gt; localDate.now() - initialTime;
}</p>
<p>虽然函数名为获取当前时间，但根据实现，可以看出，获取的其实是从性能测量时刻开始的毫秒数
如果环境支持 performance.now，那就直接使用 performance.now，我们看下 performance.now</p>
<h3>performance.now</h3>
<p>performance.now返回值表示为从 time origin 之后到当前调用时经过的时间,简单的来说，performance.now 会返回自页面创建过了多久。
time origin 译为 “时间源”, 时间源是一个可以被认定为当前文档生命周期的开始节点的标准时间，</p>
<hr>
<p>origin的计算方法如下：</p>
<ul>
<li>如果脚本的 global object 是 Window, 则时间源的确定方式如下：
<ul>
<li>如果当前 Document 是中加载的第一个 Window, 则时间源是创建浏览器上下文的时间。</li>
<li>如果处于卸载窗口中已加载的先前文档的过程中， 一个确认对话框会显示出来，让用户确认是否离开前一页，则时间源是用户确认导航到新页面的这个时间，这一点是被认同的。</li>
<li>如果以上方式都不能确定时间源, 那么时间源是创建窗口中当前 Document 的导航发生的时机。</li>
</ul>
</li>
<li>如果脚本中的全局对象是 WorkerGlobalScope (意味着，该脚本以 web worker 的形式运行), 则时间源是这个 worker 被创建的时刻。</li>
<li>在所有其他情况下，时间源的值是 undefined。</li>
</ul>
<h3>Date.now</h3>
<p>而 Date.now 返回的是自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数。</p>
<h3>performance.now VS Date.now</h3>
<ol>
<li>performance.now 精度更高，以浮点数表示时间，精度最高可达微秒级（1 毫秒 = 1000 微秒），Date.now 则为毫秒级</li>
<li>performance.now() 以一个恒定的速率慢慢增加的，它不会受到系统时间的影响（系统时钟可能会被手动调整或被 NTP 等软件篡改）</li>
<li>performance.now 是浏览器提供的方法，Date.now 是 JavaScript 内置的方法</li>
<li>performance.timing.navigationStart + performance.now() 约等于 Date.now()</li>
</ol>
<h2>maxSigned31BitInt</h2>
<p>在 <code>unstable_scheduleCallback</code> 函数中，当根据优先级计算 timeout 时间时，如果是 <code>IdlePriority</code>，对应的 timeout 时间为 <code>IDLE_PRIORITY_TIMEOUT</code>，值为 1073741823，这个数值是怎么算出来的呢？</p>
<pre><code>// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var maxSigned31BitInt = 1073741823;
// Never times out
var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;

</code></pre>
<p>根据注释可以看出，maxSigned31BitInt 表示 32 位系统下 V8 最大的整数，它是最大的 31 位整数，它的二进制为 <code>0b111111111111111111111111111111</code>，这其中 <code>0b</code>表示这是一个二进制数字，后面跟了一共 30 个 <code>1</code>，所以这个值是 2 的 30 次方 - 1，也就是 1073741823，这个时间大概是 12.4 天</p>
<h2>Smis</h2>
<p>既然是 32 位，一位用于符号位，那还有 31 位呀，为什么是 2 的 30 次方而不是 2 的 31 次方呢？</p>
<p>这就要说到<code>Smis</code>，在 ECMAScript 标准中，数字会被当成 64 位双精度浮点数处理，但是一直使用 64 位存储数字是十分低效的，就比如数组索引，在<a href="https://link.juejin.cn?target=https%3A%2F%2Ftc39.es%2Fecma262%2F%23array-index" title="https://tc39.es/ecma262/#array-index">规范</a>中，它的最大值是 2³²-2，没有必要非要使用 64 位储存，所以像 V8 就建立了一个名为 <code>Smis</code> 的特殊整数表示方式。</p>
<p>它其实是 <code>Small Integer</code>的缩写，翻译过来就是小整数，它的特殊地方在于它会使用最低有效位（least significant bits）标记这个值是否是 <code>Smis</code>： <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/317e39c4ace34267af97ae52a32a89e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""> 所以在 32 位平台上，就只有 31 位用来储存 <code>Smi</code>值。</p>
<h2>isInputPending</h2>
<p>在 shouldYieldToHost 的源码中，其实还涉及了一个 Scheduling API —— isInputPending，它是 facebook 的开发者提出的</p>
<p>它是一个函数，作用是检测是否有等待中的用户输入事件，使用语法为：</p>
<pre><code>if (navigator.scheduling.isInputPending()){
  // ...
}
</code></pre>
<h2>当这个函数执行的时候，如果浏览器有需要处理的输入事件，isInputPending() 就会返回 true。
isInputPending()优化</h2>
<p>React 辛辛苦苦实现 Fiber 结构，其目的就在于能够及时让出线程，让浏览器可以处理用户输入或者动画等，借助 isInputPending() 这个 API，我们可以快速判断出执行期间是否有用户输入，从而做出处理，保证及时响应用户输入。</p>
<p>通过合理使用 isInputPending 方法，我们可以在页面渲染时及时响应用户输入，并且，当有长耗时的 JS 任务要执行时，可以通过 isInputPending 来中断 JS 的执行，将控制权交还给浏览器来执行用户响应。</p>
<h2>isInputPending()使用实例</h2>
<pre><code>let taskQueue = [task1, task2, ...];
const options = {includeContinuous: true};

function doWork() {
  while (let task = taskQueue.pop()) {
    task.execute();
    if (navigator.scheduling.isInputPending(options)) {
      setTimeout(doWork, 0);
      break;
    }
  }
}

doWork();
</code></pre>
<p>在这个例子中，我们传入了一个 <code>{includeContinuous: true}</code>对象，这是因为在默认情况下，isInputPending 并不会检测连续事件，就比如 <code>mousemove</code>、<code>pointermove</code>等，设置为 true 后，也会开启检测这些事件。</p>
<p>但目前它的兼容性还不好，Chrome 也只有 87 版本以上才支持：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e4175b78faa4e5cb88cf16a7b807018~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p>所以 React 源码中也没有正式开启使用这个 API：</p>
<pre><code>const continuousYieldMs = 50;
const continuousInputInterval = continuousYieldMs;

const maxYieldMs = 300;
const maxInterval = maxYieldMs;

const isInputPending =
  typeof navigator !== 'undefined' &amp;&amp;
  navigator.scheduling !== undefined &amp;&amp;
  navigator.scheduling.isInputPending !== undefined
    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)
    : null;

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  if (timeElapsed &lt; frameInterval) {
    return false;
  }

  // enableIsInputPending 默认 false
  if (enableIsInputPending) {
    // ...
    if (timeElapsed &lt; continuousInputInterval) {
      if (isInputPending !== null) {
        return isInputPending();
      }
    } else if (timeElapsed &lt; maxInterval) {
      if (isInputPending !== null) {
        return isInputPending(continuousOptions);
      }
    } else {
      return true;
    }
  }
  return true;
}
</code></pre>
<h1> </h1>
<h1>React 之最小堆（min heap）</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7168283003037155359">juejin.cn</a></p>
</blockquote>
<h2>React 采用原因</h2>
<p>React 的任务列表（taskQueue）用的就是最小堆。
React 为什么采用最小堆结构呢？
React 将更新任务拆成多个小任务，每个小任务的数据结构是一个带着 expirationTime 的对象，expirationTime 表示这个任务的过期时间，expirationTime 越小就表示过期时间越近，该任务的优先级就越高，取出最小值就相当于取出优先级最高的任务。</p>
<h2>插入过程（push）</h2>
<h2>二叉堆的插入过程：
当插入一个新节点的时候，我们会在二叉堆的最后添加，然后将其 “上浮” 到正确位置。举个例子：
&gt;&gt;&gt; 1</h2>
<pre><code>const parentIndex = (index - 1) &gt;&gt;&gt; 1;
</code></pre>
<p>这是用来获取父节点的索引值的。
&gt;&gt;1 是有符号右移位操作符
&gt;&gt;&gt; 11 是无符号右移位操作符</p>
<h2>删除过程（pop）</h2>
<p>现在我们来看删除过程，因为我们删除的是根节点，它的具体流程是：</p>
<ol>
<li>取出最后一个节点，替换掉根节点</li>
<li>将节点 “下沉” 到正确位置</li>
</ol>
<h2>halfLength</h2>
<p>siftDown 的实现中，我认为最有意思是在 <code>halfLength</code> 这里：</p>
<pre><code>const length = heap.length;
  const halfLength = length &gt;&gt;&gt; 1;
  while (index &lt; halfLength) {//...}

</code></pre>
<p>那为什么只用比较一半就可以了呢？如果我们尝试自己去画几个最小堆，发现也确实如此，完全不用全部比较一遍。
我们可以这样想： 假设父节点的 index 为 x，那么左子节点的 index 为 2x + 1，右子节点的 index 为 2x + 2，每一次 shiftDown，index 的最大变化就是 2x + 2，而 2x + 2 最大只能等于 length - 1，那么：</p>
<pre><code>因为 2x + 2 &lt;= length - 1 
所以 x &lt;= length/2 - 1.5

我们知道 y &gt;&gt;&gt; 1 ，在 y 为正数的情况下，计算的结果为 y/2 - 0.5 或者 y/2

如果 x &lt;= length/2 - 1.5
那么肯定 x &lt; length/2 - 0.5 以及 x &lt; length/2
所以肯定 x &lt; length &gt;&gt;&gt; 1

</code></pre>
<h1> </h1>
<h1>「react 进阶」一文吃透 react-hooks 原理</h1><h1>一 前言</h1>
<p><code>react-hooks</code>就是函数组件<strong>解决没有<code>state</code>，生命周期，逻辑不能复用</strong>的一种技术方案。
Hook 是 React 16.8 的添加特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<h2>带着疑问</h2>
<ul>
<li>1 在无状态组件每一次函数上下文执行的时候，<code>react</code>用什么方式记录了<code>hooks</code>的状态？</li>
<li>2 多个<code>react-hooks</code>用什么来记录每一个<code>hooks</code>的顺序的 ？ 为什么不能条件语句中，声明<code>hooks</code>? <code>hooks</code>声明为什么在组件的最顶部？</li>
<li>3 <code>function</code>函数组件中的<code>useState</code>，和 <code>class</code>类组件 <code>setState</code>有什么区别？</li>
<li>4 <code>react</code> 是怎么捕获到<code>hooks</code>的执行上下文，是在函数组件内部的？</li>
<li>5 <code>useEffect</code>,<code>useMemo</code> 中，为什么<code>useRef</code>不需要依赖注入，就能访问到最新的改变值？</li>
<li>6 <code>useMemo</code>是怎么对值做缓存的？如何应用它优化性能？</li>
<li>7 为什么两次传入<code>useState</code>的值相同，函数组件不更新?</li>
</ul>
<h2>function 组件和 class 组件本质的区别</h2>
<p><strong>函数组件和类组件到底有什么区别</strong>，废话不多说，我们先看 两个代码片段。</p>
<pre><code>class Index extends React.Component&lt;any,any&gt;{
    constructor(props){
        super(props)
        this.state={
            number:0
        }
    }
    handerClick=()=&gt;{
       for(let i = 0 ;i&lt;5;i++){
           setTimeout(()=&gt;{
               this.setState({ number:this.state.number+1 })
               console.log(this.state.number)
           },1000)
       }
    }

    render(){
        return &lt;div&gt;
            &lt;button onClick={ this.handerClick } &gt;num++&lt;/button&gt;
        &lt;/div&gt;
    }
}
</code></pre>
<p>打印结果： 1 2 3 4 5
类组件中，由于执行上<code>setState</code>没有在<code>react</code>正常的函数执行上下文上执行，而是<code>setTimeout</code>中执行的，<strong>批量更新</strong>条件被破坏。 所以可以直接获取到变化后的<code>state</code>。</p>
<hr>
<p>函数组件中：</p>
<pre><code>function Index(){
    const [ num ,setNumber ] = React.useState(0)
    const handerClick=()=&gt;{
        for(let i=0; i&lt;5;i++ ){
           setTimeout(() =&gt; {
                setNumber(num+1)
                console.log(num)
           }, 1000)
        }
    }
    return &lt;button onClick={ handerClick } &gt;{ num }&lt;/button&gt;
}
</code></pre>
<p>在第二个例子🌰打印结果： 0 0 0 0 0
在<code>class</code>状态中，通过一个实例化的<code>class</code>，去维护组件中的各种状态；
但是在<code>function</code>组件中，没有一个状态去保存这些信息，每一次函数上下文执行，所有变量，常量都重新声明，执行完毕，再被垃圾机制回收。
所以如上，无论<code>setTimeout</code>执行多少次，都是在当前函数上下文执行, 此时<code>num = 0</code>不会变，之后<code>setNumber</code>执行，函数组件重新执行之后，<code>num</code>才变化。</p>
<hr>
<p>所以， 对于<code>class</code>组件，我们只需要实例化一次，实例中保存了组件的<code>state</code>等状态。对于每一次更新只需要调用<code>render</code>方法就可以。
但是在<code>function</code>组件中，每一次更新都是一次新的函数执行,
为了保存一些状态, 执行一些副作用钩子,<code>react-hooks</code>应运而生，去帮助记录组件的状态，处理一些额外的副作用。</p>
<h2>1 当我们引入 hooks 时候发生了什么？</h2>
<p><code>useState</code>在文件 <code>react/src/ReactHooks.js</code>中</p>
<pre><code>export function useState(initialState){
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
</code></pre>
<p><code>useState()</code> 的执行等于 <code>dispatcher.useState(initialState)</code> 这里面引入了一个<code>dispatcher</code>，
dispatcher由resolveDispather获得, 我们看一下<code>resolveDispatcher</code>做了些什么？</p>
<hr>
<p><strong>resolveDispatcher</strong></p>
<pre><code>function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current
  return dispatcher
}
</code></pre>
<pre><code>const ReactCurrentDispatcher = {
  current: null,
};
</code></pre>
<p>我们看到<code>ReactCurrentDispatcher.current</code>初始化的时候为<code>null</code>，然后就没任何下文了。我们暂且只能把 <strong><code>ReactCurrentDispatcher</code></strong> 记下来。看看<code>ReactCurrentDispatcher</code>什么时候用到的 ？</p>
<p>最后以一个<code>ReactCurrentDispatcher</code>草草收尾，线索全部断了，所以接下来我们只能从函数组件执行开始。</p>
<h3>renderWithHooks 执行函数</h3>
<p>对于<code>function</code>组件是什么时候执行的呢？<code>react-reconciler/src/ReactFiberBeginWork.js</code></p>
<p><code>function</code>组件初始化：</p>
<pre><code>renderWithHooks(
    null,                // current Fiber
    workInProgress,      // workInProgress Fiber
    Component,           // 函数组件本身
    props,               // props
    context,             // 上下文
    renderExpirationTime,// 渲染 ExpirationTime
);
</code></pre>
<hr>
<p><code>function</code>组件更新：
对于初始化是没有<code>current</code>树的，之后完成一次组件更新后，会把当前<code>workInProgress</code>树赋值给<code>current</code>树。</p>
<pre><code>renderWithHooks(
    current,
    workInProgress,
    render,
    nextProps,
    context,
    renderExpirationTime,
);
</code></pre>
<hr>
<p><code>renderWithHooks</code>函数作用是<strong>调用<code>function</code>组件函数</strong>的主要函数。他负责<code>function</code>组件初始化和更新
我们重点看看<code>renderWithHooks</code>做了些什么？</p>
<hr>
<p><strong>renderWithHooks</strong> <code>react-reconciler/src/ReactFiberHooks.js</code></p>
<pre><code>export function renderWithHooks(
  current,
  workInProgress,
  Component,
  props,
  secondArg,
  nextRenderExpirationTime,
) {
  renderExpirationTime = nextRenderExpirationTime;
  currentlyRenderingFiber = workInProgress;

  workInProgress.memoizedState = null;
  workInProgress.updateQueue = null;
  workInProgress.expirationTime = NoWork;

  ReactCurrentDispatcher.current =
      current === null || current.memoizedState === null
        ? HooksDispatcherOnMount
        : HooksDispatcherOnUpdate;

  let children = Component(props, secondArg);

  if (workInProgress.expirationTime === renderExpirationTime) { 
       // ....这里的逻辑我们先放一放
  }

  ReactCurrentDispatcher.current = ContextOnlyDispatcher;

  renderExpirationTime = NoWork;
  currentlyRenderingFiber = null;

  currentHook = null
  workInProgressHook = null;

  didScheduleRenderPhaseUpdate = false;

  return children;
}
</code></pre>
<p><strong>所有的函数组件执行，都是在这里方法中</strong>,
<strong><code>renderWithHooks</code>函数主要作用:</strong></p>
<ol>
<li>首先先置空即将调和渲染的<code>workInProgress</code>树的<code>memoizedState</code>和<code>updateQueue</code>，</li>
<li>根据当前函数组件是否是第一次渲染，赋予<code>ReactCurrentDispatcher.current</code>不同的<code>hooks</code></li>
<li>调用<code>Component(props, secondArg);</code>执行我们的函数组件</li>
<li>将<code>ContextOnlyDispatcher</code>赋值给 <code>ReactCurrentDispatcher.current</code></li>
<li>最后重新置空一些变量比如<code>currentHook</code>，<code>currentlyRenderingFiber</code>,<code>workInProgressHook</code>等</li>
</ol>
<hr>
<h2><img src="./Pasted image 20230815133430.png" /></h2>
<ol>
<li>首先先置空即将调和渲染的<code>workInProgress</code>树的<code>memoizedState</code>和<code>updateQueue</code>，
为什么这么做，
<ul>
<li>因为在接下来的函数组件执行过程中，要把新的<code>hooks</code>信息挂载到这两个属性上，然后在组件<code>commit</code>阶段，将<code>workInProgress</code>树替换成<code>current</code>树，替换真实的<code>DOM</code>元素节点。并在<code>current</code>树保存<code>hooks</code>信息。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>然后根据当前函数组件是否是第一次渲染，赋予<code>ReactCurrentDispatcher.current</code>不同的<code>hooks</code>
<ul>
<li>如果<code>current</code>不存在，证明是第一次渲染函数组件。通过<code>current</code>树上是否<code>memoizedState</code>（hook 信息）来判断不同的 hooks</li>
<li>对于第一次渲染组件，那么用的是<code>HooksDispatcherOnMount</code> hooks 对象。</li>
<li>对于渲染后，需要更新的函数组件，则是<code>HooksDispatcherOnUpdate</code>对象</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>调用<code>Component(props, secondArg);</code>执行我们的函数组件
我们的函数组件在这里真正的被执行了，然后，我们写的<code>hooks</code>被依次执行，把<code>hooks</code>信息依次保存到<code>workInProgress</code>树上。
至于它是怎么保存的，我们马上会讲到。</li>
</ol>
<hr>
<ol>
<li>将<code>ContextOnlyDispatcher</code>赋值给 <code>ReactCurrentDispatcher.current</code>，
由于<code>js</code>是单线程的，也就是说我们没有在函数组件中，调用的<code>hooks</code>，都是<code>ContextOnlyDispatcher</code>对象上<code>hooks</code>,</li>
</ol>
<hr>
<p>首先我们应该明白几个感念，这对于后续我们理解<code>useState</code>是很有帮助的。
<code>current fiber树</code>: 当完成一次渲染之后，会产生一个<code>current</code>树,<code>current</code>会在<code>commit</code>阶段替换成真实的<code>Dom</code>树。
<code>workInProgress fiber树</code>: 即将调和渲染的 <code>fiber</code> 树。再一次新的组件更新过程中，会从<code>current</code>复制一份作为<code>workInProgress</code>, 更新完毕后，将当前的<code>workInProgress</code>树赋值给<code>current</code>树。</p>
<p><code>workInProgress.memoizedState</code>: 在<code>class</code>组件中，<code>memoizedState</code>存放<code>state</code>信息，在<code>function</code>组件中，<strong>这里可以提前透漏一下，<code>memoizedState</code>在一次调和渲染过程中，以链表的形式存放<code>hooks</code>信息。</strong>
<code>workInProgress.expirationTime</code>: <code>react</code>用不同的<code>expirationTime</code>, 来确定更新的优先级。
<code>currentHook</code> : 可以理解 <code>current</code>树上的指向的当前调度的 <code>hooks</code>节点。
<code>workInProgressHook</code> : 可以理解 <code>workInProgress</code>树上指向的当前调度的 <code>hooks</code>节点。</p>
<hr>
<p>我们看看<code>ContextOnlyDispatcher</code>hooks，到底是什么。</p>
<pre><code>const ContextOnlyDispatcher = {
    useState:throwInvalidHookError
}
function throwInvalidHookError() {
  invariant(
    false,
    'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' +
      ' one of the following reasons:\n' +
      '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' +
      '2. You might be breaking the Rules of Hooks\n' +
      '3. You might have more than one copy of React in the same app\n' +
      'See https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.',
  );
}
</code></pre>
<p>原来如此，<code>react-hooks</code>就是通过这种函数组件执行赋值不同的<code>hooks</code>对象方式，
判断在<code>hooks</code>执行是否在函数组件内部，捕获并抛出异常的。</p>
<h2>3 不同的<code>hooks</code>对象</h2>
<p>函数第一次渲染组件和更新组件分别调用不同的<code>hooks</code>对象，我们现在就来看看<code>HooksDispatcherOnMount</code> 和 <code>HooksDispatcherOnUpdate</code>。</p>
<hr>
<p>HooksDispatcherOnMount <strong>第一次渲染 (我这里只展示了常用的<code>hooks</code>)：</strong></p>
<pre><code>const HooksDispatcherOnMount = {
  useCallback: mountCallback,
  useEffect: mountEffect,
  useLayoutEffect: mountLayoutEffect,
  useMemo: mountMemo,
  useReducer: mountReducer,
  useRef: mountRef,
  useState: mountState,
};
</code></pre>
<hr>
<p>HooksDispatcherOnUpdate <strong>更新组件：</strong></p>
<pre><code>const HooksDispatcherOnUpdate = {
  useCallback: updateCallback,
  useEffect: updateEffect,
  useLayoutEffect: updateLayoutEffect,
  useMemo: updateMemo,
  useReducer: updateReducer,
  useRef: updateRef,
  useState: updateState
};
</code></pre>
<h1>三 hooks 初始化，我们写的 hooks 会变成什么样子</h1>
<p>本文将重点围绕四个重点<code>hooks</code>展开，分别是
负责组件更新的<code>useState</code>，负责执行副作用<code>useEffect</code> ,
负责保存数据的<code>useRef</code>, 负责缓存优化的<code>useMemo</code>，
至于<code>useCallback</code>,<code>useReducer</code>,<code>useLayoutEffect</code>原理和那四个重点<code>hooks</code>比较相近，就不一一解释了。</p>
<hr>
<p>我们先写一个组件，并且用到上述四个主要<code>hooks</code>：
<strong>请记住如下代码片段，后面讲解将以如下代码段展开</strong></p>
<pre><code class="language-js">import React , { useEffect , useState , useRef , useMemo  } from 'react'
function Index(){
    const [ number , setNumber ] = useState(0)
    const DivDemo = useMemo(() =&gt; &lt;div&gt; hello , i am useMemo &lt;/div&gt;,[])
    const curRef  = useRef(null)
    useEffect(()=&gt;{
       console.log(curRef.current)
    },[])
    return &lt;div ref={ curRef } &gt;
        hello,world { number } 
        { DivDemo }
        &lt;button onClick={() =&gt; setNumber(number+1) } &gt;number++&lt;/button&gt;
     &lt;/div&gt;
}
</code></pre>
<p>接下来我们一起研究一下我们上述写的四个<code>hooks</code>最终会变成什么？</p>
<h2>1 mountWorkInProgressHook</h2>
<p>在组件初始化的时候, 每一次<code>hooks</code>执行，如<code>useState()</code>,<code>useRef()</code>, 都会调用<code>mountWorkInProgressHook</code>,</p>
<hr>
<p><code>mountWorkInProgressHook</code>到底做了写什么，让我们一起来分析一下：
<code>react-reconciler/src/ReactFiberHooks.js -&gt; mountWorkInProgressHook</code></p>
<pre><code>function mountWorkInProgressHook() {
  const hook: Hook = {
    memoizedState: null,  // useState中 保存 state信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和deps ｜ useRef中保存的是ref 对象
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) { // 例子中的第一个`hooks`-&gt; useState(0) 走的就是这样。
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
</code></pre>
<p><code>mountWorkInProgressHook</code>这个函数做的事情很简单，</p>
<ul>
<li>首先每次执行一个<code>hooks</code>函数，都产生一个<code>hook</code>对象，里面保存了当前<code>hook</code>信息,</li>
<li>然后将每个<code>hooks</code>以链表形式串联起来，并赋值给<code>workInProgress</code>的<code>memoizedState</code>。</li>
<li>也就证实了上述所说的，函数组件用<code>memoizedState</code>存放<code>hooks</code>链表。</li>
</ul>
<hr>
<p><code>hook</code>对象中都保留了那些信息？我这里先分别介绍一下 :<br>
<strong>memoizedState</strong>： <code>useState中</code> 保存 <code>state</code> 信息 ｜ <code>useEffect</code> 中 保存着 <code>effect</code> 对象 ｜ <code>useMemo</code> 中 保存的是缓存的值和 <code>deps</code> ｜ <code>useRef</code> 中保存的是 <code>ref</code> 对象。
<strong>baseQueue</strong> : <code>usestate</code>和<code>useReducer</code>中 保存最新的更新队列。
<strong>baseState</strong> ： <code>usestate</code>和<code>useReducer</code>中, 一次更新中 ，产生的最新<code>state</code>值。
<strong>queue</strong> ： 保存待更新队列 <code>pendingQueue</code> ，更新函数 <code>dispatch</code> 等信息。
<strong>next</strong>: 指向下一个 <code>hooks</code>对象。</p>
<hr>
<p>那么当我们函数组件执行之后，四个<code>hooks</code>和<code>workInProgress</code>将是如图的关系。
workInprogress.memoizedState = state hook
state hook   =next&gt;  memo hook   =next&gt; ref hook =next&gt; effect hook =next&gt; null
<img src="./Pasted image 20230815134417.png" /></p>
<hr>
<p>知道每个<code>hooks</code>关系之后，我们应该理解了，为什么不能条件语句中，声明<code>hooks</code>。
我们用一幅图表示如果在条件语句中声明会出现什么情况发生。
如果我们将上述<code>demo</code>其中的一个 <code>useRef</code> 放入条件语句中，</p>
<pre><code>let curRef  = null
 if(isFisrt){
  curRef = useRef(null)
}
</code></pre>
<p><strong>因为一旦在条件语句中声明<code>hooks</code>，在下一次函数组件更新，<code>hooks</code>链表结构，将会被破坏，<code>current</code>树的<code>memoizedState</code>缓存<code>hooks</code>信息，和当前<code>workInProgress</code>不一致，如果涉及到读取<code>state</code>等操作，就会发生异常。</strong></p>
<hr>
<p>上述介绍了 <code>hooks</code>通过什么来证明唯一性的，答案 通过<code>hooks</code>链表顺序。
接下来我们按照四个方向，分别介绍初始化的时候发生了什么？</p>
<h2>2 初始化 useState -&gt; mountState</h2>
<p><strong>mountState</strong></p>
<pre><code>function mountState(
  initialState
){
  const hook = mountWorkInProgressHook();
  if (typeof initialState === 'function') {
    // 如果 useState 第一个参数为函数，执行函数得到state
    initialState = initialState();
  }
  hook.memoizedState = hook.baseState = initialState;
  const queue = (hook.queue = {
    pending: null,  // 带更新的
    dispatch: null, // 负责更新函数
    lastRenderedReducer: basicStateReducer, //用于得到最新的 state ,
    lastRenderedState: initialState, // 最后一次得到的 state
  });

  const dispatch = (queue.dispatch = (dispatchAction.bind( // 负责更新的函数
    null,
    currentlyRenderingFiber,
    queue,
  )))
  return [hook.memoizedState, dispatch];
}
</code></pre>
<p><code>mountState</code>到底做了些什么，</p>
<ul>
<li>首先将初始化的<code>state</code>赋值给<code>mountWorkInProgressHook</code>产生的<code>hook</code>对象的 <code>memoizedState</code>和<code>baseState</code>属性，</li>
<li>然后创建一个<code>queue</code>对象，里面保存了负责更新的信息。</li>
<li>通过 dispatchAction 获得 dispatch 方法</li>
<li>返回当前记忆的 state 和 dispatch 方法</li>
</ul>
<hr>
<p>在无状态组件中，<code>useState</code>和<code>useReducer</code>触发函数更新的方法都是<code>dispatchAction</code>,
<code>useState</code>，可以看成一个简化版的<code>useReducer</code>,</p>
<hr>
<p>在研究之前 我们<strong>先要弄明白<code>dispatchAction</code>是什么?</strong></p>
<pre><code>function dispatchAction&lt;S, A&gt;(
  fiber: Fiber,
  queue: UpdateQueue&lt;S, A&gt;,
  action: A,
)
</code></pre>
<pre><code>const [ number , setNumber ] = useState(0)
</code></pre>
<p><strong><code>dispatchAction</code> 就是 <code>setNumber</code></strong> ,
<code>dispatchAction</code> 第一个参数和第二个参数，已经被<code>bind</code>给改成<code>currentlyRenderingFiber</code>和 <code>queue</code>, 我们传入的参数是第三个参数<code>action</code></p>
<h3>dispatchAction 无状态组件更新机制</h3>
<p>作为更新的主要函数，我们一下来研究一下，我把 <code>dispatchAction</code> 精简，精简，再精简，</p>
<pre><code>function dispatchAction(fiber, queue, action) {

  // 计算 expirationTime 过程略过。
  /* 创建一个update */
  const update= {
    expirationTime,
    suspenseConfig,
    action,
    eagerReducer: null,
    eagerState: null,
    next: null,
  }
  /* 把创建的update */
  const pending = queue.pending;
  if (pending === null) {  // 证明第一次更新
    update.next = update;
  } else { // 不是第一次更新
    update.next = pending.next;
    pending.next = update;
  }
  
  queue.pending = update;
  const alternate = fiber.alternate;
  /* 判断当前是否在渲染阶段 */
  if ( fiber === currentlyRenderingFiber || (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber)) {
    didScheduleRenderPhaseUpdate = true;
    update.expirationTime = renderExpirationTime;
    currentlyRenderingFiber.expirationTime = renderExpirationTime;
  } else { /* 当前函数组件对应fiber没有处于调和渲染阶段 ，那么获取最新state , 执行更新 */
    if (fiber.expirationTime === NoWork &amp;&amp; (alternate === null || alternate.expirationTime === NoWork)) {
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher;
        try {
          const currentState = queue.lastRenderedState; /* 上一次的state */
          const eagerState = lastRenderedReducer(currentState, action); /**/
          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) { 
            return
          }
        } 
      }
    }
    scheduleUpdateOnFiber(fiber, expirationTime);
  }
}
</code></pre>
<ol>
<li>产生一个 <code>update</code>对象，里面记录了此次更新的信息，</li>
<li>然后将此<code>update</code>放入待更新的<code>pending</code>队列中，</li>
<li>判断当前函数组件的<code>fiber</code>对象是否处于渲染阶段，选择更新expirationTime还是开始渲染</li>
</ol>
<hr>
<p>判断当前函数组件的<code>fiber</code>对象是否处于渲染阶段，选择更新expirationTime还是开始渲染</p>
<pre><code class="language-js">if ( fiber === currentlyRenderingFiber || (alternate !== null &amp;&amp; alternate === currentlyRenderingFiber)) {
    didScheduleRenderPhaseUpdate = true;
    update.expirationTime = renderExpirationTime;
    currentlyRenderingFiber.expirationTime = renderExpirationTime;
  } 
</code></pre>
<p>如果处于渲染阶段，那么不需要我们在更新当前函数组件，只需要更新一下当前<code>update</code>的<code>expirationTime</code>即可。</p>
<hr>
<pre><code class="language-js">else { /* 当前函数组件对应fiber没有处于调和渲染阶段 ，那么获取最新state , 执行更新 */
    if (fiber.expirationTime === NoWork &amp;&amp; (alternate === null || alternate.expirationTime === NoWork)) {
      const lastRenderedReducer = queue.lastRenderedReducer;
      if (lastRenderedReducer !== null) {
        let prevDispatcher;
        try {
          const currentState = queue.lastRenderedState; /* 上一次的state */
          const eagerState = lastRenderedReducer(currentState, action); /**/
          update.eagerReducer = lastRenderedReducer;
          update.eagerState = eagerState;
          if (is(eagerState, currentState)) { 
            return
          }
        } 
      }
    }
    scheduleUpdateOnFiber(fiber, expirationTime);
  }
</code></pre>
<ul>
<li>如果当前<code>fiber</code>没有处于更新阶段。那么通过调用<code>lastRenderedReducer</code>获取最新的<code>state</code>, 和上一次的<code>currentState</code>，进行浅比较，如果相等，那么就退出，如果两次<code>state</code>不相等，那么调用<code>scheduleUpdateOnFiber</code>调度渲染当前<code>fiber</code>，<code>scheduleUpdateOnFiber</code>是<code>react</code>渲染更新的主要函数。</li>
<li>这就证实了为什么<code>useState</code>，两次值相等的时候，组件不渲染的原因了，这个机制和<code>Component</code>模式下的<code>setState</code>有一定的区别。</li>
</ul>
<h2>3 初始化 useEffect -&gt; mountEffect</h2>
<p>上述讲到了无状态组件中<code>fiber</code>对象<code>memoizedState</code>保存当前的<code>hooks</code>形成的链表。
那么<code>updateQueue</code>保存了什么信息呢，我们会在接下来探索<code>useEffect</code>过程中找到答案。
当我们调用<code>useEffect</code>的时候，在组件第一次渲染的时候会调用<code>mountEffect</code>方法，这个方法到底做了些什么？</p>
<h3>mountEffect</h3>
<pre><code>function mountEffect(
  create,
  deps,
) {
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  hook.memoizedState = pushEffect(
    HookHasEffect | hookEffectTag, 
    create, // useEffect 第一次参数，就是副作用函数
    undefined,
    nextDeps, // useEffect 第二次参数，deps
  );
}

</code></pre>
<p>每个<code>hooks</code>初始化都会创建一个<code>hook</code>对象，然后将 hook 的<code>memoizedState</code>保存当前<code>effect hook</code>信息。</p>
<p><strong>有两个<code>memoizedState</code>大家千万别混淆了，我这里再友情提示一遍</strong></p>
<ul>
<li><code>workInProgress / current</code> 树上的 <code>memoizedState</code> 保存的是当前函数组件每个<code>hooks</code>形成的链表。</li>
<li>每个<code>hooks</code>上的<code>memoizedState</code> 保存了当前<code>hooks</code>信息，不同种类的<code>hooks</code>的<code>memoizedState</code>内容不同。</li>
</ul>
<p>上述的方法最后执行了一个<code>pushEffect</code>，pushEffect 创建了 effect 对象，挂载 updateQueue</p>
<h3>pushEffect</h3>
<pre><code>function pushEffect(tag, create, destroy, deps) {
  const effect = {
    tag,
    create,
    destroy,
    deps,
    next: null,
  };
  let componentUpdateQueue = currentlyRenderingFiber.updateQueue
  if (componentUpdateQueue === null) { // 如果是第一个 useEffect
    componentUpdateQueue = {  lastEffect: null  }
    currentlyRenderingFiber.updateQueue = componentUpdateQueue
    componentUpdateQueue.lastEffect = effect.next = effect;
  } else {  // 存在多个effect
    const lastEffect = componentUpdateQueue.lastEffect;
    if (lastEffect === null) {
      componentUpdateQueue.lastEffect = effect.next = effect;
    } else {
      const firstEffect = lastEffect.next;
      lastEffect.next = effect;
      effect.next = firstEffect;
      componentUpdateQueue.lastEffect = effect;
    }
  }
  return effect;
}
</code></pre>
<p>首先创建一个 <code>effect</code> ，
判断组件如果第一次渲染，那么创建 <code>componentUpdateQueue</code> ，就是<code>workInProgress</code>的<code>updateQueue</code>。
将<code>effect</code>放入<code>updateQueue</code>中。</p>
<hr>
<p>假设我们在一个函数组件中这么写：</p>
<pre><code>useEffect(()=&gt;{
    console.log(1)
},[ props.a ])
useEffect(()=&gt;{
    console.log(2)
},[])
useEffect(()=&gt;{
    console.log(3)
},[])
</code></pre>
<p>最后<code>workInProgress.updateQueue</code>会以这样的形式保存：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14ac9e04c10e45e5b93fc76d47a5fdd5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<h3>拓展: effectList</h3>
<p><code>effect list</code> 可以理解为是一个存储 <code>effectTag</code> 副作用列表容器。它是由 <code>fiber</code> 节点和指针 <code>nextEffect</code> 构成的单链表结构，这其中还包括第一个节点 <code>firstEffect</code> ，和最后一个节点 <code>lastEffect</code>。
<code>React</code> 采用深度优先搜索算法，在 <code>render</code> 阶段遍历 <code>fiber</code> 树时，把每一个有副作用的 <code>fiber</code> 筛选出来，最后构建生成一个只带副作用的 <code>effect list</code> 链表。 在 <code>commit</code> 阶段，<code>React</code> 拿到 <code>effect list</code> 数据后，通过遍历 <code>effect list</code>，并根据每一个 <code>effect</code> 节点的 <code>effectTag</code> 类型，执行每个<code>effect</code>，从而对相应的 <code>DOM</code> 树执行更改。</p>
<h2>4 初始化 useMemo -&gt; mountMemo</h2>
<p>不知道大家是否把 <code>useMemo</code> 想象的过于复杂了，实际相比其他 <code>useState</code> , <code>useEffect</code>等，它的逻辑实际简单的很。</p>
<pre><code>function mountMemo(nextCreate,deps){
  const hook = mountWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
</code></pre>
<p>初始化<code>useMemo</code>，就是创建一个<code>hook</code>，然后执行<code>useMemo</code>的第一个参数, 得到需要缓存的值，然后将值和<code>deps</code>记录下来，赋值给当前<code>hook</code>的<code>memoizedState</code>。整体上并没有复杂的逻辑。</p>
<h2>5 初始化 useRef -&gt; mountRef</h2>
<p>对于<code>useRef</code>初始化处理，似乎更是简单，我们一起来看一下：</p>
<pre><code>function mountRef(initialValue) {
  const hook = mountWorkInProgressHook();
  const ref = {current: initialValue};
  hook.memoizedState = ref;
  return ref;
}
</code></pre>
<p><code>mountRef</code>初始化很简单, 创建一个 ref 对象， 对象的<code>current</code> 属性来保存初始化的值，最后用<code>memoizedState</code>保存<code>ref</code>，完成整个操作。</p>
<h2>6 mounted 阶段 hooks 总结</h2>
<p>我们来总结一下初始化阶段,<code>react-hooks</code>做的事情，在一个函数组件第一次渲染执行上下文过程中，
每个<code>react-hooks</code>执行，都会产生一个<code>hook</code>对象，并形成链表结构，绑定在<code>workInProgress</code>的<code>memoizedState</code>属性上，
然后<code>react-hooks</code>上的状态，绑定在当前<code>hooks</code>对象的<code>memoizedState</code>属性上。
对于<code>effect</code>副作用钩子，会绑定在<code>workInProgress.updateQueue</code>上，等到<code>commit</code>阶段，<code>dom</code>树构建完成，在执行每个 <code>effect</code> 副作用钩子。</p>
<h1>四 hooks 更新阶段</h1>
<p>对于更新阶段，说明上一次 <code>workInProgress</code> 树已经赋值给了 <code>current</code> 树。
存放<code>hooks</code>信息的<code>memoizedState</code>，此时已经存在<code>current</code>树上，<code>react</code>对于<code>hooks</code>的处理逻辑和<code>fiber</code>树逻辑类似。</p>
<p>对于一次函数组件更新，当再次执行<code>hooks</code>函数的时候，比如 <code>useState(0)</code> ，首先要从<code>current</code>的<code>hooks</code>中找到与当前<code>workInProgressHook</code>，对应的<code>currentHooks</code>，然后复制一份<code>currentHooks</code>给<code>workInProgressHook</code>, 接下来<code>hooks</code>函数执行的时候, 把最新的状态更新到<code>workInProgressHook</code>，保证<code>hooks</code>状态不丢失。</p>
<p>所以函数组件每次更新，每一次<code>react-hooks</code>函数执行，都需要有一个函数去做上面的操作，这个函数就是<code>updateWorkInProgressHook</code>, 我们接下来一起看这个<code>updateWorkInProgressHook</code>。</p>
<h2>1 updateWorkInProgressHook</h2>
<pre><code>function updateWorkInProgressHook() {
  let nextCurrentHook;
  if (currentHook === null) {  /* 如果 currentHook = null 证明它是第一个hooks */
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else { /* 不是第一个hooks，那么指向下一个 hooks */
    nextCurrentHook = currentHook.next;
  }
  let nextWorkInProgressHook
  if (workInProgressHook === null) {  //第一次执行hooks
    // 这里应该注意一下，当函数组件更新也是调用 renderWithHooks ,memoizedState属性是置空的
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else { 
    nextWorkInProgressHook = workInProgressHook.next;
  }

  if (nextWorkInProgressHook !== null) { 
      /* 这个情况说明 renderWithHooks 执行 过程发生多次函数组件的执行 ，我们暂时先不考虑 */
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    invariant(
      nextCurrentHook !== null,
      'Rendered more hooks than during the previous render.',
    );
    currentHook = nextCurrentHook;
    const newHook = { //创建一个新的hook
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null,
    };
    if (workInProgressHook === null) { // 如果是第一个hooks
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else { // 重新更新 hook
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
</code></pre>
<ul>
<li>首先如果是第一次执行<code>hooks</code>函数，那么从<code>current</code>树上取出<code>memoizedState</code> ，也就是旧的<code>hooks</code></li>
<li>然后声明变量<code>nextWorkInProgressHook</code>，</li>
<li>最后复制<code>current</code>的<code>hooks</code>，把它赋值给<code>workInProgressHook</code>, 用于更新新的一轮<code>hooks</code>状态。</li>
</ul>
<hr>
<p>正常情况下，一次<code>renderWithHooks</code>执行，<code>workInProgress</code>上的<code>memoizedState</code>会被置空，<code>hooks</code>函数顺序执行，<code>nextWorkInProgressHook</code>应该一直为<code>null</code>，
那么什么情况下<code>nextWorkInProgressHook</code>不为<code>null</code>,
也就是当一次<code>renderWithHooks</code>执行过程中，执行了多次函数组件，也就是在<code>renderWithHooks</code>中这段逻辑。</p>
<pre><code>if (workInProgress.expirationTime === renderExpirationTime) { 
       // ....这里的逻辑我们先放一放
  }
</code></pre>
<p>这里面的逻辑，实际就是判定，如果当前函数组件执行后，当前函数组件的还是处于渲染优先级，说明函数组件又有了新的更新任务，那么循坏执行函数组件。这就造成了上述的，<code>nextWorkInProgressHook</code>不为 <code>null</code> 的情况。</p>
<p>接下来我们看一下四个种类的<code>hooks</code>，在一次组件更新中，分别做了那些操作。</p>
<h2>2 updateState</h2>
<pre><code class="language-js">function updateReducer(
  reducer,
  initialArg,
  init,
){
  const hook = updateWorkInProgressHook();
  const queue = hook.queue;
  queue.lastRenderedReducer = reducer;
  const current = currentHook;
  let baseQueue = current.baseQueue;
  const pendingQueue = queue.pending;
  if (pendingQueue !== null) {
     // 这里省略... 第一步：将 pending  queue 合并到 basequeue
  }
  if (baseQueue !== null) {
    const first = baseQueue.next;
    let newState = current.baseState;
    let newBaseState = null;
    let newBaseQueueFirst = null;
    let newBaseQueueLast = null;
    let update = first;
    do {
      const updateExpirationTime = update.expirationTime;
      if (updateExpirationTime &lt; renderExpirationTime) { //优先级不足
        const clone  = {
          expirationTime: update.expirationTime,
          ...
        };
        if (newBaseQueueLast === null) {
          newBaseQueueFirst = newBaseQueueLast = clone;
          newBaseState = newState;
        } else {
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
      } else {  //此更新确实具有足够的优先级。
        if (newBaseQueueLast !== null) {
          const clone= {
            expirationTime: Sync, 
             ...
          };
          newBaseQueueLast = newBaseQueueLast.next = clone;
        }
        /* 得到新的 state */
        newState = reducer(newState, action);
      }
      update = update.next;
    } while (update !== null &amp;&amp; update !== first);
    if (newBaseQueueLast === null) {
      newBaseState = newState;
    } else {
      newBaseQueueLast.next = newBaseQueueFirst;
    }
    hook.memoizedState = newState;
    hook.baseState = newBaseState;
    hook.baseQueue = newBaseQueueLast;
    queue.lastRenderedState = newState;
  }
  const dispatch = queue.dispatch
  return [hook.memoizedState, dispatch];
}
</code></pre>
<p>首先将上一次更新的<code>pending queue</code> 合并到 <code>basequeue</code>，
接下来把当前<code>useState</code>或是<code>useReduer</code>对应的<code>hooks</code>上的<code>baseState</code>和<code>baseQueue</code>更新到最新的状态。
会循环<code>baseQueue</code>的<code>update</code>，复制一份<code>update</code>, 更新 <code>expirationTime</code>，
对于有足够优先级的<code>update</code>（上述三个<code>setNumber</code>产生的<code>update</code>都具有足够的优先级），我们要获取最新的<code>state</code>状态。
会一次执行<code>useState</code>上的每一个<code>action</code>。得到最新的<code>state</code>。</p>
<h2>这里有会有两个疑问🤔️:</h2>
<p>问题一：这里不是执行最后一个<code>action</code>不就可以了嘛?</p>
<ul>
<li>答案：上面说了 <code>useState</code>逻辑和<code>useReducer</code>差不多。如果第一个参数是一个函数，会引用上一次 <code>update</code>产生的 <code>state</code>, 所以需要<strong>循环调用，每一个<code>update</code>的<code>reducer</code></strong>，</li>
<li>如果<code>setNumber(2)</code>是这种情况，那么只用更新值，如果是<code>setNumber(state=&gt;state+1)</code>, 那么传入上一次的 <code>state</code> 得到最新<code>state</code>。</li>
</ul>
<hr>
<p>问题二：什么情况下会有优先级不足的情况 (<code>updateExpirationTime &lt; renderExpirationTime</code>)？</p>
<ul>
<li>答案： 这种情况，一般会发生在，当我们调用<code>setNumber</code>时候，调用<code>scheduleUpdateOnFiber</code>渲染当前组件时，又产生了一次新的更新，所以把最终执行<code>reducer</code>更新<code>state</code>任务交给下一次更新。</li>
</ul>
<hr>
<p>为什么要将上一次更新的<code>pending queue</code> 合并到 <code>basequeue</code>，比如我们再一次点击事件中这么写，</p>
<pre><code>function Index(){
   const [ number ,setNumber ] = useState(0)
   const handerClick = ()=&gt;{
    //    setNumber(1)
    //    setNumber(2)
    //    setNumber(3)
       setNumber(state=&gt;state+1)
       // 获取上次 state = 1 
       setNumber(state=&gt;state+1)
       // 获取上次 state = 2
       setNumber(state=&gt;state+1)
   }
   console.log(number) // 3 
   return &lt;div&gt;
       &lt;div&gt;{ number }&lt;/div&gt;
       &lt;button onClick={ ()=&gt; handerClick() } &gt;点击&lt;/button&gt;
   &lt;/div&gt;
}
</code></pre>
<p><strong>点击按钮， 打印 3</strong></p>
<p>三次<code>setNumber</code>产生的<code>update</code>会暂且放入<code>pending queue</code>，在下一次函数组件执行时候，三次 <code>update</code>被合并到 <code>baseQueue</code>。结构如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52ed6118238d412aa20044ad33f25827~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<h2>3 updateEffect</h2>
<pre><code>function updateEffect(create, deps): void {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  let destroy = undefined;
  if (currentHook !== null) {
    const prevEffect = currentHook.memoizedState;
    destroy = prevEffect.destroy;
    if (nextDeps !== null) {
      const prevDeps = prevEffect.deps;
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        pushEffect(hookEffectTag, create, destroy, nextDeps);
        return;
      }
    }
  }
  currentlyRenderingFiber.effectTag |= fiberEffectTag
  hook.memoizedState = pushEffect(
    HookHasEffect | hookEffectTag,
    create,
    destroy,
    nextDeps,
  );
}
</code></pre>
<p><code>useEffect</code> 做的事很简单，判断两次<code>deps</code> 相等，如果相等说明此次更新不需要执行，则直接调用 <code>pushEffect</code>, 这里注意 <code>effect</code>的标签，<code>hookEffectTag</code>, 如果不相等，那么更新 <code>effect</code> , 并且赋值给<code>hook.memoizedState</code>，这里标签是 <code>HookHasEffect | hookEffectTag</code>, 然后在<code>commit</code>阶段，<code>react</code>会通过标签来判断，是否执行当前的 <code>effect</code> 函数。</p>
<h2>4 updateMemo</h2>
<pre><code>function updateMemo(
  nextCreate,
  deps,
) {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps; // 新的 deps 值
  const prevState = hook.memoizedState; 
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps = prevState[1]; // 之前保存的 deps 值
      if (areHookInputsEqual(nextDeps, prevDeps)) { //判断两次 deps 值
        return prevState[0];
      }
    }
  }
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];
  return nextValue;
}
</code></pre>
<p>在组件更新过程中，我们执行<code>useMemo</code>函数，做的事情实际很简单，就是判断两次 <code>deps</code>是否相等，如果不想等，证明依赖项发生改变，那么执行 <code>useMemo</code>的第一个函数，得到新的值，然后重新赋值给<code>hook.memoizedState</code>, 如果相等 证明没有依赖项改变，那么直接获取缓存的值。</p>
<p>不过这里有一点，值得注意，<code>nextCreate()</code>执行，如果里面引用了<code>usestate</code>等信息，变量会被引用，无法被垃圾回收机制回收，就是闭包原理，那么访问的属性有可能不是最新的值，所以需要把引用的值，添加到依赖项 <code>dep</code> 数组中。每一次<code>dep</code>改变，重新执行，就不会出现问题了。</p>
<p><strong>温馨小提示： 有很多同学说 <code>useMemo</code>怎么用，到底什么场景用，用了会不会起到反作用，通过对源码原理解析，我可以明确的说，基本上可以放心使用，说白了就是可以定制化缓存，存值取值而已。</strong></p>
<h2>5 updateRef</h2>
<pre><code>function updateRef(initialValue){
  const hook = updateWorkInProgressHook()
  return hook.memoizedState
}
</code></pre>
<p>函数组件更新 useRef 做的事情更简单，就是返回了缓存下来的值，也就是无论函数组件怎么执行，执行多少次，<code>hook.memoizedState</code>内存中都指向了一个对象，所以解释了<code>useEffect</code>,<code>useMemo</code> 中，为什么<code>useRef</code>不需要依赖注入，就能访问到最新的改变值。</p>
<h2>一次点击事件更新</h2>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a02c58be8c6f455f96c2e691b2ac6f7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<h1> </h1>
<h1>「前端工程化」从 0-1 搭建 react，ts 脚手架（1.2w 字超详细教程）</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6919308174151385096">juejin.cn</a></p>
</blockquote>
<h3>设置目标，分解目标</h3>
<p>整个流程，主要分为</p>
<ul>
<li>创建文件阶段 ，</li>
<li>构建，</li>
<li>集成 webpack 阶段，</li>
<li>运行项目阶段</li>
</ul>
<h1>二 创建文件阶段</h1>
<p>1 终端命令行交互</p>
<h2>1 终端命令行交互</h2>
<h3>① node 修改 bin</h3>
<p>我们希望的终端能够识别<code>mycli</code> , 然后通过 <code>mycli create</code>创建一个项目。
实际上流程大致是这样的通过<code>mycli</code>可以指向性执行指定的<code>node</code>文件。</p>
<ol>
<li>新建<strong>mycli.js 文件</strong>
在<code>bin</code>文件夹创建的 <code>mycli.js</code>文件</li>
</ol>
<pre><code>#!/usr/bin/env node
'use strict';
console.log('hello,world')
</code></pre>
<ol start="2">
<li>在<code>package.json</code>中声明一下<code>bin</code>。</li>
</ol>
<pre><code>{
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;bin&quot;: {
    &quot;mycli&quot;: &quot;./bin/mycli.js&quot;
  },
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;👽&quot;,
}
</code></pre>
<p>为了在本地调试，<code>my-cli</code>文件夹下用<code>npm link</code>, 如果在<code>mac</code>上需要执行 <code>sudo npm link</code>
然后我们随便新建一个文件夹，执行一下 <code>mycli</code>。看到成功打印<code>hello,world</code>, 第一步算是成功了。</p>
<hr>
<p>在package.json文件中，bin字段用于指定可执行文件的路径。它允许您将项目中的某个脚本或命令行工具作为全局命令使用。</p>
<p>当您在全局安装项目时，bin字段中指定的脚本将被链接到全局的可执行文件路径中，从而使您可以在命令行中直接运行该脚本。这样，您就可以像运行其他全局命令一样运行项目中的脚本。</p>
<p>例如，假设您的项目有一个名为&quot;my-script.js&quot;的脚本，并且您在package.json的bin字段中指定了该脚本的路径为&quot;./bin/my-script.js&quot;。当您在全局安装项目后，可以在命令行中直接运行&quot;my-script&quot;命令，而不需要指定完整的脚本路径。</p>
<p>这对于将项目作为命令行工具分发给其他开发人员或用户非常有用。他们可以通过全局安装您的项目，然后直接在命令行中使用您的工具。</p>
<h3>② commander -nodejs 终端命令行</h3>
<hr>
<p>接下来我们做的是让<code>node</code>文件 (<code>demo</code>项目中的<code>mycli.js</code>) 能够读懂我们的终端命令。
比如说 <code>mycli create</code> 创建项目； <code>mycli start</code>运行项目; <code>mycli build</code> 打包项目；
为了能够在终端流利的操纵命令行 ，我们引入 <code>commander</code> 模块。</p>
<hr>
<p>为了能在终端打印出花里胡哨的颜色，我们引入<code>chalk</code>库。</p>
<pre><code>const chalk = require('chalk')
const colors = [ 'green' , 'blue' , 'yellow' ,'red'  ]
const consoleColors = {}
/* console color */
colors.forEach(color=&gt;{
    consoleColors[color] = function(text,isConsole=true){
         return isConsole ? console.log( chalk[color](text) ) : chalk[color](text)
    }
})
module.exports = consoleColors
</code></pre>
<h4>简介 commander 常用 api</h4>
<p><code>Commander.js node.js</code>命令行界面的完整解决方案, 受 <code>Ruby Commander</code>启发。
前端开发<code>node cli</code> 必备技能。</p>
<h5>1 <code>version</code>版本</h5>
<pre><code>var program = require('commander');
program
    .version('0.0.1')
    .parse(process.argv);  
</code></pre>
<p>执行结果
node index.js -V
0.0.1</p>
<h5>2 <code>option</code>选项</h5>
<p>使用<code>.option()</code>方法定义<code>commander</code>的选项<code>options</code>
示例：.option('-n, --name [items2]', 'name description', 'default value')。</p>
<pre><code>program
  .option('-d, --debug', 'output extra debugging')
  .option('-s, --small', 'small pizza size')
program.parse(process.argv)
if( program.debug ){
    blue('option is debug')
}else if(program.small){
    blue('option is small')
}
</code></pre>
<p><strong>终端输入</strong> mycli -d
<strong>终端输出</strong> option is debug</p>
<h5>3 <code>commander</code>自定义指令 (重点)</h5>
<p>作用：添加命令名称， 示例：<code>.command('add &lt;num&gt;</code></p>
<p>1 命令名称 &lt;必须&gt;：命令后面可跟用 &lt;&gt; 或 [] 包含的参数；命令的最后一个参数可以是可变的，像实例中那样在数组后面加入 ... 标志；在命令后面传入的参数会被传入到 <code>action</code> 的回调函数以及 <code>program.args</code> 数组中。</p>
<p>2 命令描述 &lt;可省略&gt;：如果存在，且没有显示调用 <code>action(fn)</code> ，就会启动子命令程序，否则会报错 配置选项 &lt;可省略&gt;：可配置<code>noHelp、isDefault</code>等。</p>
<h4>使用 commander，添加自定义命令</h4>
<p>因为我们做的是脚手架，最基本的功能，创建项目，运行项目 (开发环境), 打包项目 (生产环境)，所以我们添加三个命令</p>
<pre><code>/* mycli create 创建项目 */
program
    .command('create')
    .description('create a project ')
    .action(function(){
        green('👽 👽 👽 '+'欢迎使用mycli,轻松构建react ts项目～🎉🎉🎉')
    })

/* mycli start 运行项目 */
program
.command('start')
 .description('start a project')
 .action(function(){
    green('--------运行项目-------')
 })

/* mycli build 打包项目 */
program
.command('build')
.description('build a project')
.action(function(){
    green('--------构建项目-------')
})

program.parse(process.argv)
</code></pre>
<h3>③ inquirer 模块命令行交互</h3>
<p>我们期望像<code>vue-cli</code>或者<code>dva-cli</code>再或者是<code>taro-cli</code>一样，实现和终端的交互功能。
这就需要另外一个 <code>nodejs</code>模块 <code>inquirer</code>。<code>Inquirer.js</code>提供用户界面和查询会话。
上手：</p>
<pre><code>var inquirer = require('inquirer');
inquirer
  .prompt([
    /* 把你的问题传过来 */
  ])
  .then(answers =&gt; {
    /* 反馈用户内容 */
  })
  .catch(error =&gt; {
    /* 出现错误 */
  });
</code></pre>
<hr>
<p>由于我们做的是<code>react</code>脚手架，所以我们和用户交互问题设定为，
是否创建新的项目？(是 / 否) -&gt; 请输入项目名称？(文本输入) -&gt; 请输入作者？(文本输入) -&gt; 请选择公共管理状态？(单选) <code>mobx</code> 或 <code>redux</code>。
上述<code>prompt</code>第一个参数需要对这些问题做基础配置。我们的 <code>question</code> 配置大致是这样</p>
<pre><code>const question = [
   {
        name:'conf',              /* key */
        type:'confirm',           /* 确认 */
        message:'是否创建新的项目？' /* 提示 */
    },{
        name:'name',
        message:'请输入项目名称？',
        when: res =&gt; Boolean(res.conf) /* 是否进行 */
    },{
        name:'author',
        message:'请输入作者？',
        when: res =&gt; Boolean(res.conf)
    },{
        type: 'list',            /* 选择框 */
        message: '请选择公共管理状态？',
        name: 'state',
        choices: ['mobx','redux'], /* 选项*/
        filter: function(val) {    /* 过滤 */
          return val.toLowerCase()
        },
        when: res =&gt; Boolean(res.conf)
    }
]

</code></pre>
<hr>
<p>然后我们在 <code>command('create')</code> 回调 <code>action()</code>里面继续加上如下代码。</p>
<pre><code>program
    .command('create')
    .description('create a project ')
    .action(function(){
        green('👽 👽 👽 '+'欢迎使用mycli,轻松构建react ts项目～🎉🎉🎉')
        inquirer.prompt(question).then(answer=&gt;{
            console.log('answer=', answer )
        })
    })
</code></pre>
<hr>
<h2>接下来我们要做的是，根据用户提供的信息<code>copy</code>项目文件，
<code>copy</code>文件有两种方案，
第一种项目模版存在脚手架中，第二种就是向<code>github</code>这种远程拉取项目模版，
我们在这里用的是第一种方案。
我们在脚手架项目中新建<code>template</code>文件夹。放入<code>react-typescript</code>模版。接下来要做的是就是复制整个<code>template</code>项目模版了。
2 深拷贝文件</h2>
<h3>2 递归复制项目文件</h3>
<h4>实现思路</h4>
<p>思路：</p>
<p>① 选择项目模版 ：首先解析在第一步<code>inquirer</code>交互模块下用户选择的项目配置，我们项目有可能有多套模版。
② 修改配置：对于我们在<code>inquirer</code>阶段，提供的配置项，比如项目名称，作者等等，需要我们对项目模版单独处理, 修改配置项。这些信息一般都存在<code>package.json</code>中。
③ 复制模版生成项目
④ 通知主程序执行下一步操作。</p>
<hr>
<p>遍历整个<code>template</code>文件夹下面所有文件，判断子文件<strong>文件类型</strong>，如果是文件就直接复制文件，如果是文件夹，创建文件夹，然后<strong>递归</strong>遍历文件夹下子文件，重复以上的操作。直到所有的文件全部复制完成。</p>
<hr>
<h4>复制项目文件核心代码</h4>
<h5>第一步：选择模版</h5>
<p><strong><code>create</code>方法</strong></p>
<pre><code>module.exports = function(res){
    /* 创建文件 */
    utils.green('------开始构建-------')
    /* 找到template文件夹下的模版项目 */
    const sourcePath = __dirname.slice(0,-3)+'template'
    utils.blue('当前路径:'+ process.cwd())
    /* 修改package.json*/
    revisePackageJson( res ,sourcePath ).then(()=&gt;{
        copy( sourcePath , process.cwd() ,npm() )
    })
}
</code></pre>
<hr>
<p>在这里我们要弄明白两个路径的意义：</p>
<p><strong><code>__dirname</code></strong>:<code>Node.js</code>中,<code>__dirname</code>总是指向被执行 <code>js</code> 文件的绝对路径, 所以当你在 <code>/d1/d2/mycli.js</code>文件中写了<code>__dirname</code>, 它的值就是<code>/d1/d2</code>。
<strong><code>process.cwd()</code></strong> : <code>process.cwd()</code> 方法会返回 <code>Node.js</code> 进程的当前工作目录。</p>
<h5>第二步：修改配置</h5>
<p>模版项目中的<code>package.json</code>，我们这里简单的做一个替换，
就是读取<code>template</code>中的<code>package.json</code>文件，然后根据模版替换，
接下来重新在目标目录中生成<code>package.json</code>。
接下来<code>revisePackageJson</code>返回的<code>promise</code>中进行真正的复制文件流程。</p>
<pre><code>function revisePackageJson(res,sourcePath){
    return new Promise((resolve)=&gt;{
      /* 读取文件 */
        fs.readFile(sourcePath+'/package.json',(err,data)=&gt;{
            if(err) throw err
            const { author , name  } = res
            let json = data.toString()
            /* 替换模版 */
            json = json.replace(/demoName/g,name.trim())
            json = json.replace(/demoAuthor/g,author.trim())
            const path = process.cwd()+ '/package.json'
            /* 写入文件 */
            fs.writeFile(path, new Buffer(json) ,()=&gt;{
                utils.green( '创建文件：'+ path )
                resolve()
            })
        })
    })
}
</code></pre>
<h5>第三步：复制文件</h5>
<pre><code>let fileCount = 0  /* 文件数量 */
let dirCount = 0   /* 文件夹数量 */
let flat = 0       /* readir数量 */
/**
 * 
 * @param {*} sourcePath   //template资源路径
 * @param {*} currentPath  //当前项目路径
 * @param {*} cb           //项目复制完成回调函数 
 */
function copy (sourcePath,currentPath,cb){
    flat++
    /* 读取文件夹下面的文件 */
    fs.readdir(sourcePath,(err,paths)=&gt;{
        flat--
        if(err){
            throw err
        }
        paths.forEach(path=&gt;{
            if(path !== '.git' &amp;&amp; path !=='package.json' ) fileCount++
            const  newSoucePath = sourcePath + '/' + path
            const  newCurrentPath = currentPath + '/' + path
            /* 判断文件信息 */
            fs.stat(newSoucePath,(err,stat)=&gt;{
                if(err){
                    throw err
                }
                /* 判断是文件，且不是 package.json  */
                if(stat.isFile() &amp;&amp; path !=='package.json' ){
                    /* 创建读写流 */
                    const readSteam = fs.createReadStream(newSoucePath)
                    const writeSteam = fs.createWriteStream(newCurrentPath)
                    readSteam.pipe(writeSteam)
                    color.green( '创建文件：'+ newCurrentPath  )
                    fileCount--
                    completeControl(cb)
                /* 判断是文件夹，对文件夹单独进行 dirExist 操作 */    
                }else if(stat.isDirectory()){
                    if(path!=='.git' &amp;&amp; path !=='package.json' ){
                        dirCount++
                        dirExist( newSoucePath , newCurrentPath ,copy,cb)
                    }
                }
            })
        })
    })
}

/**
 * 
 * @param {*} sourcePath  //template资源路径
 * @param {*} currentPath  //当前项目路径
 * @param {*} copyCallback  // 上面的 copy 函数
 * @param {*} cb    //项目复制完成回调函数 
 */
function dirExist(sourcePath,currentPath,copyCallback,cb){
    fs.exists(currentPath,(ext=&gt;{
        if(ext){
            /* 递归调用copy函数 */
            copyCallback( sourcePath , currentPath,cb)
        }else {
            fs.mkdir(currentPath,()=&gt;{
                fileCount--
                dirCount--
                copyCallback( sourcePath , currentPath,cb)
                color.yellow('创建文件夹：'+ currentPath )
                completeControl(cb)
            })
        }
    }))
}

</code></pre>
<p>这一步的流程大致是这样的，首先用 <code>fs.readdir</code>读取<code>template</code>文件夹下面的文件，然后通过 <code>fs.stat</code>读取文件信息，判断文件的类型，如果当前文件类型是<strong>文件类型</strong>，那么通过读写流<code>fs.createReadStream</code>和<code>fs.createWriteStream</code>创建文件；如果当前文件类型是<strong>文件夹类型</strong>，判断文件夹是否存在，如果当前文件夹存在，递归调用<code>copy</code>复制文件夹下面的文件, 如果不存在，那么重新新建文件夹，然后执行递归调用。这里有一点注意的是，由于我们对<code>package.json</code>单独处理，所以这里的一切文件操作应该排除<code>package.json</code>。因为我们要在整个项目文件全部复制后，进行自动下载依赖等后续操作。</p>
<h3><strong>小技巧：三变量计数法控制异步 I/O 操作</strong></h3>
<p><strong>如何才能够判断所有的文件都已经复制完成呢</strong> ，这里我们没有引入第三方异步流程库，而是巧妙的运用<strong>变量计数法</strong>来判断是否所有文件均以复制完毕。</p>
<p>变量一<code>flat</code>: 每一次 <strong>copy</strong> 函数调用, 会执行异步<code>fs.readdir</code>读取文件夹下面的所有文件, 我们用 <code>flat++</code>记录 <code>readdir</code>数量， 每次<code>readdir</code>完成执行<code>flat--</code>。
变量二<code>fileCount</code>: 每一次文件 (可能文件或者文件夹) 的遍历，我们用<code>fileCount++</code>来记录，当文件创建完成或者文件夹创建完成，执行 <code>fileCount--</code> 。
变量三<code>dirCount</code>: 每一次判断文件夹的操作，我们用 <code>dirCount++</code>来记录，当新的文件夹被创建完成，执行 <code>dirCount--</code>。</p>
<pre><code>function completeControl(cb){
    /* 三变量均为0，异步I/O执行完毕。 */
    if(fileCount === 0 &amp;&amp; dirCount ===0 &amp;&amp; flat===0){
        color.green('------构建完成-------')
        if(cb &amp;&amp; !isInstall ){
            isInstall = true
            color.blue('-----开始install-----')
            cb(()=&gt;{
                color.blue('-----完成install-----')
                /* 判断是否存在webpack  */
                runProject()
            })
        }
    }
}

</code></pre>
<p>我们在每次创建文件或文件夹事件执行之后，都会调用<code>completeControl</code>方法，通过判断<code>flat</code>,<code>fileCount</code>,<code>dirCount</code>三个变量均为 <strong>0</strong>，就能判断出整个复制流程, 执行完毕, 并作出下一步操作。</p>
<h1>三 构建，集成项目阶段</h1>
<h2>1 解析命令，自动运行命令行。</h2>
<p>之前我们通过修改<code>bin</code>，借助<code>commander</code>模块来通过输入终端<strong>命令行</strong>，来执行<code>node</code>文件，来对应启动我们的程序。
接下来我们要做的是通过<code>nodejs</code>代码，来执行对应的<strong>终端命令</strong>。
我们需要在复制整个项目目录之后，来<strong>自动下载依赖<code>npm, install</code>，启动项目<code>npm start</code></strong>。
首先我们在<code>mycli</code>脚手架项目的<code>src</code>文件夹下，新建<code>npm.js</code>，用来处理下载依赖，启动项目操作。</p>
<h3>①<code>which</code>模块助力找到<code>npm</code></h3>
<pre><code>var which = require('which')
//异步用法
which('node', function (er, resolvedPath) {
  // 如果在PATH上找不到“节点”，则返回er
  // 如果找到，则返回exec的绝对路径
})
//同步用法
const resolved = which.sync('node')
</code></pre>
<p><strong>在 npm.js 下</strong></p>
<pre><code>const which = require('which')
/* 找到npm */
function findNpm() {
  var npms = process.platform === 'win32' ? ['npm.cmd'] : ['npm']
  for (var i = 0; i &lt; npms.length; i++) {
    try {
      which.sync(npms[i])
      console.log('use npm: ' + npms[i])
      return npms[i]
    } catch (e) {
    }
  }
  throw new Error('please install npm')
}
</code></pre>
<h3>② child_process.spawn 运行终端命令</h3>
<p>在上面我们成功找到<code>npm</code>之后，需要用 <code>child_process.spawn</code>运行当前命令。
<code>child_process.spawn(command[, args][, options])</code>
<code>command &lt;string&gt;</code> 要运行的命令。 <code>args &lt;string[]&gt;</code> 字符串参数列表。</p>
<p><code>options &lt;Object&gt;</code> 配置参数。</p>
<pre><code>/**
 * 
 * @param {*} cmd   
 * @param {*} args 
 * @param {*} fn 
 */
/* 运行终端命令 */ 
function runCmd(cmd, args, fn) {
  args = args || []
  var runner = require('child_process').spawn(cmd, args, {
    stdio: 'inherit'
  })
  runner.on('close', function (code) {
    if (fn) {
      fn(code)
    }
  })
}
</code></pre>
<h3>③编写 npm 方法</h3>
<p>接下来我们①②步骤的内容整合在一起，把整个<code>npm.js</code> <code>npm</code>方法暴露出去.</p>
<pre><code>/**
 * 
 * @param {*} installArg  执行命令 命令行组成的数组，默认为 install 
 */
module.exports = function (installArg = [ 'install' ]) {
  /* 通过第一步,闭包保存npm */  
  const npm = findNpm()
  return function (done){
    /* 执行命令 */  
    runCmd(which.sync(npm),installArg, function () {
        /* 执行成功回调 */
        done &amp;&amp; done()
     })
  }
}
</code></pre>
<p><strong>使用例子🌰🌰</strong></p>
<pre><code>const npm = require('./npm')

/* 执行 npm install  */
const install = npm()
install()

/* 执行 npm start */
const start = npm(['start])
start()

</code></pre>
<h3>④ 完成自动项目安装，项目启动</h3>
<p>我们在上一步复制项目中，回调函数<code>cb</code>到底是什么？ 相信细心的同学已经发现了。</p>
<pre><code>const npm = require('./npm')
 copy( sourcePath , process.cwd() ,npm() )
</code></pre>
<p><code>cb</code> 函数就是执行<code>npm install</code> 的方法。</p>
<p>我们接着上述的复制成功后，启动项目来讲。
在三变量判断项目创建成功之后, 我们开始执行安装项目.</p>
<pre><code>function completeControl(cb){
    if(fileCount === 0 &amp;&amp; dirCount ===0 &amp;&amp; flat===0){
        color.green('------构建完成-------')
        if(cb &amp;&amp; !isInstall ){
            isInstall = true
            color.blue('-----开始install-----')
            /* 下载项目 */
            cb(()=&gt;{
                color.blue('-----完成install-----')
                runProject()
            })
        }
    }
}
</code></pre>
<p>我们在安装依赖成功的回调函数中，继续调用<code>runProject</code>启动项目。</p>
<pre><code>function runProject(){
    try{
        /* 继续调用 npm 执行，npm start 命令 */
        const start = npm([ 'start' ])
        start()
    }catch(e){
       color.red('自动启动失败，请手动npm start 启动项目')
    }
} 
</code></pre>
<p><strong>效果：由于安装依赖时间过长，运行项目阶段没有在视频里展示</strong>
<code>runProject</code>代码很简单，继续调用 <code>npm</code>， 执行 <code>npm start</code> 命令。</p>
<p>到此为止，我们实现了通过 <code>mycli create</code> <strong>创建项目</strong>，<strong>安装依赖</strong>，<strong>运行项目</strong>全流程，里面还有集成<code>webpack</code>, 进程通信等细节，我们马上慢慢道来。</p>
<h2>2 创建子进程，进程通信</h2>
<p>接下来我们需要实现<code>mycli start</code> 和 <code>mycli build</code> 两个功能。</p>
<h3>① 双进程解决方案</h3>
<p>我们打算用<code>webpack</code>作为脚手架的构建工具。
那么我们需要<code>mycli</code>主进程，创建一个子进程来管理<code>webpack</code>, 合并<code>webpack</code>配置项，运行<code>webpack-dev-serve</code>等，</p>
<p>这里注意的是，我们的主进程是在<code>mycli</code>全局脚手架项目中，而我们的子进程要建立在我们本地通过<code>mycli create</code>创建的<code>react</code>新项目<code>node_modules</code>中，
所以我们写了一个脚手架的<code>plugin</code>用来</p>
<ul>
<li>一方面建立和<code>mycli</code>进程通信,</li>
<li>另一方面管理我们的<code>react</code>目的配置，操控<code>webpack</code>。</li>
</ul>
<p><code>mycli-react-webpack-plugin</code>在创建项目中<code>package.json</code>中，我们在安装依赖的过程中，已经安装在了新建项目的<code>node_modules</code>中。</p>
<h3>② mycli start 和 mycli build</h3>
<h4>第一步：完善 <code>mycli start</code> 和 <code>mycli build</code></h4>
<p>接下来我们在<code>mycli</code>脚手架项目<code>src</code>文件夹下面创建<code>start.js</code>为了和上述的<code>plugin</code>建立起进程通信。因为无论是执行<code>mycli start</code>或者是 <code>mycli build</code>都是需要操纵<code>webpack</code>所以我们写在了一起了。
我们继续在<code>mycli.js</code>中完善 <code>mycli start</code> 和 <code>mycli build</code>两个指令。</p>
<pre><code>const start = require('../src/start')
/* mycli start 运行项目 */
program
.command('start')
 .description('start a project')
 .action(function(){
    green('--------运行项目-------')
    /* 运行项目 */
     start('start').then(()=&gt;{
		green('-------✅  ✅运行完成-------')
	})
 })

/* mycli build 打包项目 */
program
.command('build')
.description('build a project')
.action(function(){
    green('--------构建项目-------')
    /* 打包项目 */
    start('build').then(()=&gt;{
		green('-------✅  ✅构建完成-------')
	})
})

</code></pre>
<h4>第二步：start.js 进程通信</h4>
<h5>child_process.fork 介绍</h5>
<p><code>modulePath</code>：子进程运行的模块。</p>
<p>参数说明：（重复的参数说明就不在这里列举）</p>
<p><code>execPath</code>： 用来创建子进程的可执行文件，默认是<code>/usr/local/bin/node</code>。也就是说，你可通过<code>execPath</code>来指定具体的<code>node</code>可执行文件路径。（比如多个<code>node</code>版本） <code>execArgv：:</code> 传给可执行文件的字符串参数列表。默认是 <code>process.execArgv</code>，跟父进程保持一致。 <code>silent：</code> 默认是<code>false</code>，即子进程的 stdio 从父进程继承。如果是<code>true</code>，则直接<code>pipe</code>向子进程的<code>child.stdin、child.stdout</code>等。 <code>stdio：</code> 如果声明了<code>stdio</code>，则会覆盖<code>silent</code>选项的设置。</p>
<h5>运行子程序</h5>
<p>我们在<code>start.js</code>中启动<strong>子进程</strong>和上述的<code>mycli-react-webpack-plugin</code>建立起通信。接下来就是介绍<code>start.js</code>。</p>
<p><strong>start.js</strong></p>
<pre><code>'use strict';
/* 启动项目 */
const child_process = require('child_process')
const chalk = require('chalk')
const fs = require('fs')
/* 找到mycli-react-webpack-plugin的路径*/
const currentPath = process.cwd()+'/node_modules/mycli-react-webpack-plugin'

/**
 * 
 * @param {*} type  type = start 本地启动项目  type = build 线上打包项目
 */
module.exports = (type) =&gt; {
    return new Promise((resolve,reject)=&gt;{
        /* 判断 mycli-react-webpack-plugin 是否存在 */
        fs.exists(currentPath,(ext)=&gt;{
            if(ext){ /* 存在 启动子进程  */
              const children = child_process.fork(currentPath + '/index.js' )
              /* 监听子进程信息 */
              children.on('message',(message)=&gt;{
                  const msg = JSON.parse( message )
                  if(msg.type ==='end'){
                      /* 关闭子进程 */
                      children.kill()
                      resolve()
                  }else if(msg.type === 'error'){
                       /* 关闭子进程 */
                      children.kill()
                      reject()
                  }
              })
              /* 发送cwd路径 和 操作类型 start 还是 build  */
              children.send(JSON.stringify({
                  cwdPath:process.cwd(),
                  type: type || 'build'
              }))
            }else{ /* 不存在，抛出警告，下载 */
               console.log( chalk.red('mycli-react-webpack-plugin does not exist , please install mycli-react-webpack-plugin')   )
            }
        })
    })
}
</code></pre>
<p>这一步实际很简单，大致分为二步:</p>
<p>1 判断 <code>mycli-react-webpack-plugin</code> 是否存在，如果存在启动 <code>mycli-react-webpack-plugin</code>下的<code>index.js</code>为子进程。如果不存在，抛出警告下载<code>plugin</code>。</p>
<p>2 绑定子进程事件<code>message</code>, 向子进程发送指令，是<strong>启动项目</strong>还是<strong>构建项目</strong>。</p>
<h3>③ mycli-react-webpack-plugin</h3>
<p>接下来做的事就是让<code>mycli-react-webpack-plugin</code> 完成<strong>项目配置</strong>，<strong>项目构建</strong>流程。</p>
<h4>1 项目结构</h4>
<p><strong><code>mycli-react-webpack-plugin</code>插件项目文件结构</strong></p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8593363eb6c94455a4c25b717f1f95a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p>项目目录大致是如上的样子，<code>config</code>文件下，是不同构建环境的基础配置文件, 在项目构建过程中，会读取创建新项目的<code>mycli.config.js</code>在生产环境和开发环境的配置项，然后合并配置项。</p>
<p><strong>我们的新创建项目的<code>mycli.config.js</code></strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9191ac6486c4df6b516e50289481df5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<h4>2 入口文件</h4>
<pre><code>const RunningWebpack = require('./lib/run')

/**
 * 创建一个运行程序，在webpack的不同环境下运行配置文件
 */

/* 启动 RunningWebpack 实例 */
const runner = new RunningWebpack()

process.on('message',message=&gt;{
   const msg = JSON.parse( message )
   if(msg.type &amp;&amp; msg.cwdPath ){
     runner.listen(msg).then(
          ()=&gt;{
             /* 构建完成 ，通知主进程 ，结束子进程 */ 
             process.send(JSON.stringify({ type:'end' }))
          },(error)=&gt;{
             /* 出现错误 ，通知主进程 ，结束子进程 */     
             process.send(JSON.stringify({ type:'error' , error }))
          }
      )
   }
})
</code></pre>
<p>我们这里用<code>RunningWebpack</code>来执行一系列的<code>webpack</code>启动, 打包操作。</p>
<h2>3 合并配置项，自动启动 webpack。</h2>
<h3>① 基于 <code>EventEmitter</code>的 <code>RunningWebpack</code></h3>
<p>我们的 <code>RunningWebpack</code> 基于 <code>nodejs</code> 的 <code>EventEmitter</code> 模块，<code>EventEmitter</code> 可以解决异步 I/O，可以在合适的场景触发不同的<code>webpack</code>命令，比如 <code>start</code> 或者是 <code>build</code>等。</p>
<h4>EventEmitter 简介</h4>
<p><code>nodejs</code>所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p>
<p>Node.js 里面的许多对象都会分发事件：一个 <code>net.Server</code> 对象会在每次有新连接时触发一个事件， 一个 <code>fs.readStream</code> 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 <code>events.EventEmitter</code> 的实例。</p>
<h4>简单用法</h4>
<pre><code>//event.js 文件
var EventEmitter = require('events').EventEmitter; 
var event = new EventEmitter(); 
event.on('some_event', function() { 
    console.log('some_event 事件触发'); 
}); 
setTimeout(function() { 
    event.emit('some_event'); 
}, 1000); 
</code></pre>
<h3>② 合并<code>webpack</code>配置项</h3>
<p>上述介绍完用 <code>EventEmitter</code>作为运行<code>webpack</code>的事件模型，接下我们来分析以下，当运行入口文件的时候。</p>
<pre><code>runner.listen(msg).then
</code></pre>
<pre><code>const merge = require('./merge')
const webpack = require('webpack')
const runMergeGetConfig = require('../config/webpack.base')
   /**
     * 接受不同的webpack状态，合并
     */
    listen({ type,cwdPath }){
       this.path = cwdPath
       this.type = type
       /* 合并配置项，得到新的webpack配置项 */
       this.config = merge.call(this,runMergeGetConfig( cwdPath )(type))
       return new Promise((resolve,reject)=&gt;{
           this.emit('running',type)
           this.once('error',reject)
           this.once('end',resolve)
       })
    }
</code></pre>
<p><code>listen</code>入参参数有两个,<code>type</code>是主线程的传递过来的<code>webpack</code>命令，分为<code>start</code>和<code>build</code>,<code>cwdPath</code>是我们输入终端命令行的绝对路径，接下来我们要做的是读取新创建项目的<code>mycli.config.js</code>。然后和我们的<strong>默认配置</strong>进行<strong>合并</strong>操作。</p>
<h4>runMergeGetConfig</h4>
<p><strong>runMergeGetConfig</strong> 可以根据我们传递的环境 (<code>start</code> or <code>build</code>) 得到对应的<code>webpack</code>基础配置。我们来一起看看<code>runMergeGetConfig</code> 做了什么。</p>
<pre><code>const merge = require('webpack-merge')
module.exports = function(path){
  return type =&gt; {
    if (type==='start') {
      return merge(Appconfig(path), devConfig(path))
    } else {
      return merge(Appconfig(path), proConfig)
    }
  }
}
</code></pre>
<p><code>runMergeGetConfig</code> 很简单就是将 <code>base</code>基础配置，和 <code>dev</code>或者<code>pro</code>环境进行合并得到脚手架的基本配置，然后再和<code>mycli.config.js</code>文件下的自定义配置项合并，我们接着看。</p>
<h4>merge</h4>
<p>我们接着看 <code>mycli-react-webpack-plugin</code>插件下，<code>lib</code>文件夹下的<code>merge.js</code>。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44530b901f1249beb5f37b694f4945ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<pre><code>const fs = require('fs')
const merge = require('webpack-merge')


/* 合并配置 */
function configMegre(Pconf,config){
   const {
      dev = Object.create(null),
      pro = Object.create(null),
      base= Object.create(null)
   } = Pconf
   if(this.type === 'start'){
     return merge(config,base,dev)
   }else{
      return merge(config,base,pro)
   }
}

/**
 * @param {*} config 经过 runMergeGetConfig 得到的脚手架基础配置
 */
function megreConfig(config){
   const targetPath = this.path + '/mycli.config.js'
   const isExi = fs.existsSync(targetPath)
   if(isExi){
     /* 获取开发者自定义配置 */ 
      const perconfig = require(targetPath)
      /**/
      const mergeConfigResult = configMegre.call(this,perconfig,config)
      return mergeConfigResult
   }
   /* 返回最终打包的webpack配置项 */
   return config
}

module.exports = megreConfig
</code></pre>
<p>这一步实际很简单，获取开发者的自定义配置，然后和脚手架的默认配置合并，得到最终的配置。并会返回给我们的<code>running</code>实例。</p>
<h3>③ 自动启动<code>webpack</code></h3>
<p>接下来我们做的是启动<code>webpack</code>。生产环境比较简单，直接 <code>webpack(config)</code>就可以了。在开发环境中，由于需要<code>webpack-dev-server</code>搭建起服务器，然后挂起项目，所以需要我们单独处理。首先将开发环境下的<code>config</code>传入<code>webpack</code>中得到<code>compiler</code>，然后启动<code>dev-server</code>服务，<code>compiler</code> 作为参数传入<code>webpack</code> 并监听我们设置的端口，完成整个流程。</p>
<pre><code>const Server = require('webpack-dev-server/lib/Server')
    const webpack = require('webpack')
    const processOptions = require('webpack-dev-server/lib/utils/processOptions')
    const yargs = require('yargs')
    /* 运行生产环境webpack */
    build(){
        try{
            webpack(this.config,(err)=&gt;{
               if(err){
                   /* 如果发生错误 */
                  this.emit('error')
               }else{
                   /* 结束 */
                  this.emit('end')
               }
            })
        }catch(e){
            this.emit('error')
        }

    }
    /* 运行开发环境webpack */
    start(){
        const _this = this
        processOptions(this.config,yargs.argv,(config,options)=&gt;{
            /* 得到webpack  compiler*/
            const compiler = webpack(config)
            /* 创建dev-server服务 */
            const server = new Server(compiler , options )
            /* port 是在webpack.dev.js下的开发环境配置项中 设置的监听端口 */
            server.listen(options.port, options.host, (err) =&gt; {
              if (err) {
                _this.emit('error')
                throw err;
              }
            })
        })
    }
</code></pre>
<h1>四 运行项目，实现 plugin, 自动化收集 model 阶段</h1>
<p>接下来我们要讲的项目运行阶段，一些附加的配置项，和一起其他的操作。</p>
<h2>1 实现一个简单的终端加载条的 <code>plugin</code></h2>
<p>我们写一个<code>webpack</code> 的<code>plugin</code>做为<code>mycli</code>脚手架的工具，为了方便向开发者展示修改的文件，和一次<code>webpack</code>构建时间，整个插件是在<code>webpack</code>编译阶段完成的。我们需要简单了解<code>webpack</code>一些知识。</p>
<h3>① Compiler 和 Compilation</h3>
<p>在开发 <code>Plugin</code> 时最常用的两个对象就是 <code>Compiler</code> 和 <code>Compilation</code> ，它们是 <code>Plugin</code> 和 <code>Webpack</code> 之间的桥梁。
<code>Compiler</code> 和 <code>Compilation</code> 的区别在于： <code>Compiler</code> 代表了整个 <code>Webpack</code> 从启动到关闭的生命周期，而 <code>Compilation</code> 只是代表了一次新的编译。</p>
<p><code>Compiler</code> 对象包含了 <code>Webpack</code> 环境所有的的配置信息，包含 <code>options，loaders，plugins</code> 这些信息，这个对象在 <code>Webpack</code> 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 <code>Webpack</code> 实例；
<code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。
当 <code>Webpack</code> 以开发模式运行时，每当检测到一个文件变化，一次新的 <code>Compilation</code> 将被创建。 <code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。通过 <code>Compilation</code> 也能读取到 <code>Compiler</code> 对象。</p>
<h3>② <code>Compiler</code> 编译阶段</h3>
<p>我们要理解一次<code>Compiler</code>各个阶段要做的事，才能在特定的阶段用指定的钩子来完成我们的自定义<code>plugin</code>。</p>
<ol>
<li>
<p>run 启动一次新的编译</p>
</li>
<li>
<p>watch-run 和 <code>run</code> 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是<strong>哪些文件发生了变化</strong>导致重新启动一次新的编译。</p>
</li>
<li>
<p>compile  该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 <code>compiler</code> 对象。</p>
</li>
<li>
<p>compilation
当 <code>Webpack</code> 以开发模式运行时，每当检测到文件变化，一次新的 <code>Compilation</code> 将被创建。一个 <code>Compilation</code> 对象包含了当前的模块资源、编译生成资源、变化的文件等。<code>Compilation</code> 对象也提供了很多事件回调供插件做扩展。</p>
</li>
<li>
<p>make
一个新的 <code>Compilation</code> 创建完毕，即将从 <code>Entry</code> 开始读取文件，根据文件类型和配置的 <code>Loader</code> 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。</p>
</li>
<li>
<p>after-compile s一次 <code>Compilation</code> 执行完成。</p>
</li>
<li>
<p>invalid
当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 <code>Webpack</code> 退出。</p>
</li>
</ol>
<h3>③ 编写插件</h3>
<p>我们编写的<code>webpack</code>插件，需要在改动时候，打印出当前改动的文件 , 并用进度条展示一次编译的时间。</p>
<pre><code>const chalk = require('chalk')
var slog = require('single-line-log');

class MycliConsolePlugin {
    
    constructor(options){
       this.options = options
    }
    apply(compiler){
        /* 监听文件改动 */
        compiler.hooks.watchRun.tap('MycliConsolePlugin', (watching) =&gt; {
            const changeFiles = watching.watchFileSystem.watcher.mtimes
            for(let file in changeFiles){
                console.log(chalk.green('当前改动文件：'+ file))
            }
        })
        /* 在一次编译创建之前 */
        compiler.hooks.compile.tap('MycliConsolePlugin',()=&gt;{
            this.beginCompile()
        })
        /* 一次 compile 完成 */
        compiler.hooks.done.tap('MycliConsolePlugin',()=&gt;{
            this.timer &amp;&amp; clearInterval( this.timer )
            console.log( chalk.yellow(' 编译完成') )
        })
    }
    /* 开始记录编译 */
    beginCompile(){
       const lineSlog = slog.stdout
       let text  = '开始编译：'

       this.timer = setInterval(()=&gt;{
          text +=  '█'
          lineSlog( chalk.green(text))
       },50)
    }
}
module.exports = RuxConsolePlugin
</code></pre>
<h4>使用</h4>
<p>插件的使用，因为我们这个插件是在开发环境下，所以只需要在<code>webpack.dev.js</code>加入上述的<code>MycliConsolePlugin</code>插件。</p>
<pre><code>const webpack = require('webpack')
const MycliConsolePlugin = require('../plugins/mycli-console-pulgin')
const devConfig =(path)=&gt;{
  return  {
    devtool: 'cheap-module-eval-source-map',
    mode: 'development',
    devServer: {
      contentBase: path + '/dist',
      open: true, /* 自动打开浏览器 */
      hot: true,
      historyApiFallback: true,
      publicPath: '/',
      port: 8888, /* 服务器端口 */
      inline: true,
      proxy: {  /* 代理服务器 */
      }    },
    plugins: [
      new webpack.HotModuleReplacementPlugin(),
      new MycliConsolePlugin({
        dec:1
      })
    ]
  }
}
module.exports = devConfig
</code></pre>
<h2>2 require.context 实现前端自动化</h2>
<p>前端自动化已经脱离 <code>mycli</code>范畴了，但是为了让大家明白前端自动化流程，这里用<code>webpack</code>提供的<code>API</code> 中的<code>require.context</code>为案例。</p>
<h3>require.context 讲解</h3>
<pre><code>require.context(directory, useSubdirectories = true, regExp = /^\.\/.*$/, mode = 'sync');
</code></pre>
<p>可以给这个函数传入三个参数： ① <code>directory</code> 要搜索的目录， ② <code>useSubdirectories</code> 标记表示是否还搜索其子目录， ③ <code>regExp</code> 匹配文件的正则表达式。</p>
<p><code>webpack</code> 会在构建中解析代码中的 <code>require.context()</code> 。</p>
<p>官网示例：</p>
<pre><code>/* （创建出）一个 context，其中文件来自 test 目录，request 以 `.test.js` 结尾。 */
require.context('./test', false, /\.test\.js$/);

/* （创建出）一个 context，其中所有文件都来自父文件夹及其所有子级文件夹，request 以 `.stories.js` 结尾。 */
require.context('../', true, /\.stories\.js$/);

</code></pre>
<h3>实现自动化</h3>
<p>我们接着用<code>mycli</code>创建的项目作为<code>demo</code>, 我们在项目<code>src</code>文件夹下面新建<code>model</code>文件夹，用来自动收集里面的文件。<code>model</code>文件下，有三个文件 <code>demo.ts</code> , <code>demo1.ts</code> ,<code>demo2.ts</code> , 我们接下来做的是自动收集文件下的数据。</p>
<p><strong>demo.ts</strong></p>
<pre><code>const a = 'demo'
export default a
</code></pre>
<p>· <strong>demo1.ts</strong></p>
<pre><code>const b = 'demo1'
export default b
</code></pre>
<p><strong>demo2.ts</strong></p>
<pre><code>const b = 'demo2'
export default b
</code></pre>
<p><strong>探索 <code>require.context</code></strong></p>
<pre><code>const file  = require.context('./model',false,/\.tsx?|jsx?$/)
console.log(file)
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2806e1a51cc54088a5b5a2c32fd505f2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p>打印<code>file</code> ，我们发现<code>webpack</code>的方法。接下来我们获取文件名组成的数组。</p>
<pre><code>const file  = require.context('./model',false,/\.tsx?|jsx?$/)
console.log(file.keys())
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9aaacad35554330b51cdc9177ad7e76~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p>解析来我们自动收集文件下的 a , b ,c 变量。</p>
<pre><code>/* 用来收集文件 */
const model ={} 
const file  = require.context('./model',false,/\.tsx?|jsx?$/)

/* 遍历文件 */
file.keys().map(item=&gt;{
    /* 收集数据 */
    model[item] = file(item).default
})

console.log(model)
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adae9722fc234aee93e9e3f920146d07~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p>到这里我们实现了自动收集流程。如果深层次递归收集，我们可以将 <code>require.context</code> 第二个参数设置为<code>true</code></p>
<pre><code>require.context('./model',true,/\.tsx?|jsx?$/)
</code></pre>
<p><strong>项目目录</strong>
model/text/demo3.ts
<strong>demo3.ts</strong></p>
<pre><code>const d = 'demo3'

export default d
</code></pre>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc4722b618fd402a8f01c6ba2fe773d2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p><strong>打印完美递归收集了子文件下的<code>model</code></strong></p>
<h1> </h1>
<h1>一套规范的 Vue3.x 项目工程环境</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6951649464637636622?searchId=202307221641218C3D1D22C162116DC090">juejin.cn</a></p>
</blockquote>
<p>本文篇幅从以下几个方面展开：</p>
<ul>
<li>架构搭建</li>
<li>代码规范</li>
<li>提交规范</li>
<li>单元测试</li>
<li>自动部署</li>
</ul>
<h2>技术栈</h2>
<ul>
<li>Git Hook 工具：<a href="https://link.juejin.cn?target=https%3A%2F%2Ftypicode.github.io%2Fhusky%2F%23%2F" title="https://typicode.github.io/husky/#/">husky</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fokonet%2Flint-staged" title="https://github.com/okonet/lint-staged">lint-staged</a></li>
<li>代码规范：<a href="https://link.juejin.cn?target=http%3A%2F%2Feditorconfig.org" title="http://editorconfig.org">EditorConfig</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fprettier.io%2F" title="https://prettier.io/">Prettier</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Feslint.org%2F" title="https://eslint.org/">ESLint</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fairbnb%2Fjavascript%23translation" title="https://github.com/airbnb/javascript#translation">Airbnb JavaScript Style Guide</a></li>
<li>提交规范：<a href="https://link.juejin.cn?target=http%3A%2F%2Fcommitizen.github.io%2Fcz-cli%2F" title="http://commitizen.github.io/cz-cli/">Commitizen</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fcommitlint.js.org%2F%23%2F" title="https://commitlint.js.org/#/">Commitlint</a></li>
<li>单元测试：<a href="https://link.juejin.cn?target=https%3A%2F%2Fnext.vue-test-utils.vuejs.org%2F" title="https://next.vue-test-utils.vuejs.org/">vue-test-utils</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fjestjs.io%2F" title="https://jestjs.io/">jest</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-jest" title="https://github.com/vuejs/vue-jest">vue-jest</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fkulshekhar.github.io%2Fts-jest%2F" title="https://kulshekhar.github.io/ts-jest/">ts-jest</a></li>
<li>自动部署：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdocs.github.com%2Fcn%2Factions%2Flearn-github-actions" title="https://docs.github.com/cn/actions/learn-github-actions">GitHub Actions</a></li>
</ul>
<h2>架构搭建</h2>
<p>请确保你的电脑上成功安装 Node.js，本项目使用 Vite 构建工具，<strong>需要 Node.js 版本 &gt;= 12.0.0</strong>。</p>
<h3>使用 Vite 快速初始化项目雏形</h3>
<ul>
<li>使用 NPM：npm init @vitejs/app</li>
<li>使用 Yarn：yarn create @vitejs/app</li>
</ul>
<h3>使用 Vite 快速初始化项目雏形</h3>
<p>然后按照终端提示完成以下操作：
2.  选择模板
本项目需要使用 Vue3 + TypeScript，所以我们选择 <code>vue-ts</code>，会自动安装 Vue3 和 TypeScript。
3.  安装依赖 npm install
4.  启动项目 npm run dev</p>
<hr>
<p>你还可以通过附加的命令行选项直接指定项目名和模板，本项目要构建 Vite + Vue3 + TypeScript 项目，则运行：
npm 6.x
npm init @vitejs/app vite-vue3-starter --template vue-ts</p>
<p>npm 7+（需要额外的双横线）
npm init @vitejs/app vite-vue3-starter -- --template vue-ts
yarn
yarn create @vitejs/app vite-vue3-starter --template vue-ts</p>
<hr>
<p>Vite 配置文件 <code>vite.config.ts</code> 位于根目录下，项目启动时会自动读取。</p>
<h3>修改 Vite 配置文件</h3>
<p>本项目先做一些简单配置，例如：设置 <code>@</code> 指向 <code>src</code> 目录、 服务启动端口、打包路径、代理等。</p>
<pre><code>import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
// 如果编辑器提示 path 模块找不到，则可以安装一下 @types/node -&gt; npm i @types/node -D
import { resolve } from 'path'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src') // 设置 `@` 指向 `src` 目录
    }
  },
  base: './', // 设置打包路径
  server: {
    port: 4000, // 设置服务启动端口号
    open: true, // 设置服务启动时是否自动打开浏览器
    cors: true // 允许跨域

    // 设置代理，根据我们项目实际情况配置
    // proxy: {
    //   '/api': {
    //     target: 'http://xxx.xxx.xxx.xxx:8000',
    //     changeOrigin: true,
    //     secure: false,
    //     rewrite: (path) =&gt; path.replace('/api/', '/')
    //   }
    // }
  }
})

</code></pre>
<h3>规范目录结构</h3>
<pre><code>├── publish/
└── src/
    ├── assets/                    // 静态资源目录
    ├── common/                    // 通用类库目录
    ├── components/                // 公共组件目录
    ├── router/                    // 路由配置目录
    ├── store/                     // 状态管理目录
    ├── style/                     // 通用 CSS 目录
    ├── utils/                     // 工具函数目录
    ├── views/                     // 页面组件目录
    ├── App.vue
    ├── main.ts
    ├── shims-vue.d.ts
├── tests/                         // 单元测试目录
├── index.html
├── tsconfig.json                  // TypeScript 配置文件
├── vite.config.ts                 // Vite 配置文件
└── package.json

</code></pre>
<h3>集成路由工具 Vue Router</h3>
<ol>
<li>安装支持 Vue3 的路由工具 vue-router@4    npm i vue-router@4</li>
<li>创建 <code>src/router/index.ts</code> 路由配置文件</li>
<li>在 <code>main.ts</code> 文件中挂载路由配置</li>
</ol>
<hr>
<p>router/index.ts` 路由配置文件</p>
<pre><code>import {
  createRouter,
  createWebHashHistory,
  RouteRecordRaw
} from 'vue-router'
import Home from '@/views/home.vue'
import Vuex from '@/views/vuex.vue'

const routes: Array&lt;RouteRecordRaw&gt; = [
  {
	path: '/',
	name: 'Home',
	component: Home
  },
  {
	path: '/vuex',
	name: 'Vuex',
	component: Vuex
  },
  {
	path: '/axios',
	name: 'Axios',
	component: () =&gt; import('@/views/axios.vue') // 懒加载组件
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router

</code></pre>
<p>根据本项目路由配置的实际情况，你需要在 <code>src</code> 下创建 <code>views</code> 目录，用来存储页面组件。
我们在 <code>views</code> 目录下创建 <code>home.vue</code> 、<code>vuex.vue</code> 、<code>axios.vue</code>。</p>
<hr>
<ol start="3">
<li>在 <code>main.ts</code> 文件中挂载路由配置<pre><code>import { createApp } from 'vue'
import App from './App.vue'

import router from './router/index'

createApp(App).use(router).mount('#app')

</code></pre>
</li>
</ol>
<h3>集成状态管理工具 Vuex</h3>
<ol>
<li>安装支持 Vue3 的状态管理工具 vuex@next   npm i vuex@next</li>
<li>创建 <code>src/store/index.ts</code> 文件</li>
<li>
<ol start="3">
<li>在 <code>main.ts</code> 文件中挂载 Vuex 配置</li>
</ol>
</li>
</ol>
<hr>
<p>Vuex配置文件
在 <code>src</code> 下创建 <code>store</code> 目录，然后在 <code>store</code> 目录里新建 <code>index.ts</code> 文件：</p>
<pre><code>import { createStore } from 'vuex'

const defaultState = {
  count: 0
}

// Create a new store instance.
export default createStore({
  state() {
	return defaultState
  },
  mutations: {
	increment(state: typeof defaultState) {
	  state.count++
	}
  },
  actions: {
	increment(context) {
	  context.commit('increment')
	}
  },
  getters: {
	double(state: typeof defaultState) {
	  return 2 * state.count
	}
  }
})
</code></pre>
<hr>
<ol start="2">
<li>在 <code>main.ts</code> 文件中挂载 Vuex 配置<pre><code>import { createApp } from 'vue'
import App from './App.vue'

import store from './store/index'

createApp(App).use(store).mount('#app')

</code></pre>
</li>
</ol>
<h3>集成 UI 框架 Element Plus</h3>
<ol>
<li>npm安装支持 Vue3 的 UI 框架 Element Plus</li>
<li>在 <code>main.ts</code> 文件中挂载 Element Plus<pre><code>import { createApp } from 'vue'
import App from './App.vue'

import ElementPlus from 'element-plus'
import 'element-plus/lib/theme-chalk/index.css'

createApp(App).use(ElementPlus).mount('#app')

</code></pre>
</li>
</ol>
<h3>集成 HTTP 工具 Axios</h3>
<ol>
<li>npm安装 Axios（Axios 跟 Vue 版本没有直接关系，安装最新即可）</li>
<li>配置 Axios
为了使项目的目录结构合理且规范，我们在 <code>src</code> 下创建 <code>utils</code> 目录来存储我们常用的工具函数。</li>
<li>使用 Axios   在需要使用 Axios 文件里，引入 Axios 配置文件
Axios 作为 HTTP 工具，我们在 <code>utils</code> 目录下创建 <code>axios.ts</code> 作为 Axios 配置文件：</li>
</ol>
<hr>
<p>axios配置文件</p>
<pre><code>import Axios from 'axios'
import { ElMessage } from 'element-plus'

const baseURL = 'https://api.github.com'

const axios = Axios.create({
  baseURL,
  timeout: 20000 // 请求超时 20s
})

// 前置拦截器（发起请求之前的拦截）
axios.interceptors.request.use(
  (response) =&gt; {
	/**
	 * 根据你的项目实际情况来对 config 做处理
	 * 这里对 config 不做任何处理，直接返回
	 */
	return response
  },
  (error) =&gt; {
	return Promise.reject(error)
  }
)

// 后置拦截器（获取到响应时的拦截）
axios.interceptors.response.use(
  (response) =&gt; {
	/**
	 * 根据你的项目实际情况来对 response 和 error 做处理
	 * 这里对 response 和 error 不做任何处理，直接返回
	 */
	return response
  },
  (error) =&gt; {
	if (error.response &amp;&amp; error.response.data) {
	  const code = error.response.status
	  const msg = error.response.data.message
	  ElMessage.error(`Code: ${code}, Message: ${msg}`)
	  console.error(`[Axios Error]`, error.response)
	} else {
	  ElMessage.error(`${error}`)
	}
	return Promise.reject(error)
  }
)

export default axios

</code></pre>
<hr>
<ol start="3">
<li>使用 Axios<br>
在需要使用 Axios 文件里，引入 Axios 配置文件，参考如下：<pre><code>&lt;template&gt;&lt;/template&gt;
&lt;script lang=&quot;ts&quot;&gt;
  import { defineComponent } from 'vue'
  import axios from '../utils/axios'

  export default defineComponent({
    setup() {
      axios
        .get('/users/XPoet')
        .then((res) =&gt; {
          console.log('res: ', res)
        })
        .catch((err) =&gt; {
          console.log('err: ', err)
        })
    }
  })
&lt;/script&gt;

</code></pre>
</li>
</ol>
<h3>集成 CSS 预编译器 Stylus/Sass/Less</h3>
<p>本项目使用 CSS 预编译器 Stylus，直接安装为开发依赖即可。
Vite 内部已帮我们集成了相关的 loader，不需要额外配置。同理，你也可以使用 Sass 或 Less 等。</p>
<ol>
<li>安装   npm i stylus -D</li>
<li>使用<pre><code>&lt;style lang=&quot;stylus&quot;&gt;
  ...
&lt;/style&gt;

</code></pre>
</li>
</ol>
<h2>代码规范</h2>
<p>使用 <strong>EditorConfig + Prettier + ESLint</strong> 组合来实现代码规范化。</p>
<h3>集成 EditorConfig 配置</h3>
<p>EditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。
在项目根目录下增加 <code>.editorconfig</code> 文件：</p>
<pre><code># Editor configuration, see http://editorconfig.org

# 表示是最顶层的 EditorConfig 配置文件
root = true

[*] # 表示所有文件适用
charset = utf-8 # 设置文件字符集为 utf-8
indent_style = space # 缩进风格（tab | space）
indent_size = 2 # 缩进大小
end_of_line = lf # 控制换行类型(lf | cr | crlf)
trim_trailing_whitespace = true # 去除行首的任意空白字符
insert_final_newline = true # 始终在文件末尾插入一个新行

[*.md] # 表示仅 md 文件适用以下规则
max_line_length = off
trim_trailing_whitespace = false

</code></pre>
<hr>
<p>注意：</p>
<ul>
<li>VSCode 使用 EditorConfig 需要去插件市场下载插件 <strong>EditorConfig for VS Code</strong> 。</li>
<li>JetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 EditorConfig 配置。</li>
</ul>
<h3>集成 Prettier 配置</h3>
<ol>
<li>安装 Prettier   npm i prettier -D</li>
<li>创建 Prettier 配置文件</li>
<li>配置 <code>.prettierrc</code></li>
</ol>
<hr>
<p>Prettier 支持多种格式的<a href="https://link.juejin.cn?target=https%3A%2F%2Fprettier.io%2Fdocs%2Fen%2Fconfiguration.html" title="https://prettier.io/docs/en/configuration.html">配置文件</a>，比如 <code>.json</code>、<code>.yml</code>、<code>.yaml</code>、<code>.js</code>等。
在本项目根目录下创建 <code>.prettierrc</code> 文件。
在本项目中，我们进行如下简单配置</p>
<pre><code>{
  &quot;useTabs&quot;: false,
  &quot;tabWidth&quot;: 2,
  &quot;printWidth&quot;: 100,
  &quot;singleQuote&quot;: true,
  &quot;trailingComma&quot;: &quot;none&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;semi&quot;: false
}

</code></pre>
<hr>
<p>Prettier 安装且配置好之后，就能使用命令来格式化代码</p>
<pre><code># 格式化所有文件（. 表示所有文件）
npx prettier --write .
</code></pre>
<hr>
<p>注意：</p>
<ul>
<li>VSCode 编辑器使用 Prettier 配置需要下载插件 <strong>Prettier - Code formatter</strong> 。</li>
<li>JetBrains 系列编辑器（WebStorm、IntelliJ IDEA 等）则不用额外安装插件，可直接使用 Prettier 配置。</li>
</ul>
<hr>
<p>Prettier 是一款强大的代码格式化工具，基本上前端能用到的文件格式它都可以搞定，
Prettier 配置好以后，在使用 VSCode 或 WebStorm 等编辑器的格式化功能时，编辑器就会按照 Prettier 配置文件的规则来进行格式化，避免了因为大家编辑器配置不一样而导致格式化后的代码风格不统一的问题。</p>
<h3>集成 ESLint 配置</h3>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Feslint%2Feslint" title="https://github.com/eslint/eslint">ESLint</a> 是一款用于查找并报告代码中问题的工具，并且支持部分问题自动修复。
如果发现错误，就给出规则提示，并且自动修复，
其核心是通过对代码解析得到的 AST（Abstract Syntax Tree 抽象语法树）进行模式匹配，来分析代码达到检查代码质量和风格问题的能力。</p>
<ol>
<li>安装 ESLint    npm i eslint -D</li>
<li>配置 ESLint</li>
<li>ESLint 配置文件 <code>.eslintrc.js</code></li>
</ol>
<hr>
<p>ESLint 安装成功后，执行 <code>npx eslint --init</code>，然后按照终端操作提示完成一系列设置来创建配置文件。
*   How would you like to use ESLint? （你想如何使用 ESLint?）<br>
我们这里选择 <strong>To check syntax, find problems, and enforce code style（检查语法、发现问题并强制执行代码风格）</strong>
*   What type of modules does your project use?（你的项目使用哪种类型的模块?）
我们这里选择 <strong>JavaScript modules (import/export)</strong>
*   Which framework does your project use? （你的项目使用哪种框架?）
我们这里选择 <strong>Vue.js</strong>
*   Does your project use TypeScript?（你的项目是否使用 TypeScript？）
我们这里选择 <strong>Yes</strong>
*   Where does your code run?（你的代码在哪里运行?）
我们这里选择 <strong>Browser 和 Node</strong>（按空格键进行选择，选完按回车键确定）
*   How would you like to define a style for your project?（你想怎样为你的项目定义风格？）
我们这里选择 <strong>Use a popular style guide（使用一种流行的风格指南）</strong>
*   Which style guide do you want to follow?（你想遵循哪一种风格指南?）
ESLint 为我们列出了三种社区流行的 JavaScript 风格指南，分别是 Airbnb、Standard、Google。**这里作者不建议大家去自由配置 ESLint 规则，
*   What format do you want your config file to be in?（你希望你的配置文件是什么格式?）
我们这里选择 <strong>JavaScript</strong>
*   Would you like to install them now with npm?（你想现在就用 NPM 安装它们吗?）
根据上面的选择，ESLint 会自动去查找缺失的依赖，我们这里选择 <strong>Yes</strong>，使用 NPM 下载安装这些依赖包。
注意：如果自动安装依赖失败，那么需要手动安装
npm i @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-config-airbnb-base eslint-plugin-import eslint-plugin-vue -D</p>
<hr>
<p>在配置操作完成后，会在项目根目录下自动生成 <code>.eslintrc.js</code> 配置文件：</p>
<pre><code>module.exports = {
  env: {
	browser: true,
	es2021: true,
	node: true
  },
  extends: ['plugin:vue/essential', 'airbnb-base'],
  parserOptions: {
	ecmaVersion: 12,
	parser: '@typescript-eslint/parser',
	sourceType: 'module'
  },
  plugins: ['vue', '@typescript-eslint'],
  rules: {}
}

</code></pre>
<p>根据项目实际情况，如果我们有额外的 ESLint 规则，也在此文件中追加。</p>
<hr>
<ul>
<li>VSCode 使用 ESLint 配置文件需要去插件市场下载插件 <strong>ESLint</strong> 。</li>
<li>JetBrains 系列（WebStorm、IntelliJ IDEA 等）则不用额外安装插件。</li>
</ul>
<hr>
<p>配置好以后，我们在 VSCode 或 WebStorm 等编辑器中开启 ESLin，写代码时，ESLint 就会按照我们配置的规则来进行实时代码检查，发现问题会给出对应错误提示和修复方案。
虽然，现在编辑器已经给出错误提示和修复方案，但需要我们一个一个去点击修复，</p>
<p>我们只需设置编辑器保存文件时自动执行 <code>eslint --fix</code> 命令进行代码风格修复。</p>
<ul>
<li>VSCode 在 <code>settings.json</code> 设置文件中，增加以下代码：<pre><code>&quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.eslint&quot;: true
 }

</code></pre>
</li>
</ul>
<h3>解决 Prettier 和 ESLint 的冲突</h3>
<p>冲突:: 会出现用 Prettier 格式化后的代码，ESLint 检测到格式有问题的，从而抛出错误提示。</p>
<p>解决两者冲突问题，需要用到 <strong>eslint-plugin-prettier</strong> 和 <strong>eslint-config-prettier</strong>。</p>
<ul>
<li><code>eslint-plugin-prettier</code> 将 Prettier 的规则设置到 ESLint 的规则中。</li>
<li><code>eslint-config-prettier</code> 关闭 ESLint 中与 Prettier 中会发生冲突的规则。
最后形成优先级：<code>Prettier 配置规则</code> &gt; <code>ESLint 配置规则</code>。
这样，我们在执行 <code>eslint --fix</code> 命令时，ESLint 就会按照 Prettier 的配置规则来格式化代码，轻松解决二者冲突问题。</li>
</ul>
<hr>
<ul>
<li>安装插件  npm i eslint-plugin-prettier eslint-config-prettier -D</li>
<li>在 <code>.eslintrc.js</code> 添加 prettier 插件<pre><code>module.exports = {
  ...
  extends: [
    'plugin:vue/essential',
    'airbnb-base',
    'plugin:prettier/recommended' // 添加 prettier 插件
  ],
  ...
}

</code></pre>
</li>
</ul>
<h3>集成 husky 和 lint-staged</h3>
<p>我们在项目中已集成 ESLint 和 Prettier，但团队可能会有些人觉得这些条条框框的限制很麻烦，选择视 “提示” 而不见
所以，我们还需要做一些限制，让没通过 ESLint 检测和修复的代码禁止提交，从而保证仓库代码都是符合规范的。</p>
<p>为了解决这个问题，我们需要用到 Git Hook，在本地执行 <code>git commit</code> 的时候，就对所提交的代码进行 ESLint 检测和修复（即执行 <code>eslint --fix</code>），如果这些代码没通过 ESLint 规则校验，则禁止提交。</p>
<p>实现这一功能，我们借助 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypicode%2Fhusky" title="https://github.com/typicode/husky">husky</a> + <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fokonet%2Flint-staged" title="https://github.com/okonet/lint-staged">lint-staged</a> 。</p>
<hr>
<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ftypicode%2Fhusky" title="https://github.com/typicode/husky">husky</a> —— Git Hook 工具，可以设置在 git 各个阶段（<code>pre-commit</code>、<code>commit-msg</code>、<code>pre-push</code> 等）触发我们的命令。<br>
<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fokonet%2Flint-staged" title="https://github.com/okonet/lint-staged">lint-staged</a> —— 在 git 暂存的文件上运行 linters。</p>
<h4>配置 husky</h4>
<ul>
<li>自动配置（推荐）
使用 <code>husky-init</code> 命令快速在项目初始化一个 husky 配置。</li>
</ul>
<pre><code>npx husky-init &amp;&amp; npm install
</code></pre>
<p>这行命令做了四件事：</p>
<ol>
<li>安装 husky 到开发依赖</li>
<li>在项目根目录下创建 <code>.husky</code> 目录</li>
<li>在 <code>.husky</code> 目录创建 <code>pre-commit</code> hook，并初始化 <code>pre-commit</code> 命令为 <code>npm test</code></li>
<li>修改 <code>package.json</code> 的 <code>scripts</code>，增加 <code>&quot;prepare&quot;: &quot;husky install&quot;</code></li>
</ol>
<hr>
<p>现在我们来使用husky：
husky 包含很多 <code>hook</code>（钩子），常用有：<code>pre-commit</code>、<code>commit-msg</code>、<code>pre-push</code>。
这里，我们使用 <code>pre-commit</code> 来触发 ESLint 命令。修改 <code>.husky/pre-commit</code> hook 文件的触发命令</p>
<hr>
<pre><code>eslint --fix ./src --ext .vue,.js,.ts
</code></pre>
<p>上面这个 <code>pre-commit</code> hook 文件的作用是：当我们执行 <code>git commit -m &quot;xxx&quot;</code> 时，会先对 <code>src</code> 目录下所有的 <code>.vue</code>、<code>.js</code>、<code>.ts</code> 文件执行 <code>eslint --fix</code> 命令，如果 ESLint 通过，成功 <code>commit</code>，否则终止 <code>commit</code>。</p>
<hr>
<p>有时候我们明明只改动了一两个文件，却要对所有的文件执行 <code>eslint --fix</code>。
假如这是一个历史项目，我们在中途配置了 ESLint 规则，那么在提交代码时，也会对其他未修改的 “历史” 文件都进行检查，可能会造成大量文件出现 ESLint 错误</p>
<p>可以用 lint-staged 帮助我们，lint-staged 这个工具一般结合 husky 来使用，它可以让 husky 的 <code>hook</code> 触发的命令只作用于 <code>git add</code>那些文件（即 git 暂存区的文件），而不会影响到其他文件。</p>
<h4>配置 lint-staged</h4>
<p>接下来，我们使用 lint-staged 继续优化项目。</p>
<ol>
<li>安装 lint-staged      npm i lint-staged -D</li>
<li>在 <code>package.json</code>里增加 lint-staged 配置项</li>
<li>修改 <code>.husky/pre-commit</code> hook 的触发命令为：<code>npx lint-staged</code></li>
</ol>
<hr>
<p>在 <code>package.json</code>里增加 lint-staged 配置项</p>
<pre><code>&quot;lint-staged&quot;: {
&quot;*.{vue,js,ts}&quot;: &quot;eslint --fix&quot;
},
</code></pre>
<p>这行命令表示：只对 git 暂存区的 <code>.vue</code>、<code>.js</code>、<code>.ts</code> 文件执行 <code>eslint --fix</code>。</p>
<hr>
<p>至此，husky 和 lint-staged 组合配置完成。现在我们提交代码时就会变成这样：</p>
<p>假如我们修改了 <code>scr</code> 目录下的 <code>test-1.js</code>、<code>test-2.ts</code> 和 <code>test-3.md</code> 文件，然后 <code>git add ./src/</code>，最后 <code>git commit -m &quot;test...&quot;</code>，这时候就会只对 <code>test-1.js</code>、<code>test-2.ts</code> 这两个文件执行 <code>eslint --fix</code>。如果 ESLint 通过，成功提交，否则终止提交。从而保证了我们提交到 Git 仓库的代码都是规范的。</p>
<h2>提交规范</h2>
<p>在提交代码这个环节，也存在一种情况：不能保证每个人对提交信息的准确描述
如果 <code>git commit</code> 的描述信息精准，在后期维护和 Bug 处理时会变得有据可查，项目开发周期内还可以根据规范的提交信息快速生成开发日志，从而方便我们追踪项目和把控进度。</p>
<h3>Angular 的commit message 格式规范</h3>
<p>commit message 由 Header、Body、Footer 组成。</p>
<pre><code>&lt;Header&gt;
&lt;Body&gt;
&lt;Footer&gt;
</code></pre>
<h4>Header</h4>
<p>Header 部分包括三个字段 type（必需）、scope（可选）和 subject（必需）。</p>
<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
</code></pre>
<h5>type</h5>
<p>type 用于说明 commit 的提交类型（必须是以下几种之一）。</p>
<table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">feat</td><td align="left">新增一个功能</td></tr><tr><td align="left">fix</td><td align="left">修复一个 Bug</td></tr><tr><td align="left">docs</td><td align="left">文档变更</td></tr><tr><td align="left">style</td><td align="left">代码格式（不影响功能，例如空格、分号等格式修正）</td></tr><tr><td align="left">refactor</td><td align="left">代码重构</td></tr><tr><td align="left">perf</td><td align="left">改善性能</td></tr><tr><td align="left">test</td><td align="left">测试</td></tr><tr><td align="left">build</td><td align="left">变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td align="left">ci</td><td align="left">更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td align="left">chore</td><td align="left">变更构建流程或辅助工具</td></tr><tr><td align="left">revert</td><td align="left">代码回退</td></tr></tbody></table>
<h5>scope</h5>
<p>scope 用于指定本次 commit 影响的范围。scope 依据项目而定，例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。（scope 可省略）</p>
<h5>subject</h5>
<p>subject 是本次 commit 的简洁描述，长度约定在 50 个字符以内，通常遵循以下几个规范：</p>
<ul>
<li>用动词开头，第一人称现在时表述，例如：change 代替 changed 或 changes</li>
<li>第一个字母小写</li>
<li>结尾不加句号（.）</li>
</ul>
<h4>Body</h4>
<p>body 是对本次 commit 的详细描述，可以分成多行。（body 可省略）
跟 subject 类似，用动词开头，body 应该说明修改的原因和更改前后的行为对比。</p>
<h4>Footer</h4>
<p>如果本次提交的代码是突破性的变更或关闭缺陷，则 Footer 必需，否则可以省略。</p>
<ul>
<li>突破性的变更
当前代码与上一个版本有突破性改变，则 Footer 以 BREAKING CHANGE 开头，后面是对变动的描述、以及变动的理由。</li>
<li>关闭缺陷
如果当前提交是针对特定的 issue，那么可以在 Footer 部分填写需要关闭的单个 issue 或一系列 issues。</li>
</ul>
<h4>参考例子</h4>
<ul>
<li>
<p>fix</p>
<pre><code>fix(compile): couple of unit tests for IE9

Older IEs serialize html uppercased, but IE9 does not...
Would be better to expect case insensitive, unfortunately jasmine does
not allow to user regexps for throw expectations.

Closes #392
Breaks foo.bar api, foo.baz should be used instead

</code></pre>
</li>
</ul>
<h3>集成 Commitizen 实现规范提交</h3>
<p>我们使用 Commitizen 工具来帮助我们自动生成 commit message 格式，从而实现规范提交。
Commitizen 是一个帮助撰写规范 commit message 的工具。它有一个命令行工具 cz-cli。</p>
<ul>
<li>安装 Commitizen npm install commitizen -D</li>
</ul>
<h4>初始化项目</h4>
<p>成功安装 Commitizen 后，我们用 <strong>cz-conventional-changelog</strong> 适配器来初始化项目：</p>
<pre><code>npx commitizen init cz-conventional-changelog --save-dev --save-exact
</code></pre>
<p>这行命令做了两件事：</p>
<ul>
<li>安装 cz-conventional-changelog 到开发依赖（devDependencies）</li>
<li>在 <code>package.json</code> 中增加了 <code>config.commitizen</code><pre><code>&quot;config&quot;: {
  &quot;commitizen&quot;: {
    &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;
  }
}

</code></pre>
</li>
</ul>
<h4>使用 Commitizen</h4>
<p>以前我们提交代码都是 <code>git commit -m &quot;xxx&quot;</code>，现在改为 <code>git cz</code>，然后按照终端操作提示，逐步填入信息，就能自动生成规范的 commit message。</p>
<h4>自定义配置提交说明</h4>
<p><code>git cz</code> 终端操作提示都是英文的，如果想改成中文的或者自定义这些配置选项，我们使用 <strong>cz-customizable</strong> 适配器。</p>
<h5>cz-customizable 初始化项目</h5>
<p>运行如下命令使用 cz-customizable 初始化项目，注意之前已经初始化过一次，这次再初始化，需要加 <code>--force</code> 覆盖。</p>
<pre><code>npx commitizen init cz-customizable --save-dev --save-exact --force
</code></pre>
<p>这行命令做了两件事：</p>
<ul>
<li>
<p>安装 cz-customizable 到开发依赖（devDependencies）</p>
<pre><code>&quot;devDependencies&quot;: {
  ...
  &quot;cz-customizable&quot;: &quot;^6.3.0&quot;,
  ...
},

</code></pre>
</li>
<li>
<p>修改 <code>package.json</code> 中的 <code>config.commitizen</code> 字段为：</p>
<pre><code>&quot;config&quot;: {
  &quot;commitizen&quot;: {
    &quot;path&quot;: &quot;./node_modules/cz-customizable&quot;
  }
}

</code></pre>
</li>
</ul>
<h5>使用 cz-customizable</h5>
<p>在项目根目录下创建 <code>.cz-config.js</code> 文件，然后按照官方提供的<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fleoforfree%2Fcz-customizable%2Fblob%2Fmaster%2Fcz-config-EXAMPLE.js" title="https://github.com/leoforfree/cz-customizable/blob/master/cz-config-EXAMPLE.js">示例</a>来配置。</p>
<p>在本项目中我们修改成中文：</p>
<pre><code>module.exports = {
  // type 类型（定义之后，可通过上下键选择）
  types: [
    { value: 'feat', name: 'feat:     新增功能' },
    { value: 'fix', name: 'fix:      修复 bug' },
    { value: 'docs', name: 'docs:     文档变更' },
    { value: 'style', name: 'style:    代码格式（不影响功能，例如空格、分号等格式修正）' },
    { value: 'refactor', name: 'refactor: 代码重构（不包括 bug 修复、功能新增）' },
    { value: 'perf', name: 'perf:     性能优化' },
    { value: 'test', name: 'test:     添加、修改测试用例' },
    { value: 'build', name: 'build:    构建流程、外部依赖变更（如升级 npm 包、修改 webpack 配置等）' },
    { value: 'ci', name: 'ci:       修改 CI 配置、脚本' },
    { value: 'chore', name: 'chore:    对构建过程或辅助工具和库的更改（不影响源文件、测试用例）' },
    { value: 'revert', name: 'revert:   回滚 commit' }
  ],

  // scope 类型（定义之后，可通过上下键选择）
  scopes: [
    ['components', '组件相关'],
    ['hooks', 'hook 相关'],
    ['utils', 'utils 相关'],
    ['element-ui', '对 element-ui 的调整'],
    ['styles', '样式相关'],
    ['deps', '项目依赖'],
    ['auth', '对 auth 修改'],
    ['other', '其他修改'],
    // 如果选择 custom，后面会让你再输入一个自定义的 scope。也可以不设置此项，把后面的 allowCustomScopes 设置为 true
    ['custom', '以上都不是？我要自定义']
  ].map(([value, description]) =&gt; {
    return {
      value,
      name: `${value.padEnd(30)} (${description})`
    }
  }),

  // 是否允许自定义填写 scope，在 scope 选择的时候，会有 empty 和 custom 可以选择。
  // allowCustomScopes: true,

  // allowTicketNumber: false,
  // isTicketNumberRequired: false,
  // ticketNumberPrefix: 'TICKET-',
  // ticketNumberRegExp: '\\d{1,5}',


  // 针对每一个 type 去定义对应的 scopes，例如 fix
  /*
  scopeOverrides: {
    fix: [
      { name: 'merge' },
      { name: 'style' },
      { name: 'e2eTest' },
      { name: 'unitTest' }
    ]
  },
  */

  // 交互提示信息
  messages: {
    type: '确保本次提交遵循 Angular 规范！\n选择你要提交的类型：',
    scope: '\n选择一个 scope（可选）：',
    // 选择 scope: custom 时会出下面的提示
    customScope: '请输入自定义的 scope：',
    subject: '填写简短精炼的变更描述：\n',
    body:
      '填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行：\n',
    breaking: '列举非兼容性重大的变更（可选）：\n',
    footer: '列举出所有变更的 ISSUES CLOSED（可选）。 例如: #31, #34：\n',
    confirmCommit: '确认提交？'
  },

  // 设置只有 type 选择了 feat 或 fix，才询问 breaking message
  allowBreakingChanges: ['feat', 'fix'],

  // 跳过要询问的步骤
  // skipQuestions: ['body', 'footer'],

  // subject 限制长度
  subjectLimit: 100
  breaklineChar: '|', // 支持 body 和 footer
  // footerPrefix : 'ISSUES CLOSED:'
  // askForBreakingChangeFirst : true,
}

</code></pre>
<p>建议大家结合项目实际情况来自定义配置提交规则，例如很多时候我们不需要写长描述，公司内部的代码仓库也不需要管理 issue，那么可以把询问 body 和 footer 的步骤跳过（在 <code>.cz-config.js</code> 中修改成 <code>skipQuestions: ['body', 'footer']</code>）。</p>
<h3>集成 commitlint 验证提交规范</h3>
<p>提交代码这个环节，我们也增加一个限制：<strong>只让符合 Angular 规范的 commit message 通过</strong>
我们借助 @commitlint/config-conventional 和 @commitlint/cli 来实现。</p>
<h4>安装 commitlint</h4>
<p>安装 @commitlint/config-conventional 和 @commitlint/cli</p>
<pre><code>npm i @commitlint/config-conventional @commitlint/cli -D
</code></pre>
<h4>配置 commitlint</h4>
<ul>
<li>创建 commitlint.config.js 文件 在项目根目录下创建 <code>commitlint.config.js</code> 文件，并填入以下内容：</li>
</ul>
<pre><code>module.exports = { extends: ['@commitlint/config-conventional'] }
</code></pre>
<ul>
<li>使用 husky 的 <code>commit-msg</code> hook 触发验证提交信息的命令<br>
我们使用 husky 命令在 <code>.husky</code> 目录下创建 <code>commit-msg</code> 文件，并在此执行 commit message 的验证命令。</li>
</ul>
<pre><code>npx husky add .husky/commit-msg &quot;npx --no-install commitlint --edit $1&quot;
</code></pre>
<p>因为已在项目中集成 commitizen，建议大家用 <code>git cz</code> 来代替 <code>git commit</code> 提交代码，可以保证提交信息规范。</p>
<h2>单元测试</h2>
<h3>安装核心依赖</h3>
<p>我们使用 Vue 官方提供的 <strong>vue-test-utils</strong> 和社区流行的测试工具 <strong>jest</strong> 来进行 Vue 组件的单元测试。</p>
<ul>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-test-utils-next" title="https://github.com/vuejs/vue-test-utils-next">vue-test-utils</a></strong> The next iteration of Vue Test Utils. It targets Vue 3.</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fjest" title="https://github.com/facebook/jest">jest</a></strong> Delightful JavaScript Testing.</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvue-jest" title="https://github.com/vuejs/vue-jest">vue-jest</a></strong> Jest Vue transformer</li>
<li><strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fkulshekhar%2Fts-jest" title="https://github.com/kulshekhar/ts-jest">ts-jest</a></strong> A Jest transformer with source map support that lets you use Jest to test projects written in TypeScript.</li>
</ul>
<hr>
<p>安装这些工具为开发依赖（devDependencies）：</p>
<pre><code>npm i @vue/test-utils@next jest vue-jest@next ts-jest -D

</code></pre>
<h3>创建 jest 配置文件</h3>
<p>在项目根目录下新建 <code>jest.config.js</code> 文件：</p>
<pre><code>module.exports = {
  moduleFileExtensions: ['vue', 'js', 'ts'],
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  transform: {
    '^.+\\.vue$': 'vue-jest', // vue 文件用 vue-jest 转换
    '^.+\\.ts$': 'ts-jest' // ts 文件用 ts-jest 转换
  },
  // 匹配 __tests__ 目录下的 .js/.ts 文件 或其他目录下的 xx.test.js/ts xx.spec.js/ts
  testRegex: '(/__tests__/.*|(\\.|/)(test|spec))\\.(ts)$'
}

</code></pre>
<h3>创建单元测试文件</h3>
<p>在上面的 <code>jest.config.js</code> 文件中，我们配置只匹配 <code>__tests__</code> 目录下的任意 <code>.ts</code> 文件或其他目录下的 <code>xx.test.ts</code>/<code>xx.spec.ts</code> 文件进行单元测试。</p>
<p>这里，我们在项目根目录下创建 <code>tests</code> 目录来存储单元测试文件</p>
<pre><code>├── src/
└── tests/                           // 单元测试目录
    ├── Test.spec.ts                 // Test 组件测试

</code></pre>
<ul>
<li>Test.vue</li>
</ul>
<pre><code>&lt;template&gt;
  &lt;div class=&quot;test-container page-container&quot;&gt;
    &lt;div class=&quot;page-title&quot;&gt;Unit Test Page&lt;/div&gt;
    &lt;p&gt;count is: {{ count }}&lt;/p&gt;
    &lt;button @click=&quot;increment&quot;&gt;increment&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
  import { defineComponent, ref } from 'vue'
  export default defineComponent({
    name: 'Vuex',
    setup() {
      const count = ref&lt;number&gt;(0)
      const increment = () =&gt; {
        count.value += 1
      }
      return { count, increment }
    }
  })
&lt;/script&gt;

</code></pre>
<ul>
<li><code>Test.spec.ts</code><pre><code>import { mount } from '@vue/test-utils'
import Test from '../src/views/Test.vue'

test('Test.vue', async () =&gt; {
  const wrapper = mount(Test)
  expect(wrapper.html()).toContain('Unit Test Page')
  expect(wrapper.html()).toContain('count is: 0')
  await wrapper.find('button').trigger('click')
  expect(wrapper.html()).toContain('count is: 1')
})
</code></pre>
</li>
</ul>
<h3>集成 @types/jest</h3>
<p>我们使用 VSCode / WebStrom / IDEA 等编辑器时，在单元测试文件中，IDE 会提示某些方法不存在（如 <code>test</code>、<code>describe</code>、<code>it</code>、<code>expect</code>等）
安装 @types/jest 即可解决。 npm i @types/jest -D</p>
<hr>
<p>TypeScript 的编译器也会提示 jest 的方法和类型找不到，我们还需把 @types/jest 添加根目录下的 <code>ts.config.json</code>（TypeScript 配置文件）中：</p>
<pre><code>{
  &quot;compilerOptions&quot;: {
    ...
    &quot;types&quot;: [&quot;vite/client&quot;, &quot;jest&quot;]
  },
}

</code></pre>
<h3>添加 eslint-plugin-jest</h3>
<p>因为我们在项目中集成了 ESLint，我们还需要在 ESLint 中增加 <strong>eslint-plugin-jest</strong> 插件来解除对 jest 的校验。</p>
<ul>
<li>安装 eslint-plugin-jestnpm i eslint-plugin-jest -D</li>
<li>添加 eslint-plugin-jest 到 ESLint 配置文件 <code>.eslintrc.js</code> 中<pre><code>module.exports = {
  ...
  extends: [
    ...
    'plugin:jest/recommended'
  ],
  ...
}

</code></pre>
</li>
</ul>
<h3>执行单元测试</h3>
<p>在根目录下 <code>package.json</code> 文件的 <code>scripts</code> 中，添加一条单元测试命令： <code>&quot;test&quot;: &quot;jest&quot;</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66354199386b431088db0593f34b88e6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p>
<p>执行命令 <code>npm run test</code> 即可进行单元测试，jest 会根据 <code>jest.config.js</code> 配置文件去查找 <code>__tests__</code> 目录下的 <code>.ts</code> 文件或其他任意目录下的 <code>.spec.ts</code> 和 <code>.test.ts</code> 文件，然后执行单元测试方法。</p>
<p>你可以在 <code>jest.config.js</code> 配置文件中，自由配置单元测试文件的目录。</p>
<h3>单元测试约束</h3>
<p>前面，我们使用 husky 在 Git 的 <code>pre-commit</code> 和 <code>commit-msg</code> 阶段分别约束代码风格规范和提交信息规范。
这一步，我们在 <code>pre-push</code> 阶段进行单元测试，只有单元测试全部通过才让代码 <code>push</code> 到远端仓库，否则终止 <code>push</code>。</p>
<p>使用 husky 命令在 <code>.husky</code> 目录下自动创建 <code>pre-push</code> hook 文件，并在此执行单元测试命令 <code>npm run test</code>。</p>
<pre><code>npx husky add .husky/pre-push &quot;npm run test $1&quot;
</code></pre>
<p>现在，我们在 <code>git push</code> 时就能先进行单元测试了，只有单元测试全部通过，才能成功 <code>push</code>。</p>
<h2>自动部署</h2>
<p>本项目是要搭建一套规范的前端工程化环境，为此我们使用 CI（Continuous Integration 持续集成）来完成项目最后的部署工作。
这里，我们使用 GitHub Actions。</p>
<h3>什么是 GitHub Actions</h3>
<p>GitHub Actions 是 GitHub 的持续集成服务，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器、发布到第三方服务等等，GitHub 把这些操作称为 actions。</p>
<h3>配置 GitHub Actions</h3>
<h4>创建 GitHub 仓库</h4>
<p>因为 GitHub Actions 只对 GitHub 仓库有效，所以我们<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnew" title="https://github.com/new">创建 GitHub 仓库</a>来托管项目代码。
我们用：</p>
<ul>
<li><code>master</code> 分支存储项目源代码</li>
<li><code>gh-pages</code> 分支存储打包后的静态文件</li>
</ul>
<blockquote>
<p><code>gh-pages</code> 分支，是 GitHub Pages 服务的固定分支，可以通过 HTTP 的方式访问到这个分支的静态文件资源。</p>
</blockquote>
<h4>创建 GitHub Token</h4>
<p>创建一个有 <strong>repo</strong> 和 <strong>workflow</strong> 权限的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsettings%2Ftokens%2Fnew" title="https://github.com/settings/tokens/new">GitHub Token</a>
注意：新生成的 Token 只会显示一次，保存起来，后面要用到。如有遗失，重新生成即可。</p>
<h4>在仓库中添加 secret</h4>
<p>将上面新创建的 Token 添加到 GitHub 仓库的 <code>Secrets</code> 里，并将这个新增的 <code>secret</code> 命名为 <code>VUE3_DEPLOY</code> （名字无所谓，看你喜欢）。</p>
<p>步骤：仓库 -&gt; <code>settings</code> -&gt; <code>Secrets</code> -&gt; <code>New repository secret</code>。
新创建的 secret <code>VUE3_DEPLOY</code> 在 Actions 配置文件中要用到，两个地方需保持一致！</p>
<h4>创建 Actions 配置文件</h4>
<ol>
<li>在项目根目录下创建 <code>.github</code> 目录。</li>
<li>在 <code>.github</code> 目录下创建 <code>workflows</code> 目录。</li>
<li>在 <code>workflows</code> 目录下创建 <code>deploy.yml</code> 文件。
<code>deploy.yml</code> 文件的内容：</li>
</ol>
<pre><code>name: deploy

on:
  push:
    branches: [master] # master 分支有 push 时触发

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Setup Node.js v14.x
        uses: actions/setup-node@v1
        with:
          node-version: '14.x'

      - name: Install
        run: npm install # 安装依赖

      - name: Build
        run: npm run build # 打包

      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3 # 使用部署到 GitHub pages 的 action
        with:
          publish_dir: ./dist # 部署打包后的 dist 目录
          github_token: ${{ secrets.VUE3_DEPLOY }} # secret 名
          user_name: ${{ secrets.MY_USER_NAME }}
          user_email: ${{ secrets.MY_USER_EMAIL }}
          commit_message: Update Vite2.x + Vue3.x + TypeScript Starter # 部署时的 git 提交信息，自由填写

</code></pre>
<h3>自动部署触发原理</h3>
<p>当有新提交的代码 <code>push</code> 到 GitHub 仓库时，就会触发 GitHub Actions，在 GitHub 服务器上执行 Action 配置文件里面的命令，例如：<strong>安装依赖</strong>、<strong>项目打包</strong>等，然后将打包好的静态文件部署到 GitHub Pages 上，最后，我们就能通过域名访问了。</p>
<h1> </h1>
<h1>一次弄懂 Event Loop（彻底解决此类面试问题）</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844903764202094606#heading-36">juejin.cn</a></p>
</blockquote>
<h3>MicroTask（微任务）</h3>
<ul>
<li><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code>（具体使用方式查看<a href="https://link.juejin.cn?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fdom%2Fmutationobserver.html" title="http://javascript.ruanyifeng.com/dom/mutationobserver.html">这里</a>）</li>
</ul>
<h2>浏览器中的 Event Loop</h2>
<p><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈 (执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p>
<h3>同步任务和异步任务</h3>
<p><code>Javascript</code>单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>
同步任务会在调用栈中按照顺序等待主线程依次执行，
异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。
<img src="./Pasted image 20230814132849.png" /></p>
<h3>事件循环的进程模型</h3>
<ul>
<li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即<code>null</code>，则执行跳转到微任务（<code>MicroTask</code>）的执行步骤。</li>
<li>将事件循环中的任务设置为已选择任务。执行任务。</li>
<li>执行任务后将事件循环中当前运行任务设置为 null。</li>
<li>将已经运行完成的任务从任务队列中删除。</li>
<li>microtasks 步骤：进入 microtask 检查点。</li>
<li>更新界面渲染。</li>
<li>返回第一步。</li>
</ul>
<h3>执行进入 microtask 检查点时，用户代理会执行以下步骤：</h3>
<ul>
<li>设置 microtask 检查点标志为 true。</li>
<li>当事件循环<code>microtask</code>执行不为空时：选择一个最先进入的<code>microtask</code>队列的<code>microtask</code>，将事件循环的<code>microtask</code>设置为已选择的<code>microtask</code>，运行<code>microtask</code>，</li>
<li>运行完之后将已经执行完成的<code>microtask</code>为<code>null</code>，移出<code>microtask</code>中的<code>microtask</code>。</li>
<li>清理 IndexDB 事务</li>
<li>设置进入 microtask 检查点的标志为 false。</li>
</ul>
<hr>
<p>执行栈在执行完<strong>同步任务</strong>后，查看<strong>执行栈</strong>是否为空，如果执行栈为空，就会去检查<strong>微任务</strong> (<code>microTask</code>) 队列是否为空，如果为空的话，就执行<code>Task</code>（宏任务），否则就一次性执行完所有微任务。<br>
每次单个<strong>宏任务</strong>执行完毕后，检查<strong>微任务</strong> (<code>microTask</code>) 队列是否为空，如果不为空的话，会按照<strong>先入先</strong>出的规则全部执行完<strong>微任务</strong> (<code>microTask</code>) 后，设置<strong>微任务</strong> (<code>microTask</code>) 队列为<code>null</code>，然后再执行<strong>宏任务</strong>，如此循环。</p>
<h2>再举个例子</h2>
<pre><code>console.log('script start')

async function async1() {
  await async2()
  console.log('async1 end')
}
async function async2() {
  console.log('async2 end') 
  //await async2相当于 promise，这里算是new promise（async2()，属于同步代码
}
async1()

setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(resolve =&gt; {
  console.log('Promise')
  resolve()
})
  .then(function() {
    console.log('promise1')
  })
  .then(function() {
    console.log('promise2')
  })

console.log('script end')
</code></pre>
<ul>
<li>在老版本版本以下，先执行<code>promise1</code>和<code>promise2</code>，再执行<code>async1</code>。</li>
<li>在 73 版本，先执行<code>async1</code>再执行<code>promise1</code>和<code>promise2</code>。</li>
</ul>
<hr>
<p>每次我们使用 <code>await</code>, 解释器都创建一个 <code>promise</code> 对象，然后把剩下的 <code>async</code> 函数中的操作放到 <code>then</code> 回调函数中。</p>
<p>**主要原因是因为在谷歌 (金丝雀)73 版本中更改了规范，区别在于<code>RESOLVE(thenable)</code>和之间的区别<code>Promise.resolve(thenable)</code>。</p>
<hr>
<h3><strong>在老版本中</strong></h3>
<ul>
<li>首先，传递给 <code>await</code> 的值被包裹在一个 <code>Promise</code> 中。然后，处理程序附加到这个包装的 <code>Promise</code>，以便在 <code>Promise</code> 变为 <code>fulfilled</code> 后恢复该函数，并且暂停执行异步函数，一旦 <code>promise</code> 变为 <code>fulfilled</code>，恢复异步函数的执行。</li>
<li>每个 <code>await</code> 引擎必须创建两个额外的 Promise（即使右侧已经是一个 <code>Promise</code>）并且它需要至少三个 <code>microtask</code> 队列 <code>ticks</code>（<code>tick</code>为系统的相对时间单位，也被称为系统的时基，来源于定时器的周期性中断（输出脉冲），一次中断表示一个<code>tick</code>，也被称做一个 “时钟滴答”、时标。）。</li>
</ul>
<h3><strong>引用贺老师知乎上的一个例子</strong></h3>
<pre><code>async function f() {
  await p
  console.log('ok')
}
</code></pre>
<p>简化理解为：</p>
<pre><code>function f() {
  return RESOLVE(p).then(() =&gt; {
    console.log('ok')
  })
}
</code></pre>
<ul>
<li>如果 <code>RESOLVE(p)</code> 对于 <code>p</code> 为 <code>promise</code> 直接返回 <code>p</code> 的话，那么 <code>p</code>的 <code>then</code> 方法就会被马上调用，其回调就立即进入 <code>job</code> 队列。</li>
<li>而如果 <code>RESOLVE(p)</code> 严格按照标准，应该是产生一个新的 <code>promise</code>，尽管该 <code>promise</code>确定会 <code>resolve</code> 为 <code>p</code>，但这个过程本身是异步的，也就是现在进入 <code>job</code> 队列的是新 <code>promise</code> 的 <code>resolve</code>过程，所以该 <code>promise</code> 的 <code>then</code> 不会被立即调用，而要等到当前 <code>job</code> 队列执行到前述 <code>resolve</code> 过程才会被调用，然后其回调（也就是继续 <code>await</code> 之后的语句）才加入 <code>job</code> 队列，所以时序上就晚了。</li>
</ul>
<h3><strong>谷歌（金丝雀）73 版本中</strong></h3>
<ul>
<li>使用对<code>PromiseResolve</code>的调用来更改<code>await</code>的语义，以减少在公共<code>awaitPromise</code>情况下的转换次数。</li>
<li>如果传递给 <code>await</code> 的值已经是一个 <code>Promise</code>，那么这种优化避免了再次创建 <code>Promise</code> 包装器，在这种情况下，我们从最少三个 <code>microtick</code> 到只有一个 <code>microtick</code>。</li>
</ul>
<h2>NodeJS 的 Event Loop</h2>
<p><code>Node</code>中的<code>Event Loop</code>是基于<code>libuv</code>实现的，而<code>libuv</code>是 <code>Node</code> 的新跨平台抽象层，libuv 使用异步，事件驱动的编程方式，核心是提供<code>i/o</code>的事件循环和异步回调。libuv 的<code>API</code>包含有时间，非阻塞的网络，异步文件操作，子进程等等。 <code>Event Loop</code>就是在<code>libuv</code>中实现的。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/18/16860f8f8f7f053d~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt=""></p>
<h3><code>Node</code>的<code>Event loop</code>一共分为 6 个阶段，每个细节具体如下：</h3>
<ul>
<li><code>timers</code>: 执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>。</li>
<li><code>pending callback</code>: 上一轮循环中少数的<code>callback</code>会放在这一阶段执行。</li>
<li><code>idle, prepare</code>: 仅在内部使用。</li>
<li><code>poll</code>: 最重要的阶段，执行<code>pending callback</code>，在适当的情况下回阻塞在这个阶段。</li>
<li><code>check</code>: 执行<code>setImmediate</code>(<code>setImmediate()</code>是将事件插入到事件队列尾部，主线程和事件队列的函数执行完成之后立即执行<code>setImmediate</code>指定的回调函数) 的<code>callback</code>。</li>
<li><code>close callbacks</code>: 执行<code>close</code>事件的<code>callback</code>，例如<code>socket.on('close'[,fn])</code>或者<code>http.server.on('close, fn)</code>。</li>
</ul>
<p>具体细节如下：</p>
<h3>timers</h3>
<p>执行<code>setTimeout</code>和<code>setInterval</code>中到期的<code>callback</code>，执行这两者回调需要设置一个毫秒数，理论上来说，应该是时间一到就立即执行 callback 回调，但是由于<code>system</code>的调度可能会延时，达不到预期时间。</p>
<hr>
<p>timers官网文档解释延迟的例子：</p>
<p>当进入事件循环时，它有一个空队列（<code>fs.readFile()</code>尚未完成），因此定时器将等待剩余毫秒数，当到达 95ms 时，<code>fs.readFile()</code>完成读取文件并且其完成需要 10 毫秒的回调被添加到轮询队列并执行。<br>
当回调结束时，队列中不再有回调，因此事件循环将看到已达到最快定时器的<strong>阈值</strong>，然后回到 <strong>timers 阶段</strong>以执行定时器的回调。</p>
<pre><code>const fs = require('fs');

function someAsyncOperation(callback) {
  // Assume this takes 95ms to complete
  fs.readFile('/path/to/file', callback);
}

const timeoutScheduled = Date.now();

setTimeout(() =&gt; {
  const delay = Date.now() - timeoutScheduled;

  console.log(`${delay}ms have passed since I was scheduled`);
}, 100);


// do someAsyncOperation which takes 95 ms to complete
someAsyncOperation(() =&gt; {
  const startCallback = Date.now();

  // do something that will take 10ms...
  while (Date.now() - startCallback &lt; 10) {
    // do nothing
  }
});
</code></pre>
<h3>pending callbacks</h3>
<p>此阶段执行某些系统操作（例如 TCP 错误类型）的回调。 例如，如果<code>TCP socket ECONNREFUSED</code>在尝试 connect 时 receives，则某些 * nix 系统希望等待报告错误。 这将在<code>pending callbacks</code>阶段执行。</p>
<h3>poll</h3>
<p><strong>该 poll 阶段有两个主要功能：</strong></p>
<ul>
<li>执行<code>I/O</code>回调。</li>
<li>处理轮询队列中的事件。</li>
</ul>
<hr>
<p><strong>当事件循环进入<code>poll</code>阶段并且在<code>timers</code>中没有可以执行定时器时，将发生以下两种情况之一</strong></p>
<p>如果<code>poll</code>队列不为空，则事件循环将遍历其同步执行它们的<code>callback</code>队列，直到队列为空，或者达到<code>system-dependent</code>（系统相关限制）。</p>
<p><strong>如果<code>poll</code>队列为空，则会发生以下两种情况之一</strong></p>
<ul>
<li>如果有<code>setImmediate()</code>回调需要执行，则会立即停止执行<code>poll</code>阶段并进入执行<code>check</code>阶段以执行回调。</li>
<li>如果没有<code>setImmediate()</code>回到需要执行，poll 阶段将等待<code>callback</code>被添加到队列中，然后立即执行。</li>
</ul>
<hr>
<p><strong>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</strong></p>
<h3>check</h3>
<p><strong>此阶段允许人员在 poll 阶段完成后立即执行回调。</strong><br>
如果<code>poll</code>阶段闲置并且<code>script</code>已排队<code>setImmediate()</code>，则事件循环到达 check 阶段执行而不是继续等待。</p>
<hr>
<p><code>setImmediate()</code>实际上是一个特殊的计时器，它在事件循环的一个单独阶段运行。
它使用<code>libuv API</code>来调度在<code>poll</code>阶段完成后执行的回调。</p>
<p>通常，当代码被执行时，事件循环最终将达到<code>poll</code>阶段，它将等待传入连接，请求等。<br>
但是，如果已经调度了回调<code>setImmediate()</code>，并且轮询阶段变为空闲，则它将结束并且到达<code>check</code>阶段，而不是等待<code>poll</code>事件。</p>
<pre><code>console.log('start')
setTimeout(() =&gt; {
  console.log('timer1')
  Promise.resolve().then(function() {
    console.log('promise1')
  })
}, 0)
setTimeout(() =&gt; {
  console.log('timer2')
  Promise.resolve().then(function() {
    console.log('promise2')
  })
}, 0)
Promise.resolve().then(function() {
  console.log('promise3')
})
console.log('end')
</code></pre>
<p>如果<code>node</code>版本为<code>v11.x</code>， 其结果与浏览器一致。</p>
<pre><code>start
end
promise3
timer1
promise1
timer2
promise2
</code></pre>
<p>如果 v10 版本上述结果存在两种情况：</p>
<ul>
<li>如果 time2 定时器已经在执行队列中了</li>
</ul>
<pre><code>start
end
promise3
timer1
timer2
promise1
promise2
</code></pre>
<ul>
<li>如果 time2 定时器没有在执行对列中，执行结果为</li>
</ul>
<pre><code>start
end
promise3
timer1
promise1
timer2
promise2
</code></pre>
<h2>setImmediate() 的 setTimeout() 的区别</h2>
<p><strong><code>setImmediate</code>和<code>setTimeout()</code>是相似的，但根据它们被调用的时间以不同的方式表现。</strong></p>
<ul>
<li><code>setImmediate()</code>设计用于在当前<code>poll</code>阶段完成后 check 阶段执行脚本 。</li>
<li><code>setTimeout()</code> 安排在经过最小（ms）后运行的脚本，在<code>timers</code>阶段执行。</li>
</ul>
<h3>setImmediate() 的 setTimeout() 的区别例子</h3>
<p>**执行定时器的顺序将根据调用它们的上下文而有所不同。 如果从主模块中调用两者，那么时间将受到进程性能的限制。**<strong>其结果也不一致</strong>
<strong>如果在<code>I / O</code>周期内移动两个调用，则始终首先执行立即回调：</strong></p>
<pre><code>const fs = require('fs');

fs.readFile(__filename, () =&gt; {
  setTimeout(() =&gt; {
    console.log('timeout');
  }, 0);
  setImmediate(() =&gt; {
    console.log('immediate');
  });
});
</code></pre>
<p>其结果可以确定一定是<code>immediate =&gt; timeout</code>。<br>
主要原因是在<code>I/O阶段</code>读取文件后，事件循环会先进入<code>poll</code>阶段，发现有<code>setImmediate</code>需要执行，会立即进入<code>check</code>阶段执行<code>setImmediate</code>的回调。</p>
<p>然后再进入<code>timers</code>阶段，执行<code>setTimeout</code>，打印<code>timeout</code>。</p>
<pre><code>┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre>
<h2>Process.nextTick()</h2>
<p><strong><code>process.nextTick()</code>虽然它是异步 API 的一部分，但未在图中显示。这是因为<code>process.nextTick()</code>从技术上讲，它不是事件循环的一部分。</strong></p>
<hr>
<p><code>process.nextTick()</code>方法将 <code>callback</code> 添加到<code>next tick</code>队列。 一旦当前事件轮询队列的任务全部完成，在<code>next tick</code>队列中的所有<code>callbacks</code>会被依次调用。</p>
<p><strong>换种理解方式：</strong>  当每个阶段完成后，如果存在 <code>nextTick</code> 队列，就会清空队列中的所有回调函数，并且优先于其他 <code>microtask</code> 执行。</p>
<h3>Process.nextTick()例子</h3>
<pre><code>let bar;

setTimeout(() =&gt; {
  console.log('setTimeout');
}, 0)

setImmediate(() =&gt; {
  console.log('setImmediate');
})
function someAsyncApiCall(callback) {
  process.nextTick(callback);
}

someAsyncApiCall(() =&gt; {
  console.log('bar', bar); // 1
});

bar = 1;
</code></pre>
<p>在 NodeV10 中上述代码执行可能有两种答案，一种为：</p>
<pre><code>bar 1
setTimeout
setImmediate
</code></pre>
<p>另一种为：</p>
<pre><code>bar 1
setImmediate
setTimeout
</code></pre>
<p>无论哪种，始终都是先执行<code>process.nextTick(callback)</code>，打印<code>bar 1</code>。</p>
<h1> </h1>
<h1>一篇文章总结 redux、react-redux、redux-saga</h1><blockquote>
<p>原文地址 <a href="https://juejin.cn/post/6844903846666321934?searchId=202307221642455A486F0EE437F36B080F">juejin.cn</a></p>
</blockquote>
<p>React 有 props 和 state:</p>
<ol>
<li>props 意味着父级分发下来的属性</li>
<li>state 意味着组件内部可以自行管理的状态，并且整个 React 没有数据向上回溯的能力，这就是 react 的单向数据流</li>
</ol>
<h2>有时候发现 <strong>React 根本无法让两个组件互相交流</strong>，使用对方的数据，react 的通过层级传递数据的这种方法是非常难受的，
redux<strong>把所有的 state 集中到组件顶部，能够灵活的将所有 state 各取所需的分发给所有的组件</strong>
redux 是的诞生是为了给 React 应用提供「可预测化的状态管理」机制。
redux简介</h2>
<p>Redux 会将**整个应用状态 (其实也就是数据) 存储到到一个地方，称为 store,这个 store 里面保存一棵状态树 (state tree)</p>
<hr>
<p>组件改变 state 的唯一方法是通过调用 store 的 dispatch 方法，触发一个 action，这个 action 被对应的 reducer 处理，于是 state 完成更新</p>
<hr>
<p>组件可以派发 (dispatch) 行为 (action) 给 store, 而不是直接通知其它组件,其它组件**可以通过订阅 store 中的状态 (state) 来刷新自己的视图</p>
<hr>
<p>流程图，方便理解 redux 的工作流程
<img src="./Pasted image 20230814120443.png" /></p>
<h2>使用步骤</h2>
<ol>
<li><strong>创建 reducer</strong></li>
<li><strong>创建 action</strong></li>
<li><strong>创建的 store，使用 createStore 方法</strong></li>
</ol>
<hr>
<ol>
<li><strong>创建 reducer</strong>
<ul>
<li>可以使用单独的一个 reducer, 也可以将多个 reducer 合并为一个 reducer，即：<code>combineReducers()</code></li>
<li>action 发出命令后将 state 放入 reucer 加工函数中，返回新的 state, 对 state 进行加工处理</li>
</ul>
</li>
</ol>
<hr>
<ol start="2">
<li><strong>创建 action</strong>
<ul>
<li>用户是接触不到 state 的，只能有 view 触发，所以，这个 action 可以理解为指令，需要发出多少动作就有多少指令</li>
<li>action 是一个对象，必须有一个叫 type 的参数，定义 action 类型</li>
</ul>
</li>
</ol>
<hr>
<ol start="3">
<li><strong>创建的 store，使用 createStore 方法</strong>
<ul>
<li>store 可以理解为有多个加工机器的总工厂</li>
<li>提供 subscribe，dispatch，getState 这些方法。</li>
</ul>
</li>
</ol>
<h2>按步骤手把手实战。</h2>
<p>上述步骤，对应的序号，我会在相关代码标出</p>
<ol>
<li><strong>创建 reducer</strong></li>
<li><strong>创建 action</strong></li>
<li><strong>创建的 store，使用 createStore 方法</strong></li>
</ol>
<pre><code>npm install redux -S // 安装

import { createStore } from 'redux' // 引入

const reducer = (state = {count: 0}, action) =&gt; {----------&gt; ⑴
  switch (action.type){
    case 'INCREASE': return {count: state.count + 1};
    case 'DECREASE': return {count: state.count - 1};
    default: return state;
  }
}

const actions = {----------&gt;⑵
  increase: () =&gt; ({type: 'INCREASE'}),
  decrease: () =&gt; ({type: 'DECREASE'})
}

const store = createStore(reducer);----------&gt;⑶

store.subscribe(() =&gt;
  console.log(store.getState())
);

store.dispatch(actions.increase()) // {count: 1}
store.dispatch(actions.increase()) // {count: 2}
store.dispatch(actions.increase()) // {count: 3}
</code></pre>
<h1>react-redux</h1>
<p>刚开始就说了，如果把 store 直接集成到 React 应用的顶层 props 里面，只要各个子组件能访问到顶层 props 就行了，比如这样：</p>
<pre><code>&lt;顶层组件 store={store}&gt;
  &lt;App /&gt;
&lt;/顶层组件&gt;
</code></pre>
<h2>这就是 react-redux。Redux 官方提供的 React 绑定库。 具有高效且灵活的特性。
<strong>React Redux 将组件区分为 容器组件 和 UI 组件</strong></h2>
<ol>
<li>容器组件会处理逻辑</li>
<li>UI 组件只负责显示和交互，内部不处理逻辑，状态完全由外部掌控</li>
</ol>
<h2>**React Redux 两个核心</h2>
<p>Provider和 connect</p>
<ul>
<li>
<h3>Provider</h3>
</li>
</ul>
<p>看我上边那个代码的<strong>顶层组件</strong>这个顶级组件就是 Provider, 一般我们都将
顶层组件包裹在 Provider 组件之中，因为这个组件的目的是让所有组件都能够访问到Redux中的数据。
store 必须作为参数放到 Provider 组件中去</p>
<pre><code>&lt;Provider store = {store}&gt;
	&lt;App /&gt;
&lt;Provider&gt;
</code></pre>
<ul>
<li>
<h3>connect</h3>
</li>
</ul>
<p>这是 react-redux 中比较难的部分</p>
<p>首先，先记住下边的这行代码：</p>
<pre><code>connect(mapStateToProps, mapDispatchToProps)(MyComponent)
</code></pre>
<h4>mapStateToProps</h4>
<p>这个单词翻译过来就是<strong>把 state 映射到 props 中去</strong> , 就是<strong>把 Redux 中的数据映射到 React 中的 props 中去。</strong></p>
<pre><code>const mapStateToProps = (state) =&gt; {
      return {
      	// prop : state.xxx  | 意思是将state中的某个数据映射到props中
        foo: state.bar
      }
    }
</code></pre>
<p>然后渲染的时候就可以使用 this.props.foo</p>
<pre><code>class Foo extends Component {
    constructor(props){
        super(props);
    }
    render(){
        return(
        	// 这样子渲染的其实就是state.bar的数据了
            &lt;div&gt;this.props.foo&lt;/div&gt;
        )
    }
}
Foo = connect()(Foo);
export default Foo;
</code></pre>
<p>然后这样就可以完成渲染了</p>
<h4>mapDispatchToProps</h4>
<p>这个单词翻译过来就是就是<strong>把各种 dispatch 也变成了 props 让你可以直接使用</strong></p>
<pre><code>const mapDispatchToProps = (dispatch) =&gt; { // 默认传递参数就是dispatch
  return {
    onClick: () =&gt; {
      dispatch({
        type: 'increatment'
      });
    }
  };
}
</code></pre>
<pre><code>class Foo extends Component {
    constructor(props){
        super(props);
    }
    render(){
        return(
        	
             &lt;button onClick = {this.props.onClick}&gt;点击increase&lt;/button&gt;
        )
    }
}
Foo = connect()(Foo);
export default Foo;
</code></pre>
<p>组件也就改成了上边这样，可以直接通过 this.props.onClick，来调用 dispatch, 这样子就不需要在代码中来进行 store.dispatch 了</p>
<p>react-redux 的基本介绍就到这里了</p>
<h1>redux-saga</h1>
<p>如果按照原始的 redux 工作流程，当组件中产生一个 action 后会直接触发 reducer 修改 state，reducer 又是一个纯函数，也就是不能再 reducer 中进行异步操作；</p>
<p><strong>而往往实际中，组件中发生的 action 后，在进入 reducer 之前需要完成一个异步任务, 比如发送 ajax 请求后拿到数据后，再进入 reducer, 显然原生的 redux 是不支持这种操作的</strong></p>
<p>这个时候急需一个中间件来处理这种业务场景，目前最优雅的处理方式自然就是 redux-saga</p>
<h2>redux-saga核心讲解</h2>
<ul>
<li>Saga 辅助函数</li>
<li>Effect Creators</li>
</ul>
<h3><strong>1、Saga 辅助函数</strong></h3>
<p>redux-saga 提供了一些辅助函数，用来在一些特定的 action 被发起到 Store 时派生任务，下面我先来讲解两个辅助函数：<code>takeEvery</code> 和 <code>takeLatest</code></p>
<h4>takeEvery</h4>
<p><strong>takeEvery 就像一个流水线的洗碗工，过来一个脏盘子就直接执行后面的洗碗函数，一旦你请了这个洗碗工他会一直执行这个工作，绝对不会停止接盘子的监听过程和触发洗盘子函数</strong></p>
<h4>takeEvery例子</h4>
<p>例如：每次点击 按钮去 Fetch 获取数据时时，我们发起一个 FETCH_REQUESTED 的 action。
我们想通过启动一个任务从服务器获取一些数据，来处理这个 action，类似于</p>
<pre><code>window.addEventLister('xxx',fn)
</code></pre>
<p>当 dispatch xxx 的时候，就会执行 fn 方法，</p>
<p>首先我们创建一个将执行异步 action 的任务 (也就是上边的 fn），然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务, 也就<strong>相当于每次触发一个名字为 FETCH_REQUESTED 的 action 就会执行上边的任务</strong></p>
<p>创建将执行异步 action 的任务</p>
<pre><code>// put：你就认为put就等于 dispatch就可以了；

// call：可以理解为实行一个异步函数,是阻塞型的，只有运行完后面的函数，才会继续往下；
// 在这里可以片面的理解为async中的await！但写法直观多了！
import { call, put } from 'redux-saga/effects'

export function* fetchData(action) {
   try {
      const apiAjax = (params) =&gt; fetch(url, params);
      const data = yield call(apiAjax);
      yield put({type: &quot;FETCH_SUCCEEDED&quot;, data});
   } catch (error) {
      yield put({type: &quot;FETCH_FAILED&quot;, error});
   }
}
</code></pre>
<p>每次触发一个名字为 FETCH_REQUESTED 的 action 就会执行上边的任务, 代码如下</p>
<pre><code>import { takeEvery } from 'redux-saga'

function* watchFetchData() {

  yield* takeEvery(&quot;FETCH_REQUESTED&quot;, fetchData)
}
</code></pre>
<p>takeEvery 函数可以使用下面的写法替换</p>
<pre><code>function* watchFetchData() {
  
   while(true){
     yield take('FETCH_REQUESTED');
     yield fork(fetchData);
   }
}
</code></pre>
<h4>takeLatest</h4>
<p>takeEvery <strong>允许多个 fetchData 实例同时启动</strong>，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束</p>
<p>如果我们<strong>只想得到最新那个请求的响应</strong>（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数</p>
<pre><code>import { takeLatest } from 'redux-saga'

function* watchFetchData() {
  yield* takeLatest('FETCH_REQUESTED', fetchData)
}
</code></pre>
<p><strong>和 takeEvery 不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消</strong></p>
<h3><strong>2、Effect Creators</strong></h3>
<p>redux-saga 框架提供了很多创建 effect 的函数，下面我们就来简单的介绍下开发中最常用的几种</p>
<ul>
<li>take(pattern)</li>
<li>put(action)</li>
<li>call(fn, ...args)</li>
<li>fork(fn, ...args)</li>
<li>select(selector, ...args)</li>
</ul>
<h4><strong>take(pattern)</strong></h4>
<p>take 函数可以理解为监听未来的 action，它创建了一个命令对象，告诉 middleware 等待一个特定的 action， Generator 会暂停，直到一个与 pattern 匹配的 action 被发起，才会继续执行下面的语句，也就是说，take 是一个阻塞的 effect</p>
<p>用法：</p>
<pre><code>function* watchFetchData() {
   while(true) {
   // 监听一个type为 'FETCH_REQUESTED' 的action的执行，直到等到这个Action被触发，才会接着执行下面的 		yield fork(fetchData)  语句
     yield take('FETCH_REQUESTED');
     yield fork(fetchData);
   }
}
</code></pre>
<h4><strong>put(action)</strong></h4>
<p>put 函数是用来发送 action 的 effect，你可以简单的<strong>把它理解成为 redux 框架中的 dispatch 函数</strong>，当 put 一个 action 后，reducer 中就会计算新的 state 并返回，<strong>注意：</strong> <strong>put 也是阻塞 effect</strong></p>
<p>用法：</p>
<pre><code>export function* toggleItemFlow() {
    let list = []
    // 发送一个type为 'UPDATE_DATA' 的Action，用来更新数据，参数为 `data：list`
    yield put({
      type: actionTypes.UPDATE_DATA,
      data: list
    })
}
</code></pre>
<h4><strong>call(fn, ...args)</strong></h4>
<p><strong>call 函数你可以把它简单的理解为就是可以调用其他函数的函数</strong>，它命令 middleware 来调用 fn 函数， args 为函数的参数，<strong>注意：</strong> <strong>fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数</strong>，call 函数也是<strong>阻塞 effect</strong></p>
<p>用法：</p>
<pre><code>export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))

export function* removeItem() {
  try {
    // 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数
    return yield call(delay, 500)
  } catch (err) {
    yield put({type: actionTypes.ERROR})
  }
}
</code></pre>
<h4><strong>fork(fn, ...args)</strong></h4>
<p>fork 函数和 call 函数很像，<strong>都是用来调用其他函数的，但是 fork 函数是非阻塞函数</strong>，也就是说，<strong>程序执行完 <code>yield fork(fn， args)</code> 这一行代码后，会立即接着执行下一行代码语句，而不会等待 fn 函数返回结果后</strong>，在执行下面的语句</p>
<p>用法：</p>
<pre><code>import { fork } from 'redux-saga/effects'

export default function* rootSaga() {
  // 下面的四个 Generator 函数会一次执行，不会阻塞执行
  yield fork(addItemFlow)
  yield fork(removeItemFlow)
  yield fork(toggleItemFlow)
  yield fork(modifyItem)
}
</code></pre>
<h4><strong>select(selector, ...args)</strong></h4>
<p>select 函数是用来指示 middleware 调用提供的选择器获取 Store 上的 state 数据，你也可以简单的把它理解为 <strong>redux 框架中获取 store 上的 state 数据一样的功能</strong> ：<code>store.getState()</code></p>
<p>用法：</p>
<pre><code>export function* toggleItemFlow() {
     // 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list
     let tempList = yield select(state =&gt; state.getTodoList.list)
}
</code></pre>
<h1>一个具体的实例</h1>
<p>**index.js **</p>
<pre><code>import React from 'react';
import ReactDOM from 'react-dom';
import {createStore, applyMiddleware} from 'redux'
import createSagaMiddleware from 'redux-saga'

import rootSaga from './sagas'
import Counter from './Counter'
import rootReducer from './reducers'

const sagaMiddleware = createSagaMiddleware() // 创建了一个saga中间件实例

// 下边这句话和下边的两行代码创建store的方式是一样的
// const store = createStore(reducers,applyMiddlecare(middlewares))

const createStoreWithMiddleware = applyMiddleware(middlewares)(createStore)
const store = createStoreWithMiddleware(rootReducer)

sagaMiddleware.run(rootSaga)

const action = type =&gt; store.dispatch({ type })

function render() {
  ReactDOM.render(
    &lt;Counter
      value={store.getState()}
      onIncrement={() =&gt; action('INCREMENT')}
      onDecrement={() =&gt; action('DECREMENT')}
      onIncrementAsync={() =&gt; action('INCREMENT_ASYNC')} /&gt;,
    document.getElementById('root')
  )
}

render()

store.subscribe(render)
</code></pre>
<p><strong>sagas.js</strong></p>
<pre><code>import { put, call, take,fork } from 'redux-saga/effects';
import { takeEvery, takeLatest } from 'redux-saga'

export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms));

function* incrementAsync() {
  // 延迟 1s 在执行 + 1操作
  yield call(delay, 1000);
  yield put({ type: 'INCREMENT' });
}

export default function* rootSaga() {
  // while(true){
  //   yield take('INCREMENT_ASYNC');
  //   yield fork(incrementAsync);
  // }

  // 下面的写法与上面的写法上等效
  yield* takeEvery(&quot;INCREMENT_ASYNC&quot;, incrementAsync)
}
</code></pre>
<p><strong>reducer.js</strong></p>
<pre><code>export default function counter(state = 0, action) {
  switch (action.type) {
    case 'INCREMENT':
      return state + 1
    case 'DECREMENT':
      return state - 1
    case 'INCREMENT_ASYNC':
      return state
    default:
      return state
  }
}
</code></pre>
<p>从上面的代码结构可以看出，redux-saga 的使用方式还是比较简单的，相比较之前的 redux 框架的 CounterApp，多了一个 sagas 的文件，reducers 文件还是之前的使用方式</p>
<h3>redux-saga 基本用法总结：</h3>
<ol>
<li><strong>使用 createSagaMiddleware 方法创建 saga 的 Middleware ，然后在创建的 redux 的 store 时，使用 applyMiddleware 函数将创建的 saga Middleware 实例绑定到 store 上，最后可以调用 saga Middleware 的 run 函数来执行某个或者某些 Middleware 。</strong></li>
<li><strong>在 saga 的 Middleware 中，可以使用 takeEvery 或者 takeLatest 等 API 来监听某个 action ，当某个 action 触发后， saga 可以使用 call 发起异步操作，操作完成后使用 put 函数触发 action ，同步更新 state ，从而完成整个 State 的更新。</strong></li>
</ol>
<h1> </h1>
<h1>前端面试查漏补缺 --前端加密</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844903781704925192?searchId=20230722164117366D8610A656DA70F4E6">juejin.cn</a></p>
</blockquote>
<h2>前端加密的意义</h2>
<p>在 HTTP 协议下，数据是明文传输，传输过程中网络嗅探可直接获取其中的数据。 如用户的密码和信用卡相关的资料，一旦被中间人获取，会给用户带来极大的安全隐患。另一方面在非加密的传输过程中，攻击者可更改数据或插入恶意的代码等。</p>
<p>前端加密的意义: 即在数据发送前将数据进行哈希或使用公钥加密。如果数据被中间人获取，拿到的则不再是明文。
其他一些优点: 例如避免后端等打印日志直接暴露明文密码, 还可以避免明文撞库等.</p>
<p><strong>没有 &quot;意义&quot;:</strong> 前端加密，其实只能<strong>防君子不能防小人。</strong> 前端系统的控制权是完全在用户手里的，也就是说，前端做什么事情，用户有完全的控制权。即使前端加密不可以防范中间人攻击, 包括 HTTPS, 因为中间还是存在着各种代理, 客户端代理, 服务端代理. 是很难做到不被劫持的.</p>
<p>这里简单说下:</p>
<ul>
<li>加密了也无法解决重放的问题，你发给服务器端的虽然是加密后的数据，但是黑客拦截之后，把加密之后的数据重发一遍，依然是验证通过的。</li>
<li>攻击者通过查看源码就能得到算法和密钥。除非你是通过做浏览器插件，将算法和密钥封装在插件中，然后加密的时候明文混淆上时间戳，这样即使黑客拦截到了请求数据，进行重放过程时，也会很快失效。</li>
</ul>
<p><strong>总结一下:</strong></p>
<ul>
<li>1, 安全是前后端都需要做的事, 不能前端加密了, 后端就不管了.</li>
<li>2,HTTPS 还是有必要的, 只要正确使用了 HTTPS 连接和服务器端安全的哈希算法，密码系统都可以是很安全的。</li>
</ul>
<h2>前端加密的几种做法</h2>
<p>• JavaScript 加密后传输 (具体可以参考后面的常见加密方法)
• 浏览器插件内进行加密传输 (这个用得不是很多, 这里暂不细究)
• Https 传输</p>
<h2>加密算法</h2>
<p>不同于哈希 (后面会提到)，加密（Encrypt）是将目标文本转换成具有不同长度的、<strong>可逆的密文</strong>。
在加密算法中又分为对称加密（symmetric encryption）和非对称加密（asymmetric encryption）。</p>
<p><strong>注意:</strong> 因为前端的透明性，<strong>对于登录密码等敏感信息, 就不要使用 JavaScript 来进行对称加密.</strong> 因为别人可以从前端得到密匙后, 可以直接对信息进行解密!</p>
<h2>哈希加密算法</h2>
<h3><strong>哈希算法（Hash）</strong></h3>
<p>基于哈希算法的特性，其适用于该场景：被保护数据仅仅用作比较验证且不需要还原成明文形式。<strong>比较常用的哈希算法是 MD5 和 SHA1 。</strong></p>
<p>我们比较熟悉的使用哈希存储数据的例子是：当我们登录某个已注册网站时，在忘记密码的情况下需要重置密码，此时网站会给你发一个随机的密码或者一个邮箱激活链接，而不是将之前的密码发给你，这就是因为哈希算法是不可逆的。</p>
<p><strong>需要注意的是</strong>：在 Web 应用中，<strong>在浏览器中使用哈希加密的同时也要在服务端上进行哈希加密
服务端哈希加密原因:</strong> 一方面因为不需要将密文解密成明文来比对密码，另一方面是一旦加密算法和密钥泄露，那么整个用户资料库就相当于明文存储了。如果前端传过来的是明文，那么在注册时将其哈希，存入数据库。登录时，将密码哈希和数据库对应的数据比对，若一致则说明密码正确。</p>
<p>现在，对于简单的哈希算法的攻击方法主要有：寻找碰撞法和穷举法。</p>
<p>所以，为了保证数据的安全，可以<strong>在哈希算法的基础上进一步的加密，常见的方法有：加盐、慢哈希、密钥哈希、XOR 等。</strong></p>
<h3><strong>加盐（Adding Salt）</strong></h3>
<p>加盐加密是一种对系统登录口令的加密方式，它实现的方式是将每一个口令同一个叫做 “盐”（salt）的 n 位随机数相关联。</p>
<p>使用 salt 加密，它的基本想法是这样的：</p>
<ul>
<li>
<ol>
<li>用户注册时，在密码上撒一些盐。生成一种味道，记住味道。</li>
</ol>
</li>
<li>
<ol start="2">
<li>用户再次登陆时，在输入的密码上撒盐，闻一闻，判断是否和原来的味道相同，相同就让你吃饭。</li>
</ol>
</li>
</ul>
<p>由于验证密码时和最初散列密码时使用相同的盐值，所以 <strong>salt 的存储在数据库</strong>。
并且<strong>这个值是由系统随机产生的</strong>，而非硬编码。这就保证了所要保护对象的机密性。</p>
<h3>加盐实例</h3>
<p><strong>注册时:</strong></p>
<ul>
<li>
<ol>
<li>用户注册，系统随机产生 salt 值。</li>
</ol>
</li>
<li>
<ol start="2">
<li>将 salt 值和密码连接起来，生产 Hash 值。</li>
</ol>
</li>
<li>
<ol start="3">
<li>将 Hash 值和 salt 值分别存储在数据库中。</li>
</ol>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc99da52c424818aef40e99b3007f3b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p><strong>登陆时:</strong></p>
<ul>
<li>
<ol>
<li>系统根据用户名找到与之对应的密码 Hash。</li>
</ol>
</li>
<li>
<ol start="2">
<li>将用户输入密码和 salt 值进行散列。</li>
</ol>
</li>
<li>
<ol start="3">
<li>判断生成的 Hash 值是否和数据库中 Hash 相同。</li>
</ol>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a19b1f2457494ebfbd695c9b519e6961~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p>
<p><strong>PS:</strong> 其实图中的这种登录也是不安全的. 原因是后面要提到的盐值复用</p>
<h3>加盐加密注意</h3>
<p>使用加盐加密时需要注意以下两点：</p>
<ul>
<li><strong>短盐值（Short Slat）</strong></li>
</ul>
<p>如果盐值太短，攻击者可以预先制作针对所有可能的盐值的查询表。例如，如果盐值只有三个 ASCII 字符，那么只有 95x95x95=857,375 种可能性，加大了被攻击的可能性。还有，不要使用可预测的盐值，比如用户名，因为针对某系统用户名是唯一的且被经常用于其他服务。</p>
<ul>
<li><strong>盐值复用（Salt Reuse）</strong>
在项目开发中，有时会遇到将盐值写死在程序里或者只有第一次是随机生成的，之后都会被重复使用，这种加盐方法是不起作用的。以登录密码为例，如果两个用户有相同的密码，那么他们就会有相同的哈希值，攻击者就可以使用反向查表法对每个哈希值进行字典攻击，使得该哈希值更容易被破解。</li>
</ul>
<p><strong>所以正确的加盐方法如下：</strong>
（1）盐值应该使用加密的安全伪随机数生成器（ Cryptographically Secure Pseudo-Random Number Generator，CSPRNG ）产生，比如 C 语言的 rand() 函数，这样生成的随机数高度随机、完全不可预测；
（2）盐值混入目标文本中，一起使用标准的加密函数进行加密；</p>
<p>（3）盐值要足够长（经验表明：盐值至少要跟哈希函数的输出一样长）且永不重复；</p>
<p>（4）盐值最好由服务端提供，前端取值使用。</p>
<h3><strong>慢哈希函数（Slow Hash Function）</strong></h3>
<p>顾名思义，慢哈希函数是将哈希函数变得非常慢，使得攻击方法也变得很慢，慢到足以令攻击者放弃，而往往由此带来的延迟也不会引起用户的注意。降低攻击效率用到了密钥扩展（ key stretching）的技术，而密钥扩展的实现使用了一种 CPU 密集型哈希函数（ CPU-intensive hash function）。看起来有点晕~ 还是关注下该函数怎么用吧！</p>
<p>如果想在一个 Web 应用中使用密钥扩展，则需要设定较低的迭代次数来降低额外的计算成本。我们一般直接选择使用标准的算法来完成，比如 PBKDF2 或 bcrypt 。PHP、斯坦福大学的 JavaScript 加密库都包含了 PBKDF2 的实现，浏览器中则可以考虑使用 JavaScript 完成，否则这部分工作应该由服务端进行计算。</p>
<h3><strong>密钥哈希</strong></h3>
<p>密钥哈希是将密钥添加到哈希加密，这样只有知道密钥的人才可以进行验证。目前有两种实现方式：使用 ASE 算法对哈希值加密、使用密钥哈希算法 HMAC 将密钥包含到哈希字符串中。为了保证密钥的安全，需要将其存储在外部系统（比如一个物理上隔离的服务端）。</p>
<p>即使选择了密钥哈希，在其基础上进行加盐或者密钥扩展处理也是很有必要。目前密钥哈希用于服务端比较多，例如来应对常见的 SQL 注入攻击。</p>
<h3><strong>XOR</strong></h3>
<p>XOR 大家都不陌生，它指的是逻辑运算中的 “异或运算”。两个值相同时，返回 false，否则返回 true，用来判断两个值是否不同。</p>
<p>JavaScript 语言的二进制运算，有一个专门的 XOR 运算符，写作 ^。</p>
<p>XOR 运算有一个特性：<strong>如果对一个值连续做两次 XOR，会返回这个值本身。这也是其可以用于信息加密的根本。</strong></p>
<pre><code>message XOR key // cipherText
cipherText XOR key // message

</code></pre>
<p>目标文本 message，key 是密钥，第一次执行 XOR 会得到加密文本；在加密文本上再用 key 做一次 XOR 就会还原目标文本 message。为了保证 XOR 的安全，需要满足以下两点：</p>
<p>（1）key 的长度大于等于 message ；
（2）key 必须是一次性的，且每次都要随机产生。</p>
<h2>XOR 加密使用</h2>
<p>下面以登录密码加密为例介绍下 XOR 的使用：
第一步：使用 MD5 算法，计算密码的哈希；</p>
<pre><code>const message = md5(password);

</code></pre>
<p>第二步：生成一个随机 key 值；
第三步：进行 XOR 运算，求出加密后的 message。</p>
<pre><code>function getXOR(message, key) 

const arr = [];

//假设 key 是32位的

for (let i = 0; i &lt; 32; i++) {
  const  m = parseInt(message.substr(i, 1), 16);
  const k = parseInt(key.substr(i, 1), 16);
  arr.push((m ^ k).toString(16));
}

return arr.join('');

}

</code></pre>
<p>如上所示，使用 XOR 和一次性的密钥 key 对密码进行加密处理，只要 key 没有泄露，目标文本就不会被破解。</p>
<p>上面说了那么多，问题就来了：我们应该使用什么样的哈希算法呢？</p>
<p>（1）选择经过验证的成熟算法，如 PBKDF2 等 ；</p>
<p>（2）crypt 的安全版本；</p>
<p>（3）避免使用自己设计的加密算法。</p>
<h3><strong>HMAC</strong></h3>
<p>对于 HMAC 算法, 我也不是太了解. 看了几篇文章, 感觉和加盐很像, 就是 salt 换成后端随机生成的 (好像可以防止重放攻击). 然后再通过 HMAC 算法, 得到摘要.</p>
<p>关于 HMAC 算法部分可以详细看这篇<a href="https://link.juejin.cn?target=https%3A%2F%2Fxiaix.me%2Fji-yu-hashhan-shu-de-mac-hmac%2F" title="https://xiaix.me/ji-yu-hashhan-shu-de-mac-hmac/">文章</a>, 我是学渣, 看了半天也不是太懂.=.=</p>
<p><strong>大概过程如下:</strong></p>
<ul>
<li>
<ol>
<li>客户端发出登录请求</li>
</ol>
</li>
<li>
<ol start="2">
<li>服务器返回一个随机值，在会话记录中保存这个随机值</li>
</ol>
</li>
<li>
<ol start="3">
<li>客户端将该随机值作为密钥，用户密码进行 hmac 运算，递交给服务器</li>
</ol>
</li>
<li>
<ol start="4">
<li>服务器读取数据库中的用户密码，利用密钥做和客户端一样的 hmac 运算，然后与用户发送的结果比较，如果一致，则用户身份合法。</li>
</ol>
</li>
</ul>
<p><strong>好处:</strong></p>
<ul>
<li>与自定义的加 salt 算法不同，Hmac 算法针对所有哈希算法都通用，无论是 MD5 还是 SHA-1。采用 Hmac 替代我们自己的 salt 算法，可以使程序算法更标准化，也更安全。(摘自雪峰大佬的<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F0014316089557264a6b348958f449949df42a6d3a2e542c000%2F0015108777177966ef0f4f8510a41b3b8c48cdcf7047b2d000" title="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0015108777177966ef0f4f8510a41b3b8c48cdcf7047b2d000">这篇文章</a>)</li>
<li>另外一个就是密码的安全性, 由于不知道密钥，所以不可能获取到用户密码</li>
</ul>
<h3><strong>补充 1: 结合验证码进行前端加密</strong> (其实就是一种动态加盐哈希)</h3>
<p>前端先将密码哈希，然后和用户输入的验证码进行哈希，得到的结果作为密码字段发送给服务器。服务器先确认验证码正确，然后再进行密码验证，否则直接返回验证码错误信息。</p>
<p>这种实践保证了密码在传输过程中的资料安全，即使攻击者拿到了数据也无法重放。图形化验证码更是增加了难度。另一方面该实践大大增加了撞库的成本。</p>
<p>前端加密一定程度保障了传输过程中的资料安全，那么会不会有对两端（客户端和服务器）有安全帮助呢？</p>
<p>有帮助，使用一些前端加密手段，可以增加拖库后的数据破解难度。但是验证码方法不具有这样的功能，因为数据库存的仍是明文密码哈希后的结果，那么攻击者可以绕过前端加密，可以直接暴力破解。</p>
<h3><strong>补充 2: Base64 编码</strong></h3>
<p>大家经常说的是 Base64 加密，有 Base64 加密吗？<strong>真木有，只有 Base64 编码。</strong></p>
<p>Base64 是一种基于 64 个可打印字符来表示二进制数据的表示方法。常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据, 包括 MIME 的 email，email via MIME，在 XML 中存储复杂数据；主要用来解决把不可打印的内容塞进可打印内容的需求。js 中 base64 方法使用如下：</p>
<pre><code>//1.编码
var result = Base.encode('shotCat好帅!');  //--&gt; &quot;c2hvdENhdOWlveW4hSE=&quot;

//2.解码
var result2 = Base.decode(result); //--&gt; 'shotCat好帅!' 没错,我就是这么不要脸!!!

</code></pre>
<p>因此，Base64 适用于小段内容的编码，比如数字证书签名、Cookie 的内容等；而且 Base64 也是一种通过查表的编码方法，不能用于加密，如果需要加密，请使用专业的加密算法。</p>
<p><strong>PS:</strong> 对于前端来说, base64 用得最多的也就是图片转码吧.</p>
<h3><strong>补充 3: 数字签名</strong></h3>
<p>数字签名主要用于: <strong>确认信息来源于特定的主体且信息完整、未被篡改，发送方生成签名，接收方验证签名。</strong></p>
<p><strong>发送方:</strong> 首先计算目标文本的摘要（哈希值），通过私钥对摘要进行签名，将目标文本和电子签名发送给接收方。</p>
<p><strong>接收方:</strong> 验证签名的步骤如下：</p>
<ul>
<li>1, 通过公钥破解电子签名，得到摘要 D1 (如果失败，则信息来源主体校验失败)；</li>
<li>2, 计算目标文本摘要 D2；</li>
<li>3, 若 D1 === D2，则说明目标文本完整、未被篡改。</li>
</ul>
<p><strong>数字签名与非对称加密区别:</strong></p>
<ul>
<li>非对称加密（加密 / 解密）：公钥加密，私钥解密。</li>
<li>数字签名（签名 / 验证）：私钥签名，公钥验证。</li>
</ul>
<h1> </h1>
<h1>顾凡及丨脑科学的范式革命</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://mp.weixin.qq.com/s/ZHGnBWWQdUrnyYCYMYCfPg">mp.weixin.qq.com</a></p>
</blockquote>
<h1><strong>Imaging Brain Function With EEG</strong></h1>
<p>德国诗人和科学家歌德曾说过：“除非我们设法知道前人懂得了什么，否则我们就无法清楚地明白我们究竟懂得了哪些东西。如果我们不知道怎样欣赏往日的成就，那么我们也就不能真正理解如今的进展。”
因此，从科学史的角度梳理人类在认识脑的过程中所发生的范式革命，是非常有意义的</p>
<hr>
<p>“范式革命” 是由托马斯 · 库恩提出的概念，意指某门学科中基本概念和研究方法的根本性变化
由此出发，可以帮助我们思考可能面临什么样的新范式革命，以便更自觉地做出应对。</p>
<hr>
<p>在科学的发展中，某些关键研究技术的突破也起到举足轻重的作用——虽然这些技术还不能被归入该学科的范式革命，却是范式革命必不可少的催化剂和前提条件。
范式革命的发生往往是由问题驱动的，即当学科发展遭遇某个非解决不可的关键问题时，或迟或早会有天才科学家提出石破天惊的新思想，做出颠覆性的发现，引发范式革命</p>
<hr>
<p>古希腊医生希波克拉底早在公元前 5 世纪就根据脑损伤病人的症状提出 “脑是我们精神生活的所在地”
但由亚里士多德在公元 4 世纪提出的“心脏中心论” 仍统治了欧洲十几个世纪。这是因为当时可以清楚地看到血管，但是却看不清神经</p>
<hr>
<p>心智功能的实现需要全脑还是局部脑？
最早提出 “心智功能位于特定局部皮层区域” 的是 18 世纪末的德国解剖学家和生理学家弗朗兹 · 约瑟夫 · 加尔（Franz Joseph Gall），但他的论据却是错误的。
加尔想当然地认为，如果某个区域的皮层特别发达，那么其上的颅骨就会隆起。
他认为只要根据颅骨形状就可以判断人的品性，这一假说被称为“颅相学”，并曾风行一时。</p>
<h1> </h1>