<h1>2024-01-22</h1><p>铭文是大规模用户以及自主世界（Autonomous World）的关键</p>
<ul>
<li>铭文模式对新人友好</li>
</ul>
<p>如何把用户吸引到链上，一直是业内的一个困境。每一次牛市都讲大量用户吸引到链上</p>
<ul>
<li>17年 ICO 牛市以及 20 年的 DeFi 牛市，都是以大量用户直接使用区块链为标志，
<ul>
<li>而ICO 让用户可以直接参与项目的早期募资</li>
<li>DeFi 可以通过流动性挖矿获益</li>
</ul>
</li>
<li>它们的参与门槛都太高，很难吸引大规模用户进入。</li>
</ul>
<h2>Cons</h2>
<p>ICO 的参与门槛在于识别成本，</p>
<ul>
<li>对不懂技术的新人来说，更难鉴别，所以只能追寻热点，造就一波泡沫。</li>
</ul>
<p>DeFi 的参与门槛在于初始资金，</p>
<ul>
<li>如果没有初始资金，以及安全方面的鉴别能力，不仅赚不到钱，还可能被一把 rug 了或者被黑掉了。</li>
</ul>
<p>铭文的参与门槛是最低的，用户只要能付得起 Gas 费，就可以参与，</p>
<ul>
<li>有利于风险偏好比较低的用户群。</li>
<li>用户天然靠近社区，可以占据主动性，只要坚持一个原则，只参与 mint 或者早期阶段，基本顶多亏个 Gas 费。</li>
</ul>
<p>Web3 这种新类型的应用，体验低于旧应用，门槛高于旧应用，</p>
<ul>
<li>它所承诺的价值需要用户先形成网络效应才能发挥出来，如何实现冷启动一直是个困境。</li>
<li>而通过铭文直接分发应用内未来的资产，吸引用户上链，先通过资产构建启动用户社群是一种办法。</li>
</ul>
<p>铭文是否是一个可持续的赛道？
博弈到第二阶段，就需要发出更可信的信号，搞基础建设。围绕一个生态搞基础建设，相当于一种质押取信的方法，如果这个游戏不能持续，那基建投资都会浪费。</p>
<p>铭文的演化路径
这方面主要有几个方向：</p>
<ol>
<li>Bitcoin 上的新资产协议。无论是基于 Ordinals Inscription 协议扩展，还是新的铭刻方法，都可以归在这个角度。</li>
<li>催生 Bitcoin 扩容的基础设施。现在众多 Bitcoin Layer2 冒出来，其实也是这个方向的演化结果。不过市场的分歧在于，铭文是主菜还是开胃菜。很多人认为铭文是开胃菜，主菜是 Layer2。但从铭文的演化角度来看，铭文实际上才是主菜，Bitcoin Layer2 要为铭文服务。而 Indexer 模式的 Layer2 扩容路径，才能延续铭文的扩展场景。这个话题比较大，后面单独写文章来阐述。</li>
<li>铭文和智能合约的结合，也就是智能铭文（Smart Inscription）。很多铭文所设想的生态以及应用场景，需要在 Indexer 层实现。而 Indexer 层如果想提供第三方扩展，自然的想法是内置一套智能合约虚拟机，于是铭文和智能合约产生了结合。铭文表达资产，智能合约创造使用场景，自然打开了铭文应用场景的想象力。</li>
</ol>
<h2>铭文的衍生生态</h2>
<p>铭文从资产表达角度来看，它是一种半均质化资产（SFT），但它同时蕴含着资产的发行方式
铭文的 SFT 特征，让它的流动性介于 FT 和 NFT 之间，更适合初创小团队用来发行资产。当市场摸索出可复制的激励和应用构建模式，大量的中小团队开始构建应用，才预示着真正牛市的来临。</p>

<h1>2024-01-23</h1><p>In summary, mitigation is about taking actions to prevent or reduce the impact of a risk before it happens, while contingency involves preparing for and responding to the consequences of a risk if it does occur.</p>

<h1>2024-01-26</h1><p>罗翔的演讲中，反复在传达几个观点：</p>
<p>1、人类是渺小的，不要慕强，更无需为非理性而羞愧，承认自己的无知和有限</p>
<p>2、真实的世界是不美好的，从书籍中获得足够的力量，然后再回到真实的世界，坦然面对，在人类的总经验中做出选择</p>
<p>3、焦虑无时无刻都存在，不眷恋过去，也不奢盼未来，做好人生中每一个节点该做的事情，把当下活好，不用害怕批评和唾沫</p>
<p>4、坚守自己的原则，去做自己认为对的事情，同时也承认命运之神的存在，过得好或者不好，坚持、能力、原则固然重要，但运气也很重要，珍惜自己的运气</p>

<h1>API requestAnimationFrame</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6991297852462858277?searchId=202401111042005CE25745555C47841FB9">juejin.cn</a></p>
</blockquote>
<p><strong>window.requestAnimationFrame()</strong></p>
<p>告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。
<strong>注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用<code>window.requestAnimationFrame()</code></strong></p>
<p>原来在回调函数中要再次调用 <code>requestAnimationFrame</code> 才可以，修改代码再试一下。</p>
<pre><code>(() =&gt; {
  let n = 0
  function test() {
    n++
    console.log(`🚀🚀hello ~ requestAnimationFrame ${n}`);
    requestAnimationFrame(test)
  }
  requestAnimationFrame(test)
})()
</code></pre>
<h2>执行频率</h2>
<p>这时候有小伙伴就要问了，我没有像 <code>setTimeout</code> 和 <code>setInterval</code> 那样设置时间，它为什么会间隔执行呢？
再看看文档怎么说。</p>
<blockquote>
<p>回调函数执行次数通常是每秒 <strong>60</strong> 次，但在大多数遵循 <code>W3C</code> 建议的浏览器中，回调函数执行次数通常与 <strong>浏览器屏幕刷新次数</strong> 相匹配。</p>
</blockquote>
<p>这回就知道了，原来它根本就不用手动设置执行间隔时间，而是根据 <strong>浏览器屏幕刷新次数</strong> 自动调整了, 也就是说浏览器屏幕刷新多少次，它就执行多少次。看到这我只想说一句 <strong>厉害坏了</strong> 。
那么什么是 <strong>浏览器屏幕刷新次数</strong> 呢？
<strong>屏幕刷新频率（次数）：</strong> 屏幕每秒出现图像的次数。普通笔记本为 60Hz。</p>
<h2>回调参数</h2>
<blockquote>
<p>回调函数会被传入 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDOMHighResTimeStamp" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp"><code>DOMHighResTimeStamp</code></a>参数，<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDOMHighResTimeStamp" title="https://developer.mozilla.org/zh-CN/docs/Web/API/DOMHighResTimeStamp"><code>DOMHighResTimeStamp</code></a>指示当前被 <code>requestAnimationFrame()</code> 排序的回调函数被触发的时间。</p>
</blockquote>
<p>修改代码来看一下这个参数。</p>
<pre><code>(() =&gt; {
  function test(timestamp) {
    console.log(`🚀🚀hello ~ requestAnimationFrame ${timestamp}`);
    requestAnimationFrame(test)
  }
  requestAnimationFrame(test)
})()
</code></pre>
<p>在同一个帧中的 <strong>多个回调函数</strong> ，它们每一个都会接受到一个 <strong>相同的时间戳</strong> ，即使在计算上一个回调函数的工作负载期间已经 <strong>消耗了一些时间</strong> 。该时间戳是一个十进制数，单位毫秒，最小精度为 1ms(1000μs)。</p>
<p>修改代码，我们同时执行两个 <code>requestAnimationFrame</code> 来看一下。
可以看到，两个 <code>requestAnimationFrame</code> 在控制台输出的时间戳是一样的。也就是浏览器刷新一次的时候，执行所有的 <code>requestAnimationFrame</code> ，并且它们的回调参数是一模一样的。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f779dd8e9fca40aa9aa8ba61b583fa4b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p>
<h2>requestAnimationFrame返回值</h2>
<p>一个 <code>long</code> 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。
以下代码点击开始的时候，输出 <code>requestAnimationFrame</code> 的返回值。可以看见，每执行一次，数值就会 <strong>+1</strong></p>
<pre><code>(() =&gt; {
  const beginBtn = document.querySelector(&quot;#begin&quot;)
  
  let myRef;
  
  beginBtn.addEventListener(&quot;click&quot;, () =&gt; {
    myRef = requestAnimationFrame(test)
  })
  
  function test() {
    myRef = requestAnimationFrame(test)
    console.log('🚀🚀~ myRef:', myRef);
  }
})()
</code></pre>
<h2>终止执行</h2>
<p>你可以传之前的返回值值给 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FcancelAnimationFrame" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/cancelAnimationFrame"><code>window.cancelAnimationFrame()</code></a> 以取消回调函数。
那如果我想要在特定的条件下终止 <code>requestAnimationFrame</code> 怎么办呢，官方也给出了答案，那就是 <code>cancelAnimationFrame API</code> 。 只需要把 <code>requestAnimationFrame</code> 的返回值作为参数传递给 <code>cancelAnimationFrame</code> 就可以了。</p>
<pre><code>(() =&gt; {
  const beginBtn = document.querySelector(&quot;#begin&quot;)
  const endBtn = document.querySelector(&quot;#end&quot;)
  let myRef;
  beginBtn.addEventListener(&quot;click&quot;, () =&gt; {
    myRef = requestAnimationFrame(test)
  })
  endBtn.addEventListener(&quot;click&quot;, () =&gt; {
    cancelAnimationFrame(myRef)
  })
  function test() {
    myRef = requestAnimationFrame(test)
    console.log('🚀🚀~ myRef:', myRef);
  }
})()
</code></pre>
<p>可以看到，当我点击开始的时候控制台持续输出内容，当我点击停止的时候，控制台停止输出。
其实不用这个 <code>API</code> 也可以达到终止执行的目的，比如简单的 <code>if语句</code> 。</p>
<pre><code>(() =&gt; {
  function test(timestamp) {
    console.log(`🚀🚀hello ~ requestAnimationFrame ${timestamp}`);
    if (timestamp &lt; 500) {
      requestAnimationFrame(test)
    }
  }
  requestAnimationFrame(test)
})()
</code></pre>
<h2>可以看到，当 <code>timestamp</code> 超过 500 的时候就停止了。当然还有更多可能性，这就要靠小伙伴们开动聪明的脑袋瓜子了。
小技巧</h2>
<p>我们这样就可以把每两次执行的时间间隔传递给外部使用了。外部拿到以后就可以搞事情了，比如时间间隔累加到 <strong>1000</strong> 就执行什么什么操作~</p>
<pre><code>(() =&gt; {
  let startTime = Date.now();

  function handleTicker() {
    foo(Date.now() - startTime);
    startTime = Date.now();
    requestAnimationFrame(handleTicker);
  }

  requestAnimationFrame(handleTicker);

  let t = 0
  function foo(timeInterval) {
    t += timeInterval
    console.log('🚀🚀~ t:', t);
    if (t &gt; 1000) {
      console.log('🚀🚀~ 搞事情');
      t = 0
    }
  }
})()
</code></pre>
<h2>可以看到，当 <code>t</code> 累加大于 <code>1000</code> 的时候，就搞了一次事情，然后重置 <code>t</code> ，以此类推。
setTimeout &amp;&amp; setInterval</h2>
<p><code>setTimeout</code> 和 <code>setInterval</code> 的问题是，它们不够精确。它们的内在运行机制决定了 <strong>时间间隔参数</strong> 实际上只是指定了把动画代码添加到 <strong>浏览器 UI 线程队列</strong> 中以等待执行的时间。如果队列前面已经加入了其它任务，那动画代码就要等前面的 <strong>任务完成后</strong> 再执行，并且如果时间间隔过短（小于 16.7ms）会造成丢帧，所以就会导致动画可能不会按照预设的去执行，降低用户体验。</p>
<p><code>requestAnimationFrame</code> 采用 <strong>浏览器时间间隔</strong> ，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，消耗性能；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个 <strong>统一</strong> 的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。</p>

<h1>Access Token & Refresh Token 详解以及使用原则</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6859572307505971213?searchId=20240112202231678693B99788D345C320">juejin.cn</a></p>
</blockquote>
<h2>Oauth2 使用 Token 的基本流程</h2>
<p>我们先看看一个来自 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.rfcreader.com%2F%23rfc6749" title="http://www.rfcreader.com/#rfc6749">RFC6749</a> 定义的 Oauth2 中 token 使用的基本流程，大概可以明白 Access Token 和 Refresh Token 两个的用法。</p>
<pre><code>+----+                                           +---------------+
|        |--(A)------- Authorization Grant ---------&gt;|           |
|        |                                           |          |
|        |&lt;-(B)----------- Access Token -------------|          |
|        |               &amp; Refresh Token             |          |
|        |                                           |          |
|        |                            +----------+   |          |
|        |--(C)---- Access Token ----&gt;|          |   |          |
|        |                            |          |   |          |
|        |&lt;-(D)- Protected Resource --| Resource |   |Auth      |
| Client |                            |  Server  |   | Server    |
|        |--(E)---- Access Token ----&gt;|          |   |          |
|        |                            |          |   |          |
|        |&lt;-(F)- Invalid Token Error -|          |   |          |
|        |                            +----------+   |          |
|        |                                           |          |
|        |--(G)----------- Refresh Token -----------&gt;|          |
|        |                                           |          |
|        |&lt;-(H)----------- Access Token -------------|          |
+----+           &amp; Optional Refresh Token        +------+
               Figure 2: Refreshing an Expired Access Token
</code></pre>
<p>上图中 Authorization Server 翻译为授权服务，负责 Token 的签发。Resource Server 翻译为资源服务，也就是被授权访问的资源，比如 API 接口。在分布式应用中，他们应该分属不同的服务。 值得注意的是，资源服务器不签发 Token，但是可以具备独立验证 Access Token 的能力。
上面的流程图包括了下面的步骤。</p>
<ul>
<li>(A) 客户端向授权服务器请求 Access Token（整个认证授权的流程，可以是多次请求完成该步骤）</li>
<li>(B) 授权服务器验证客户端身份无误，且请求的资源是合理的，则颁发 Access Token 和 Refresh Token，可以同时返回 Access Token 的过期时间等附加属性。</li>
<li>(C) 带着 Access Token 请求资源</li>
<li>(D) 资源服务器验证 Access Token 有效则返回请求的内容。</li>
<li>(E) <strong>注意：</strong> 上面的 (C)(D) 步骤可以反复进行，直到 Access Token 过期。 如果客户端在请求之前就能判断 Access Token 已过期或临近过期（下发过期时间），就可以直接跳到步骤(G)。否则，就会再请求一次，也就产生了本步骤。</li>
<li>(F) 当 Access Token 无效的时候，资源服务器会拒绝响应资源并返回 Token 无效的错误。</li>
<li>(G) 客户端重新向授权服务器请求 Access Token，但是这次只需带着 Refresh Token 即可，而不需要用户再执行认证和授权的流程。这样就可以做到用户无感。</li>
<li>(H) 授权服务器验证 Refresh Token，如果有效，则签发新的 Access Token（或者同时下发一个新的 Refresh Token）。</li>
</ul>
<p>我们总结几个点，Access Token 作为请求资源的凭证，是使用最频繁的，但是有效期比较短，Refresh Token 有效期较长，只会发给授权服务器，用来获取新的 Access Token。</p>
<h3>资源服务如何脱离授权服务验证 Access Token？</h3>
<p>以 JTW 为例。如果 Access Token 是 JWT 形式签发，资源服务可以使用验证签名的方式判断是否合法，只需要把签名密钥在资源服务同步一份即可。也有使用非对称加密的，授权服务使用私钥签发，资源服务使用公钥验证。由于 JWT 允许携带一些信息，用户，权限，有效期等，因此资源服务判断 JWT 合法之后可以继续根据携带信息来判断是否可访问资源。仅此而已，这样的好处是可以快速验证有效性，坏处是 Access Token 一旦签发，将很难收回，只能通过过期来失效。</p>
<h3>Refresh Token 机制如何提升安全？</h3>
<p>Refresh Token 的其中一个目的是让用户在较长的时间保持登录状态，那么可否直接让 Access Token 具有更长的有效期，从而可以省去许多没用的步骤。答案是不安全，理由参考上面问题的答案。</p>
<p>举个例子，某个用户登录成功，获得了一个可以发帖的 Access Token，这时管理员发现他发布垃圾内容吊销了发帖权限，而这个信息一般属于授权服务管理，也就是说他下次向授权服务请求 Access Token 将不会得到发帖权限。但是如果用户之前拿到的 Access Token 是长期有效的，那么这个用户就可以发帖很长时间。如果 Access Token 在短时间内失效，那么他必须重新去授权服务请求，这时授权服务将不会颁发具备发帖权限的 Access Token。</p>
<p>第二个例子，如果 Access Token 具有较长的有效期，一旦被盗用，攻击者就可以拿 Access Token 使用很长时间。聪明的你可能会想到，攻击者可以同时盗取 Refresh Token。</p>
<p><a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.rfcreader.com%2F%23rfc6749" title="http://www.rfcreader.com/#rfc6749">RFC6749</a> 第 10 节中有说明，授权服务<strong>必须维护 Refresh Token 与客户端的绑定关系</strong>，也就是说只有合法用户的客户端（可通过 IP,UA 等资料判断）来请求是可以通过的。退一步讲，如果攻击者模拟了客户端可以执行刷新请求，那么就要看谁先刷。由于授权服务<strong>可以设置 Refresh Token 一次有效</strong>，因此不管哪个先刷新，另一个人刷新就会报错。如果用户先刷新，攻击者以 Access Token 和 Refresh Token 的双重失效结束游戏。如果攻击者先刷新了，合法用户就会收到报错信息，授权服务会引导用户从上图的步骤 (A) 重新开始认证，从而把有效的 Refresh Token 拿回到合法用户这里。</p>
<h2>总结</h2>
<p>Access Token 应该维持在较短有效期，过长不安全，过短也会影响用户体验，因为频繁去刷新带来没有必要的网络请求。可以参考我们常常在某些网站停止操作一段时间之后就会掉线，这个时间是 Refresh Token 的有效期，Access Token 不应长过这个时间。</p>
<p>Refresh Token 的有效期就是允许用户在多久时间内不用重新登录的时间，可以很长，视业务而定。我们在使用某些 APP 的时候，即使一个月没有开过也是登录状态的，这就是 Refresh Token 决定的。授权服务在接到 Refresh Token 的时候还要进一步做客户端的验证，尽可能排除盗用的情况。</p>
<p>所有 token 应该保管在 private 的地方，也就是只能客户端自己使用，所有 token 都应该在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E5%2582%25B3%25E8%25BC%25B8%25E5%25B1%25A4%25E5%25AE%2589%25E5%2585%25A8%25E6%2580%25A7%25E5%258D%2594%25E5%25AE%259A%23TLS_1.3" title="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A#TLS_1.3">TLS</a> 信道下发送（比如 HTTPS）。</p>

<h1>React CSS-In-JS 方案Linaria StyledComponents</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7153146950701973518?searchId=20240120202017BD9D5A30E810FAEC4E61">juejin.cn</a></p>
</blockquote>
<h2>CSS-in-JS 解决方案</h2>
<p>CSS-in-JS 解决方案给我们提供了新的编写 CSS 的方式。这些方案使用以 javascript 为基础的 API 来创建和编写样式。
主要的优点包括：</p>
<ul>
<li>动态样式：允许开发者编写动态 CSS</li>
<li>元素作用域：可以把样式的范围固定在某些元素上</li>
<li>消除无用代码：会自动除去应用中冗余的 CSS 代码</li>
<li>支持自定义主题</li>
<li>更加容易编写单元测试</li>
<li>性能提升</li>
<li>支持 SSR</li>
<li>支持所有的 CSS 语法</li>
</ul>
<h2>Linaria</h2>
<p>Linaria 是最流行的 CSS-in-JS 解决方案之一
Linaria 是 「零运行时」方法，这意味着它将开发者写好的样式代码在构建时转换为一个单独的 .css 文件。
这个行为跟很多的 CSS 预处理器相似，比如 SASS ，LESS</p>
<p>它提供了很多功能，包括：</p>
<ul>
<li>提供创建 CSS 类的 API 。”css” API 允许开发者创建所选择的样式，同时他也支持模版语法来满足当我们需要插入动态值。</li>
</ul>
<pre><code>import { css } from '@linaria/core';

const red = &quot;red&quot;
const header = css`
  text-transform: uppercase;
	color: ${red}
`;

&lt;h1 className={header}&gt;Hello world&lt;/h1&gt;;
</code></pre>
<ul>
<li>它也提供可以创建元素的 API. “styled” API 允许开发者创建任何元素，比如： div，p，等等。当然，这个 API 也是支持模版语法来插入对应的变量值的</li>
</ul>
<pre><code>import { styled } from '@linaria/react'

const Container = styled.div`
  font-size: 35px;
  color: red;
  border: 1px solid red;

  &amp;:hover {
    border-color: blue;
  }

  h1 {
    margin-bottom: 24px;
  }
`;

const App = () =&gt; {
    return &lt;Container&gt;
        &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;/Container&gt;
  }
export default App;
</code></pre>
<ul>
<li>它通过 React 的 Props 或者常规变量来管理动态样式。在下面的代码中，我们通过 React 组件传递 props 和一些常规变量到另一个元素上</li>
</ul>
<pre><code>import { styled } from '@linaria/react';

const Title = styled.h1`
  font-family: inherit;
`;
const medium = 30

const Navbar = styled.nav`
  font-size: ${medium}px;
  color: ${props =&gt; props.color};
  border: 1px solid red;

  &amp;:hover {
    border-color: blue;
  }

  ${Title} {
    margin-bottom: 24px;
  }
`;

const App = () =&gt; {
    return &lt;Navbar color=&quot;#999&quot;&gt;
        &lt;Title&gt;Hello world&lt;/Title&gt;
    &lt;/Navbar&gt;
}

export default App;
</code></pre>
<p>其他的功能包括：</p>
<ul>
<li>通过 CSS source maps 可以很容易的找到样式变量是在哪里定义的</li>
<li>可以在 JS 代码中开启 CSS Lint <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint" title="https://github.com/stylelint/stylelint"></a><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint" title="https://github.com/stylelint/stylelint">github.com/stylelint/s…</a></li>
<li>通过 @linaria/atomic 可以支持原子样式</li>
</ul>
<h2>Styled-Components</h2>
<p>Styled-Components 也是流行的 CSS-in-JS 解决方案之一。
Styled-components 让开发者能够通过编写真实的 CSS 代码来修改组件的样式。
它在组件和样式之间创建了一个抽象层，从而消除了直接的映射。</p>
<p>提供的能力，包括：</p>
<ul>
<li>自动提取关键 CSS 和 代码分割：Styled-Components 监控组件，并且在组件渲染到页面的时候插入组件必要的样式代码。同时支持代码分割来加快组件加载的速度</li>
<li>为样式生成唯一的类名，以防止样式的覆盖，拼写错误以及冗余</li>
<li>Styled-component 也提供通过 props 或者常规变量为元素注入动态值。“styled” API 允许开发者创建选择的元素，跟 Linaria 一样，Styled-component 也支持大致相同的模版语法</li>
</ul>
<pre><code>import styled from 'styled-components';

const Button = styled.button`
  background: ${props =&gt; props.primary ? &quot;palevioletred&quot; : &quot;white&quot;};
  color: ${props =&gt; props.primary ? &quot;white&quot; : &quot;palevioletred&quot;};

  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 3px;
`;

const App = () =&gt; {
    return &lt;div&gt;
        &lt;Button&gt;Normal&lt;/Button&gt;
        &lt;Button primary&gt;Primary&lt;/Button&gt;
  &lt;/div&gt;
}

export default App;
</code></pre>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b71464735a7c48cfb3966060e68da08c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p>
<ul>
<li>样式扩展：Styled-Components 允许在已有的样式上通过 styled 进行扩展</li>
</ul>
<pre><code>import styled from 'styled-components';

const Button = styled.button`
  color: palevioletred;
  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 3px;
`;

const TomatoButton = styled(Button)`
  color: tomato;
  border-color: tomato;
`;

const App = () =&gt; {
    return &lt;div&gt;
        &lt;Button&gt;Normal Button&lt;/Button&gt;
        &lt;TomatoButton&gt;Tomato Button&lt;/TomatoButton&gt;
    &lt;/div&gt;
}

export default App;
</code></pre>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/113961d591ec476991654dfbc268dd07~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d7bb02fc4e499f8e6b40bb8ff443e4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p>
<p>其他的功能，包括：</p>
<ul>
<li>维护成本低</li>
<li>更简便的删除不必要的 CSS</li>
<li>支持 SSR</li>
<li>支持主题定制</li>
</ul>
<h2>对比 Linaria 和 Styled-Components</h2>
<p>开发者在很长一段时间都在选择最适合自己项目的样式解决方案，而 Linaria 和 Styled-Components 无疑是当中的佼佼者。接下来我们将从：「功能」，「性能」以及 「生态」来对这两个方案进行比较</p>
<h3>功能</h3>
<ul>
<li>Linaria 是「零运行时」方案，这意味着样式文件会在构建时被单独抽取成 CSS 文件；Styled-Components 则是在构建时通过 javascript 将 CSS 注入，不会生成额外的 CSS 文件</li>
<li>都拥有相似的 CSS 语法（类似 Sass 的风格）</li>
<li>在 React 应用中都可以基于 Prop 实现变量注入（原理是使用 CSS 变量）</li>
<li>都可以通过 CSS source maps 很快找到 CSS 变量定义的位置</li>
<li>都可以通过 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint" title="https://github.com/stylelint/stylelint">stylelint</a> 的方案进行代码检查</li>
<li>都使用 Javascript 来组织代码逻辑，无需使用 CSS 预处理器</li>
<li>都可以平替 Sass 或者 PostCSS 方案</li>
</ul>
<p>通过上述的的功能描述，我们发现 Linaria 和 Styled-Components 的 API 都比较相似，所以开发者很容易就可以从其中一个方案迁移到另一个方案</p>
<h3>基于请求的性能对比</h3>
<ul>
<li>在生产环境中， Linaria 会产生额外的 .css 文件，这将会引起 CSS 文件体积变大，文件数量变多，导致请求数量变多的问题</li>
<li>对于 Styled-Components 来说，相同情况下，CSS 文件体积和数量无疑是更少的，但是会增加 JS bundle 的体积大小</li>
</ul>
<p>许多争论在于认为 Linaria 产生的 css 文件对性能的影响是比较小的，相对于 Styled-Components ，Linaria 不会增加 JS bundle 体积是一种更好的取舍；而另一些则认为 Linaria 增加了 CSS 冗余代码的可能性。</p>
<p>我们可以在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fpustelto.com%2Fblog%2Fcss-vs-css-in-js-perf%2F%23network-comparison" title="https://pustelto.com/blog/css-vs-css-in-js-perf/#network-comparison">这里</a> 看到更多关于请求的性能对比</p>
<h3>基于页面加载的性能对比</h3>
<p>在加入多种页面加载标准之后发现，大部分的页面使用 Linaria 的加载性能要 <strong>好于</strong> 使用 Styled-Components。其中一个比较重要的原因就是，Linaria 导致的 CSS 资源体积与数量的增加对于页面加载的影响要小于 Styled-Components 导致的 JS bundle 体积的增加</p>

<h1>React Fiber 架构</h1><h3>调和阶段知识拓展</h3>
<p><strong>1、为什么 Fiber 架构更快？</strong>
<strong><code>flags</code></strong> 或 <strong><code>subtreeFlags</code></strong> 是 16 进制的标识，在这里进行按位或 (<code>|</code>) 运算后，可以记录当前节点本身和子树的副作用类型，通过这个运算结果可以减少节点的遍历
这样的计算方式可以减少递归那些没有副作用的子树或节点，所以比以前的版本全部递归的算法要高效</p>
<pre><code>假设有两种标识符：
Placement (表示新插入的子节点)：0b001
Update (表示子节点已更新)：0b010
A
├─ B (Update)
│   └─ D (Placement)
└─ C
   └─ E

这个例子里，计算逻辑是这样：
1、检查到A的flags没有副作用，直接复用，但subtreeFlags有副作用，那么递归检查B和C
2、检查到B的flags有复用，更新B，subtreeFlags也有副作用，则继续检查D
3、检查到C的flags没有副作用，subtreeFlags也没有副作用，那么直接复用C和E
</code></pre>
<h3>第二阶段：Commit（提交）</h3>
<ul>
<li><strong>目标</strong>: 更新 DOM 并执行任何副作用。</li>
<li><strong>原理</strong>: 遍历在 Reconciliation 阶段创建的副作用列表进行更新。
Commit的入口方法</li>
</ul>
<ul>
<li>源码里 <strong><code>commitRoot</code></strong> 和 <strong><code>commitRootImpl</code></strong> 是提交阶段的
在两个方法中，可以看出来提交阶段也有三个核心小阶段：</li>
</ul>
<ol>
<li>CommitBeforeMutationEffects:遍历副作用列表</li>
<li>CommitMutationEffects:正式提交副作用</li>
<li>CommitLayoutEffects:处理 layout effects</li>
</ol>
<h3><strong>1、遍历副作用列表：<code>commitBeforeMutation</code></strong></h3>
<pre><code class="language-js">export function commitBeforeMutationEffects(
  root: FiberRoot,
  firstChild: Fiber,
): boolean {
  nextEffect = firstChild; 
  commitBeforeMutationEffects_begin(); 
  // 遍历fiber，处理节点删除和确认节点在before mutation阶段是否有要处理的副作用
  const shouldFire = shouldFireAfterActiveInstanceBlur; 
  // 当一个焦点元素被删除或隐藏时，它会被设置为 true
  shouldFireAfterActiveInstanceBlur = false;
  focusedInstanceHandle = null;
  return shouldFire;
}
</code></pre>
<h3>2、正式提交：<code>CommitMutationEffect</code></h3>
<pre><code class="language-js">// packages/react-reconciler/src/ReactFiberCommitWork.js
// 以下只是核心逻辑的代码，不是commitMutationEffects的完整源码
export function commitMutationEffects(
  root: FiberRoot,
  finishedWork: Fiber,
  committedLanes: Lanes,
) {
    // lanes和root被设置为&quot;in progress&quot;状态，表示它们正在被处理
  inProgressLanes = committedLanes;
  inProgressRoot = root;

    // 递归遍历Fiber，更新副作用节点
  commitMutationEffectsOnFiber(finishedWork, root, committedLanes);

    // 重置进行中的lanes和root
  inProgressLanes = null;
  inProgressRoot = null;
}
</code></pre>
<h3>3、处理 layout effects：<code>commitLayout</code></h3>
<pre><code class="language-js">// packages/react-reconciler/src/ReactFiberCommitWork.js
export function commitLayoutEffects(
  finishedWork: Fiber,
  root: FiberRoot,
  committedLanes: Lanes,
): void {
  inProgressLanes = committedLanes;
  inProgressRoot = root;

  // 创建一个current指向就Fiber树的alternate
  const current = finishedWork.alternate;
  // 处理那些由useLayoutEffect创建的layout effects
  commitLayoutEffectOnFiber(root, current, finishedWork, committedLanes);

  inProgressLanes = null;
  inProgressRoot = null;
}
</code></pre>
<p>从源码里我们可以看到，一旦进入提交阶段后，React 是无法中断的。</p>
<h2>Part 1 Fiber 树的组织方式</h2>
<h3>基于链表的树</h3>
<p>另一种则是通过节点之间的指针表示他们的关系，形成一棵树。</p>
<pre><code>// 对于多个 children，往往是父节点指向第一个子节点 child，再通过子节点的兄弟节点 sibling 指针横着指
// 也可以加上 return 指父节点
A = { child: B }
B = { return: A, sibling: C }
C = { return: A, sibling: D, child: E }
D = { return: A }
E = { return: C }
</code></pre>
<p>虽然损失了一些可读性，这个结构却有很多优势：</p>
<ul>
<li>调整节点位置很灵活，只要改改指针</li>
<li>方便进行各种方式的遍历</li>
<li>可以随时从某一个节点出发还原整棵树
这一切，正符合 Fiber 架构的要求：遍历、分割、暂停……
Part 2 Fiber 树的遍历方式</li>
</ul>
<hr>
<p>React 构建出新 Virtual DOM 树，通过 Diffing 算法和老树对比。</p>
<ul>
<li>但实际上 Fiber 树是边构建、边遍历、边对比的，这样最大程度减少了遍历次数，也符合「可中断」的设定。</li>
</ul>
<h3>遍历的实现</h3>
<p>通过源码我们看看遍历是如何实现的。从 “协调” 的入口开始，会删掉一些代码，只关注遍历相关的部分。</p>
<pre><code class="language-js">// packages/react-reconciler/src/ReactFiberScheduler.js
function workLoop() {
  while (workInProgress !== null) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
// packages/react-reconciler/src/ReactFiberScheduler.js
function performUnitOfWork(unitOfWork: Fiber): Fiber | null {
  let next;
  next = beginWork(current, unitOfWork, renderExpirationTime);
  if (next === null) {
    next = completeUnitOfWork(unitOfWork);
  }
  return next;
}
</code></pre>
<p>遍历需要一个指针指向当前遍历到的节点，workInProgress 就是这个指针，
进一步是 performUnitOfWork 的 next 指针，遍历在指针为 null 的时候结束。</p>
<ul>
<li>next 先从 beginWork 获取，</li>
<li>如果没有，就从 completeUnitOfWork 获取。
<ul>
<li>这里 beginWork 是 “递”，即不停向下找到当前分支最深叶子节点的过程</li>
<li>completeUnitOfWork 是 “归”，即结束这个分支，向右或向上的过程。</li>
</ul>
</li>
</ul>
<h3>递</h3>
<p>先看 beginWork。</p>
<pre><code class="language-js">// packages/react-reconciler/src/ReactFiberBeginWork.js
function beginWork( current: Fiber | null, workInProgress: Fiber, renderExpirationTime: ExpirationTime,
): Fiber | null {
  switch (workInProgress.tag) {
    case ClassComponent: {
      return updateClassComponent(current, workInProgress, Component, resolvedProps);
    }
  }
}
</code></pre>
<p>beginWork 本身对递归没什么实际进展，主要是根据 tag 分发逻辑。
我们关注的是 beginWork 把 updateClassComponent 的返回作为下一个遍历节点返回，按深度优先规则，这个节点应该是当前节点的第一个子节点。</p>
<pre><code class="language-js">// packages/react-reconciler/src/ReactFiberBeginWork.js
function updateClassComponent(current: Fiber | null, workInProgress: Fiber, Component: any, nextProps) {
  const nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate);
  return nextUnitOfWork;
}
function finishClassComponent(
  current: Fiber | null, workInProgress: Fiber, Component: any, shouldUpdate: boolean, hasContext: boolean
) {
  return workInProgress.child; 
}
</code></pre>
<p>updateClassComponent 调 finishClassComponent，返回 workInProgress.child，确实是当前节点的第一个子节点。</p>
<h3>归</h3>
<p>需要注意的是，next 指针不应该重复经过同一个节点。因为如果向下的过程中经过某个节点，在向上的过程中又出现，就会再次进入 beginWork，造成死循环。继续看 completeUnitOfWork 如何解决这个问题。</p>
<pre><code class="language-js">function completeUnitOfWork(unitOfWork: Fiber): Fiber | null {
  workInProgress = unitOfWork;
  do {
    const siblingFiber = workInProgress.sibling;
    if (siblingFiber !== null) {
      return siblingFiber;
    }
    const returnFiber = workInProgress.return;
    workInProgress = returnFiber;
  } while (workInProgress !== null);
  return null;
}
</code></pre>
<p>completeUnitOfWork 内部又创建了一层循环，搭配一个向上的新指针 workInProgress（此 workInProgress 非彼 workInProgress），然后循环看当前指针节点，有兄弟节点就返回交还给外层循环，没有就向上到父节点，直到最上面的根节点。</p>
<h3>一张图总结</h3>
<p>假设我们有如下这样一棵树。
<img src="https://picx.zhimg.com/v2-eabcf03d0c43acfedb92c3933575c8f9_r.jpg?source=1def8aca" alt=""></p>
<ul>
<li>整个遍历由 performUnitOfWork 发起，为深度优先遍历</li>
<li>从根节点开始，循环调 beginWork 向下爬树（黄色箭头，每个箭头表示一次调用）</li>
<li>到达叶子节点（beginWork 爬不下去）后，调 completeUnitOfWork 向上爬到下一个未遍历过的节点，也就是第一个出现的祖先兄弟节点（绿色箭头，每个箭头表示一次调用）</li>
<li>所以 beginWork 可能连续调用多次，一次最多只爬一步，但 completeUnitOfWork 只可能在 beginWork 之间连续调用一次，一次可以向上爬若干步</li>
<li>completeUnitOfWork 内部包下了若干步循环向上的爬树操作（绿色虚线箭头）</li>
</ul>
<h3>服务于功能的遍历过程</h3>
<p>到这里有个疑问，Fiber 实现深度优先遍历为什么要这么复杂？为什么要区分内外两层循环？
Fiber 树是边创建边遍历的，每个节点都经历了「创建、Diffing、收集副作用（要改哪些节点）」的过程。</p>
<ul>
<li>其中，创建、Diffing 要自上而下，因为有父才有子；</li>
<li>收集副作用要自下而上最终收集到根节点。
现在我们回头看遍历过程。外层循环每一步（也就是 beginWork 每次执行）都是自上而下的，并保证每个节点只走一次；内层循环每一步（在 completeUnitOfWork 里）都是自下而上的。</li>
</ul>
<p>显然，beginWork 负责创建、Diffing，completeUnitOfWork 负责收集副作用。
那这些功能具体又是怎么体现的？</p>
<h2>Part 3 树的构建和 Diffing</h2>
<p>首先明确一点，所谓的 Diffing 算法并不是独立存在的，不是说先把树建完再执行 Diffing 算法找出差距，而是将 Diffing 算法体现在构建过程中对老节点的复用策略。</p>
<h3>背景：两棵树</h3>
<p>在 React 中最多会同时存在两棵 Fiber 树：</p>
<ul>
<li>当前屏幕上显示内容对应的 Fiber 树称为 current Fiber 树</li>
<li>正在构建的 Fiber 树称为 workInProgress Fiber 树，我们这里讨论的所有遍历都在这棵树上
当一次协调发起，首先会开一棵新 workInProgress Fiber 树，然后从根节点开始构建并遍历 workInProgress Fiber 树。</li>
</ul>
<p><img src="https://picx.zhimg.com/v2-ab587b626f5a0af15dac6fb9a825feeb_r.jpg?source=1def8aca" alt=""></p>
<p>如果构建到一半被打断，current 树还在。
如果构建并提交完成，直接把 current 树丢掉，让 workInProgress Fiber 树成为新的 current 树。
所谓 Diffing 也是在这两棵树之间，如果构建过程中确认新节点对旧节点的复用关系，新旧节点间也会通过 alternate 指针相连。</p>
<p><img src="https://picx.zhimg.com/v2-422ba239fe44fa9c8745039cc3b6d6b9_r.jpg?source=1def8aca" alt=""></p>
<h3>Diffing 算法思想</h3>
<p>正常情况下，完全找到两棵树的差异，是个时间复杂度很高的操作。但 Diffing 算法通过一些假设，权衡了执行开销和完整性。</p>
<ul>
<li><strong>假设一：不同类型的节点元素会有不同的形态</strong>
当节点为不同类型的元素时，React 会拆卸原有节点并且建立起新的节点。举个例子，当一个元素从 a 变成 img，从 Article 变成 Comment，都会触发一个完整的重建流程。
该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。</li>
<li><strong>假设二：节点不会进行跨父节点移动</strong>
只会对比两个关联父节点的子节点，多了就加少了就减。没有提供任何方式追踪他们是否被移动到别的地方。
<strong>假设三：用户会给每个子节点提供一个 key，标记它们 “是同一个”</strong>
当子元素拥有 key 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。在新增 key 之后，使得树的转换效率得以提高。比如两个兄弟节点调换了位置，有 key 的情况下能保证二者都复用仅做移动，但无 key 就会造成两个不必要的卸载重建。</li>
</ul>
<h3>深入 Diffing 过程</h3>
<p>接下来我们看 Diffing 算法如何体现在具体实现中的。（代码会精简掉很多无关逻辑，只关注 Diffing 过程）</p>
<pre><code>function performUnitOfWork(unitOfWork: Fiber): Fiber | null {
  const current = unitOfWork.alternate;
  next = beginWork(current, unitOfWork);
  return next;
}
</code></pre>
<p>对每个遍历到的新节点 unitOfWork，取出它关联复用的 current 树节点，称为「current」，然后新旧节点一并传给 beginWork。
这个关联关系是在前面某轮循环执行 beginWork 构造 unitOfWork 时建立的，取决于当时的 Diffing 判断新旧节点是否复用。
所以可能存在 current 为 null 的情况。</p>
<pre><code>function beginWork( current: Fiber | null, workInProgress: Fiber): Fiber | null {
  switch (workInProgress.tag) {
    case HostComponent: {
      return updateHostComponent(current, workInProgress);
    }
  }
}
</code></pre>
<p>beginWork 根据当前节点 tag 做分发，这里的 tag 比较丰富常见的 HostComponent、FunctionComponent、ClassComponent、Fragment 等都在此列。以 updateHostComponent 为例。</p>
<pre><code class="language-js">function updateHostComponent(current: Fiber | null, workInProgress: Fiber) {
  reconcileChildren(current, workInProgress, workInProgress.pendingProps.children);
  return workInProgress.child;
}
function reconcileChildren(current: Fiber | null, workInProgress: Fiber, nextChildren: any) {
  if (current === null) {
    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren);
  } else {
    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren);
  }
}
</code></pre>
<p>updateHostComponent 从 workInProgress 属性中取出 children，这个 children 不是 fiber 节点，而是组件 render 方法根据 JSX 结构 createElement 创建的 element 数组，这点不要混淆。</p>
<p>然后在 reconcileChildren 中构造子节点。可以看到如果 current 节点为 null，也就是当前节点无复用，就直接放弃子节点 Diffing 了。所以<strong>父节点可复用，是子节点复用的必要不充分条件</strong>。</p>
<p><strong>这里也遵循了 Diffing 算法的假设二——节点不会进行跨父节点移动，只对比关联节点的子节点的增减，不管它们有没有被移动到别处或从别处移动来。</strong></p>

<h1>从源码角度解析：react hook 为啥不能放入条件语句中</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7279325329118625853?searchId=2024011909074637716191FEDA6F0DC2CF">juejin.cn</a></p>
</blockquote>
<p><code>react hook</code>必须在函数组件顶层使用，不能在条件语句或者循环结构中使用。</p>
<h3>1，hooks 的加载</h3>
<p>首先准备一个函数组件案例：</p>
<pre><code>export default function MyFun(props) {
  // hook加载
  const [count, setCount] = useState(1)
  useEffect(() =&gt; {
    console.log('useEffect DOM渲染之后执行')
  }, [])
  function handleClick() {
    setCount(2)
  }
  return (
    &lt;div className='MyFun'&gt;
      &lt;div&gt;MyFun组件&lt;/div&gt;
      &lt;div&gt;state: {count}&lt;/div&gt;
      &lt;button onClick={handleClick}&gt;更新&lt;/button&gt;
    &lt;/div&gt;
  )
}
</code></pre>
<p>我们都知道在 react 应用中，函数组件加载的一个重点就是：会调用一次我们定义的函数，也就是案例中的<code>MyFun</code>。
而在函数调用的过程中，就会遇到我们定义的<code>hooks</code>，react 内部就会开始执行<code>hooks</code>的加载处理。
当然首先我们得知道，react 组件的加载处于<code>Fiber Reconciler</code>协调流程之中，</p>
<ul>
<li>这个流程的主要作用就是创建<code>FiberTree</code>【虚拟 DOM 树】，</li>
<li>与<code>hook</code>相关的部分内容就存储在<code>fiber.memoizedState</code>属性之中。</li>
<li>每一个<code>hook</code>在首次加载时，都会执行一个<code>mountWorkInProgressHook</code>方法：</li>
</ul>
<h2>mountWorkInProgressHook`</h2>
<p>比如<code>useState</code>加载时：</p>
<pre><code>function mountState(initialState) {
    const hook = mountWorkInProgressHook();
    ...
}
</code></pre>
<p>这个方法内部会为我们在组件中定义的<code>hook</code>创建一个对应的<code>hook</code>对象：</p>
<pre><code>// hook对象
const hook: Hook = {
  memoizedState: null,
  baseState: null,
  baseQueue: null,
  queue: null,
  next: null, // 指向下一个hook对象
};
</code></pre>
<p>这个<code>hook</code>对象的属性存储着我们组件中对应<code>hook</code>的相关信息，但是在这里我们只需要关心它的<code>next</code>属性即可：</p>
<p>在加载第一个<code>hook</code>即<code>useState</code>时，就会将第一个<code>hook</code>对象直接赋值给当前函数组件对应的<code>Fiber</code>节点的<code>memoizedState</code>属性。</p>
<pre><code>fiber.memoizedState = hook;
</code></pre>
<p>所以此时函数组件<code>Fiber</code>节点的<code>memoizedState</code>属性指向为：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f19ddad1625c4f2ca16e70228fe6b704~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1229&amp;h=190&amp;s=15115&amp;e=png&amp;b=fdfdfd" alt=""></p>
<p>加载第二个<code>hook</code>即<code>useEffect</code>时，就会将上一个<code>hook</code>的<code>next</code>属性指向当前新建的<code>hook</code>对象。
所以此时函数组件<code>Fiber</code>节点的<code>memoizedState</code>属性指向为：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d808cafeefb944109a6e63203cdaf440~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1256&amp;h=193&amp;s=19037&amp;e=png&amp;b=fdfdfd" alt=""></p>
<pre><code>useState =&gt; hook1
useEffect =&gt; hook2
</code></pre>
<p>在函数组件在加载完成后，<code>fiber.memoizedState</code>属性形成了一个这样的单向链表。</p>
<h3>2，hooks 的更新 updateWorkInProgressHook</h3>
<p>来到函数组件的更新过程：函数组件的更新同样会调用一次<code>MyFun</code>，在这个过程中 react 内部就会开始执行<code>hooks</code>的更新处理。
同理每一个<code>hook</code>在更新时，都会执行一个<code>updateWorkInProgressHook</code>方法：</p>
<pre><code>function updateState(initialState) {
    const hook = updateWorkInProgressHook();
    ...
}
</code></pre>
<p><strong>重点：</strong> <code>updateWorkInProgressHook</code>方法内部会引用<code>current.memoizedState</code>属性的内容。</p>
<ul>
<li>函数组件更新时，<code>current</code>代表旧的节点内容</li>
<li>所以<code>hook</code>更新时会引用<strong>函数组件加载阶段</strong>就已形成的<code>hook</code>链表，会按照这个链表顺序来取出对应的原<code>hook</code>对象，利用原<code>hook</code>信息生成新的<code>hook</code>对象参与计算或者更新。</li>
<li><code>hooks</code>的更新会按照函数组件加载阶段就已经固定的<code>hook</code>链表顺序，这就是<code>hook</code>必须置于函数组件顶层使用的<strong>根本原因</strong>。</li>
<li>如果我们将<code>hook</code>置于条件或者循环之中，在更新阶段就会出现无法与原来的<code>hook</code>链表相匹配的问题，将会导致渲染出现异常。</li>
</ul>

<h1>前端性能优化必杀技：骨架屏让你快人一步</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7281162206946721829?searchId=2024011609412312EDD0E05BFA1C6769DA">juejin.cn</a></p>
</blockquote>
<h4>3、骨架屏优化</h4>
<pre><code>/* CSS */
@keyframes shimmer {
  0% {
    background-position: -468px 0;
  }
  100% {
    background-position: 468px 0;
  }
}

.skeleton-header, .skeleton-body .skeleton-line {
  animation-duration: 1.25s;
  animation-fill-mode: forwards;
  animation-iteration-count: infinite;
  animation-name: shimmer;
  animation-timing-function: linear;
  background: #f6f7f8;
  background: linear-gradient(to right, #eeeeee 8%, #dddddd 18%, #eeeeee 33%);
  background-size: 800px 104px;
  position: relative;
}
</code></pre>
<p>以上代码为骨架屏添加了一个流动光影的动画效果，使得骨架屏看起来更有活力。</p>
<p>查看效果： <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAJElEQVRoge3BMQEAAADCoPVP7WkJoAAAAAAAAAAAAAAAAAAAbjh8AAFte11jAAAAAElFTkSuQmCC" alt=""></p>
<h2>基于预渲染的骨架屏</h2>
<p>基于预渲染的骨架屏技术通过服务器端渲染（SSR）或静态站点生成（SSG）提前生成页面的骨架，然后在客户端加载时填充内容，从而提高性能和 SEO。</p>
<h4>使用 react-loading-skeleton 创建骨架屏</h4>
<pre><code>import React from 'react';
import Skeleton from 'react-loading-skeleton';

function UserProfile() {
  return (
    &lt;div&gt;
      &lt;h2&gt;User Profile&lt;/h2&gt;
      &lt;div class&gt;
        &lt;Skeleton height={100} width={100} circle={true} /&gt;
        &lt;div class&gt;
          &lt;Skeleton height={20} width={200} /&gt;
          &lt;Skeleton height={20} width={200} /&gt;
          &lt;Skeleton height={20} width={200} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default UserProfile;
</code></pre>
<h2>骨架屏的最佳实践</h2>
<h4>保持骨架屏与实际内容的一致性</h4>
<p>为了确保用户不会感知到内容的 “跳动”，骨架屏的结构和样式应该与最终加载的内容一致。</p>
<h4>使用占位符</h4>
<p>占位符可以帮助页面保持稳定的布局，防止内容在加载完成前发生大的布局变化。</p>
<h4>优化骨架屏的性能</h4>
<p>为了提高性能，应该减小骨架屏的大小，并确保它们以最快的速度加载。</p>

<h1>精读《zustand 源码》</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7056568996157456398?searchId=20240126153450902039BAB3C63517BA67">juejin.cn</a></p>
</blockquote>
<p>zustand的使用方法。</p>
<h3>创建 store</h3>
<p>通过 <code>create</code> 函数创建 store，
传入一个函数，函数参数包括 <code>get</code> <code>set</code> ,他可以获取 store 瞬时值与修改 store。
返回一个 hook 可以在 React 组件中访问 store。</p>
<pre><code class="language-js">import create from 'zustand'

const useStore = create((set, get) =&gt; ({
  bears: 0,
  increasePopulation: () =&gt; set(state =&gt; ({ bears: state.bears + 1 })),
  removeAllBears: () =&gt; set({ bears: 0 })
}))
</code></pre>
<p>所有函数都支持异步，因为修改 store 并不依赖返回值，而是调用 <code>set</code>，所以是否异步对数据流框架来说都一样。</p>
<h2>创建多实例 store</h2>
<p>可以通过 <code>createContext</code> 方式创建多实例 store，结合 Provider 使用：</p>
<pre><code>import create from 'zustand'
import createContext from 'zustand/context'
const { Provider, useStore } = createContext()
const createStore = () =&gt; create(...)
const App = () =&gt; (
  &lt;Provider createStore={createStore}&gt;
    ...
  &lt;/Provider&gt;
)
</code></pre>
<h3>访问 store</h3>
<p>通过 <code>useStore</code> 在组件中访问 store。
与 redux 不同的是，</p>
<ul>
<li>无论普通数据还是函数都可以存在 store 里，且函数也通过 selector 语法获取。</li>
<li>因为函数引用不可变，所以实际上下面第二个例子不会引发重渲染：</li>
</ul>
<pre><code class="language-js">function BearCounter() {
  const bears = useStore(state =&gt; state.bears)
  return &lt;h1&gt;{bears} around here ...&lt;/h1&gt;
}

function Controls() {
  const increasePopulation = useStore(state =&gt; state.increasePopulation)
  return &lt;button onClick={increasePopulation}&gt;one up&lt;/button&gt;
}
</code></pre>
<p>如果嫌访问变量需要调用多次 <code>useStore</code> 麻烦，可以自定义 compare 函数返回一个对象：</p>
<pre><code class="language-js">const { nuts, honey } = useStore(state =&gt; ({ nuts: state.nuts, honey: state.honey }), shallow)
</code></pre>
<h3>细粒度 memo</h3>
<p>利用 <code>useCallback</code> 甚至可以跳过普通 compare，而仅关心外部 id 值的变化，如：</p>
<pre><code class="language-js">const fruit = useStore(useCallback(state =&gt; state.fruits[id], [id]))
</code></pre>
<p>原理是 id 变化时，<code>useCallback</code> 返回值才会变化，而 <code>useCallback</code> 返回值如果不变，<code>useStore</code> 的 compare 函数引用对比就会为 <code>true</code>，非常巧妙。</p>
<h3>set 合并与覆盖</h3>
<p><code>set</code> 函数第二个参数默认为 <code>false</code>，即合并值而非覆盖整个 store，所以可以利用这个特性清空 store：</p>
<pre><code>const useStore = create(set =&gt; ({
  salmon: 1,
  tuna: 2,
  deleteEverything: () =&gt; set({ }, true), // clears the entire store, actions included
}))
</code></pre>
<h3>监听指定变量</h3>
<p>还是用英文比较表意，即 <code>subscribeWithSelector</code>，这个中间件可以让我们把 selector 用在 subscribe 函数上，相比于 redux 传统的 subscribe，就可以有针对性的监听了：</p>
<pre><code class="language-js">import { subscribeWithSelector } from 'zustand/middleware'
const useStore = create(subscribeWithSelector(() =&gt; ({ paw: true, snout: true, fur: true })))

// Listening to selected changes, in this case when &quot;paw&quot; changes
const unsub2 = useStore.subscribe(state =&gt; state.paw, console.log)
// Subscribe also exposes the previous value
const unsub3 = useStore.subscribe(state =&gt; state.paw, (paw, previousPaw) =&gt; console.log(paw, previousPaw))
// Subscribe also supports an optional equality function
const unsub4 = useStore.subscribe(state =&gt; [state.paw, state.fur], console.log, { equalityFn: shallow })
// Subscribe and fire immediately
const unsub5 = useStore.subscribe(state =&gt; state.paw, console.log, { fireImmediately: true })
</code></pre>
<p>后面还有一些结合中间件、immer、localstorage、redux like、devtools、combime store 就不细说了，都是一些细节场景。值得一提的是，所有特性都是正交的。</p>
<h2>精读</h2>
<p>其实大部分使用特性都在利用 React 语法，所以可以说 50% 的特性属于 React 通用特性，只是写在了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fpmndrs%2Fzustand" title="https://github.com/pmndrs/zustand">zustand</a> 文档里，</p>
<h3>创建 store 实例</h3>
<p>任何数据流管理工具，都有一个最核心的 store 实例。
对 zustand 来说，便是定义在 <code>vanilla.ts</code> 文件的 <code>createStore</code> 了。</p>
<h2>createStore</h2>
<p>我们看 <code>createStore</code> 的定义与结尾：</p>
<pre><code class="language-js">function createStore(createState) {
  let state: TState
  const setState = /** ... */
  const getState = /** ... */
  /** ... */
  const api = { setState, getState, subscribe, destroy }
  state = createState(setState, getState, api)
  return api
}
</code></pre>
<p>虽然这个 <code>state</code> 是个简单的对象，但回顾使用文档，我们可以在 <code>create</code> 创建 store 利用 callback 对 state 赋值，那个时候的 <code>set</code>、<code>get</code>、<code>api</code> 就是上面代码倒数第二行传入的：</p>
<pre><code>import { create } from 'zustand'

const useStore = create((set, get) =&gt; ({
  bears: 0,
  increasePopulation: () =&gt; set(state =&gt; ({ bears: state.bears + 1 })),
  removeAllBears: () =&gt; set({ bears: 0 })
}))
</code></pre>
<p>至此，初始化 store 的所有 API 的来龙去脉就梳理清楚了，逻辑简单清晰。
<code>createStore</code> 返回一个类似 redux store 的数据管理实例，拥有四个非常常见的 API：</p>
<pre><code>export type StoreApi&lt;T extends State&gt; = {
  setState: SetState&lt;T&gt;
  getState: GetState&lt;T&gt;
  subscribe: Subscribe&lt;T&gt;
  destroy: Destroy
}
</code></pre>
<h3>getState</h3>
<p>首先 <code>getState</code> 的实现：</p>
<pre><code>const getState: GetState&lt;TState&gt; = () =&gt; state
</code></pre>
<p>就是这么简单粗暴。再看 <code>state</code>，就是一个普通对象：</p>
<pre><code>let state: TState
</code></pre>
<p>这就是数据流简单的一面，没有魔法，数据存储用一个普通对象，仅此而已。</p>
<h3>setState</h3>
<p>接着看 <code>setState</code>，它做了两件事，修改 <code>state</code> 并执行 <code>listenser</code>：</p>
<pre><code>const setState: SetState&lt;TState&gt; = (partial, replace) =&gt; {
  const nextState = typeof partial === 'function' ? partial(state) : partial
  if (nextState !== state) {
    const previousState = state
    state = replace ? (nextState as TState) : Object.assign({}, state, nextState)
    listeners.forEach((listener) =&gt; listener(state, previousState))
  }
}
</code></pre>
<p>修改 <code>state</code> 也非常简单，
唯一重要的是 <code>listener(state, previousState)</code>，那么这些 <code>listeners</code> 是什么时候注册和声明的呢？</p>
<p><code>listeners</code> 就是一个 Set 对象：</p>
<pre><code>const listeners: Set&lt;StateListener&lt;TState&gt;&gt; = new Set()
</code></pre>
<p>注册和销毁时机分别是 <code>subscribe</code> 与 <code>destroy</code> 函数调用时，这个实现很简单、高效。显然，<code>subscribe</code> 时注册的监听函数会作为 <code>listener</code> 添加到 <code>listeners</code> 队列中，当发生 <code>setState</code> 时便会被调用。</p>
<h3>create 函数的实现</h3>
<p>上面我们说清楚了如何创建 store 实例，但这个实例是底层 API，使用文档介绍的 <code>create</code> 函数在 <code>react.ts</code> 文件定义，并调用了 <code>createStore</code> 创建框架无关数据流。之所 <code>create</code> 定义在 <code>react.ts</code>，是因为返回的 <code>useStore</code> 是一个 Hooks，所以本身具有 React 环境特性，因此得名。</p>
<p>该函数第一行就调用 <code>createStore</code> 创建基础 store，因为对框架来说是内部 API，所以命名也叫 api：</p>
<pre><code>const api: CustomStoreApi = typeof createState === 'function' ? createStore(createState) : createState

const useStore: any = &lt;StateSlice&gt;(
  selector: StateSelector&lt;TState, StateSlice&gt; = api.getState as any,
  equalityFn: EqualityChecker&lt;StateSlice&gt; = Object.is
) =&gt; /** ... */
</code></pre>
<p>接下来所有代码都在创建 <code>useStore</code> 这个函数，我们看下其内部实现：</p>
<p>简单来说就是利用 <code>subscribe</code> 监听变化，并在需要的时候强制刷新当前组件，并传入最新的 <code>state</code> 给到 <code>useStore</code>。所以第一步当然是创建 <code>forceUpdate</code> 函数:</p>
<pre><code>const [, forceUpdate] = useReducer((c) =&gt; c + 1, 0) as [never, () =&gt; void]
</code></pre>
<p>然后通过调用 API 拿到 <code>state</code> 并传给 selector，并调用 <code>equalityFn</code>（这个函数可以被定制）判断状态是否发生了变化：</p>
<pre><code>const state = api.getState()
newStateSlice = selector(state)
hasNewStateSlice = !equalityFn(
  currentSliceRef.current as StateSlice,
  newStateSlice
)
</code></pre>
<p>如果状态变化了，就更新 <code>currentSliceRef.current</code>：</p>
<pre><code>useIsomorphicLayoutEffect(() =&gt; {
  if (hasNewStateSlice) {
    currentSliceRef.current = newStateSlice as StateSlice
  }
  stateRef.current = state
  selectorRef.current = selector
  equalityFnRef.current = equalityFn
  erroredRef.current = false
})
</code></pre>
<blockquote>
<p><code>useIsomorphicLayoutEffect</code> 是同构框架常用 API 套路，在前端环境是 <code>useLayoutEffect</code>，在 node 环境是 <code>useEffect</code>：</p>
</blockquote>
<p>说明一下 <code>currentSliceRef</code> 与 <code>newStateSlice</code> 的功能。我们看 <code>useStore</code> 最后的返回值：</p>
<pre><code>const sliceToReturn = hasNewStateSlice
  ? (newStateSlice as StateSlice)
  : currentSliceRef.current
useDebugValue(sliceToReturn)
return sliceToReturn
</code></pre>
<p>发现逻辑是这样的：如果 state 变化了，则返回新的 state，否则返回旧的，这样可以保证 compare 函数判断相等时，返回对象的引用完全相同，这个是不可变数据的核心实现。另外我们也可以学习到阅读源码的技巧，即要经常跳读。</p>
<p>那么如何在 selector 变化时更新 store 呢？中间还有一段核心代码，调用了 <code>subscribe</code>，相信你已经猜到了，下面是核心代码片段：</p>
<pre><code>useIsomorphicLayoutEffect(() =&gt; {
  const listener = () =&gt; {
    try {
      const nextState = api.getState()
      const nextStateSlice = selectorRef.current(nextState)
      if (!equalityFnRef.current(currentSliceRef.current as StateSlice, nextStateSlice)) {
        stateRef.current = nextState
        currentSliceRef.current = nextStateSlice
        forceUpdate()
      }
    } catch (error) {
      erroredRef.current = true
      forceUpdate()
    }
  }
  const unsubscribe = api.subscribe(listener)
  if (api.getState() !== stateBeforeSubscriptionRef.current) {
    listener() // state has changed before subscription
  }
  return unsubscribe
}, [])
</code></pre>
<p>这段代码要先从 <code>api.subscribe(listener)</code> 看，这使得任何 <code>setState</code> 都会触发 <code>listener</code> 的执行，而 <code>listener</code> 利用 <code>api.getState()</code> 拿到最新 <code>state</code>，并拿到上一次的 compare 函数 <code>equalityFnRef</code> 执行一下判断值前后是否发生了改变，如果改变则更新 <code>currentSliceRef</code> 并进行一次强制刷新（调用 <code>forceUpdate</code>）。</p>
<h3>context 的实现</h3>
<p>注意到 context 语法，可以创建多个互不干扰的 store 实例：</p>
<pre><code>import create from 'zustand'
import createContext from 'zustand/context'

const { Provider, useStore } = createContext()

const createStore = () =&gt; create(...)

const App = () =&gt; (
  &lt;Provider createStore={createStore}&gt;
    ...
  &lt;/Provider&gt;
)
</code></pre>
<p>首先我们知道 <code>create</code> 创建的 store 是实例间互不干扰的，问题是 <code>create</code> 返回的 <code>useStore</code> 只有一个实例，也没有 <code>&lt;Provider&gt;</code> 声明作用域，那么如何构造上面的 API 呢？
首先 <code>Provider</code> 存储了 <code>create</code> 返回的 <code>useStore</code>：</p>
<pre><code>const storeRef = useRef&lt;TUseBoundStore&gt;()
storeRef.current = createStore()
</code></pre>
<p>那么 <code>useStore</code> 本身其实并不实现数据流功能，而是将 <code>&lt;Provider&gt;</code> 提供的 <code>storeRef</code> 拿到并返回：</p>
<pre><code class="language-js">const useStore: UseContextStore&lt;TState&gt; = &lt;StateSlice&gt;(
  selector?: StateSelector&lt;TState, StateSlice&gt;,
  equalityFn = Object.is
) =&gt; {
  const useProviderStore = useContext(ZustandContext)
  return useProviderStore(
    selector as StateSelector&lt;TState, StateSlice&gt;,
    equalityFn
  )
}
</code></pre>
<p>所以核心逻辑还是是现在 <code>create</code> 函数里，<code>context.ts</code> 只是利用 ReactContext 将 <code>useStore</code> “注入” 到组件，且利用 ReactContext 特性，这个注入可以存在多个实例，且不会相互影响。</p>
<h3>中间件</h3>
<p>中间件其实不需要怎么实现。比如看这个 redux 中间件的例子：</p>
<pre><code>import { redux } from 'zustand/middleware'
const useStore = create(redux(reducer, initialState))
</code></pre>
<p>可以将 zustand 用法改变为 reducer，实际上是利用了函数式理念，redux 函数本身可以拿到 <code>set, get, api</code>，如果想保持 API 不变，则原样返回 callback 就行了，如果想改变用法，则返回特定的结构，就是这么简单。</p>
<p>为了加深理解，我们看看 redux 中间件源码：</p>
<pre><code>export const redux = ( reducer, initial ) =&gt; ( set, get, api ) =&gt; {
  api.dispatch = action =&gt; {
    set(state =&gt; reducer(state, action), false, action)
    return action
  }
  api.dispatchFromDevtools = true
  return { dispatch: (...a) =&gt; api.dispatch(...a), ...initial }
}
</code></pre>
<p>将 <code>set, get, api</code> 封装为 redux API：<code>dispatch</code> 本质就是调用 <code>set</code>。</p>
