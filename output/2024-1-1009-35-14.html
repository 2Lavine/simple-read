<h1>2023-12-30</h1><p>各种 merge 的区别
<img src="file://Mac/Home/myGitHubMac/simple-read/_resources/Pasted image 20231230171324.png" /></p>
<p>fast-forward</p>
<ul>
<li>没有合并记录
<ul>
<li>Git 只需要移动分支指针向前，因为所有的提交都是当前分支所缺失的。
No Fast-Forward</li>
</ul>
</li>
<li>保留了一个明确的分支结构,可以清晰看到何时以及为何进行了合并
Squash</li>
<li>将要合并的分支的所有提交压缩成一个新的提交。</li>
</ul>

<h1>2024-01-01</h1><p>过度追求事业和过度思考，本来是为了寻求安全感，却可能严重伤害心理与身体健康。
过度的追求同样潜藏着不好的一面，需要引起我们的警惕。</p>
<ul>
<li>我们以为，如果过度追求成就或者过度思考，就能避免受到伤害——避免被他人责怪、控制或拒绝。</li>
<li>实际上，当我们长期过度行为时，我们反而伤害了自己，给心理和身体健康带来了真实的后果。</li>
</ul>
<h2>成长与恐惧</h2>
<hr>
<p>新年改变习惯往往基于这样一种传统观念：你需要做更多事情才能变得更好。
成长是值得追求的。但我们常说我们追求的是成长，实际上可能是在逃避恐惧。</p>
<ul>
<li>当我们更加有意识地关注大脑如何驱动我们的行为时，我们就有了构建我们真正追求的东西的机会：一种持续的内心安全感。</li>
</ul>
<h2>过度行为</h2>
<p>“过度行为”（the Overs）这包括</p>
<ul>
<li>过度工作（overworking）、过度追求（overachieving）、过度思考（overthinking）、过度解释（overexplaining）、过度给予（overgiving）、过度承诺（overcommitting）以及过度适应（overaccommodating）。</li>
</ul>
<h2>过度行为与平衡</h2>
<p>“过度行为”，是为了给自己营造一种心理安全感而采取的行为。
这一种调节神经系统的方式。当你感到焦虑、压力、挫败感或不确定时，因为你大脑中的威胁网络被激活了：你在害怕。为了恢复平衡，你采取了一些补偿性行为，以减轻你的恐惧感。</p>
<ul>
<li>比如，你可能会因为害怕老板发怒而加班加点，但更深层的原因是为了缓解这种担忧所带来的*压力。</li>
</ul>
<h2>过渡行为变成了压力源</h2>
<p>然而，常常是这些“过度行为”本身成了我们生活中的主要心理压力源。、
过度做事是一种自我保护的方式。问题在于，这种做法最终对我们不利。</p>
<p>思考过度追求成就——这种对高绩效不懈的追求。
人们普遍认为，“努力做到最好”是一种能提升生产力的韧性。</p>
<ul>
<li>研究发现过度追求者典型的完美主义与实际绩效之间并无关联。换言之，不断努力成为最优秀的表现者，并不意味着你就能成为最佳。</li>
</ul>
<p>这种追求在心理和身体健康方面有严重的负面影响。</p>
<ul>
<li>完美主义与更严重的焦虑和抑郁情绪有关。</li>
<li>过度追求与奖励相关神经回路之间you关系
<ul>
<li>过度追求者的多巴胺水平较高，这种神经递质与动机和成瘾有关。</li>
<li>大脑会产生强烈的渴望，使我们不断过度努力——你越是这样做，就越想继续这样做。</li>
</ul>
</li>
</ul>
<h2>过度思考无效</h2>
<p>如果过度思考真的有效，那么它应该能帮助我们解决生活中的更多问题。</p>
<ul>
<li>然而，研究显示恰恰相反。过度思考会导致决策能力下降、人际问题增多，以及心理压力加剧。思考问题的目的是为了减少困扰，而不是加剧问题。</li>
</ul>
<hr>
<p>以下是三种简单的策略，可帮助您在生活中停止过度行为。</p>
<h3>制定新界限，准备迎接不适感。</h3>
<p>想要避免过度行为，就得做好在行动更加平衡时短期内感到不安的准备。</p>
<ul>
<li>过度行为（Overfunctioning）=过度警觉（hypervigilance）的策略，是大脑为防范潜在风险而调整行为的一种方式。
<ul>
<li>比如，如果你决定新年后晚上 7 点后不检查邮件，到了晚上 7 点，大脑就会发出警报：<em>你是不是错过了什么重要信息？老板会不会因此生气？</em> 如果你屈服于这种冲动，实际上是在加固你本想改变的行为。</li>
</ul>
</li>
</ul>
<p>但如果你坚持新设定的界限，大脑很快就会适应。
习惯化 (habituation) 是克服恐惧最有效的方法之一。</p>
<ul>
<li>习惯化指的是反复让自己面对起初让你害怕的事物，多次面对后，大脑就会意识到这些事物并非危险。</li>
</ul>
<h3>分辨危险与不喜欢的差异。</h3>
<p>在设定这些新界限时，你可能会面临一些真实的后果。</p>
<ul>
<li>比如，如果你不再过度迁就朋友、家人和同事，他们可能会感到失望。
<ul>
<li>你可能不喜欢这种感觉，但这并不等同于危险。</li>
</ul>
</li>
<li>研究显示，人们往往高估了自己决策的负面影响。</li>
</ul>
<p>真正伤害你的，是长期逃避这些决策可能引发的负面情绪。</p>
<ul>
<li>逃避和否认消耗巨大的心理能量，并且往往会使我们的生活变得更糟。</li>
<li>以创伤后应激障碍（PTSD）为例：如果某人在军事行动中经历了创伤，PTSD 的痛苦通常在后期显现，比如他们可能会避免开车经过郊区街道等日常活动。
<ul>
<li>人们之所以避免这些活动，并非因为它们本身危险，而是因为他们认为自己的<em>感受</em>是危险的。
尽管 PTSD 是一个极端案例，但类似的逻辑也适用于我们的日常生活。我们可能认为直面内心的感受是危险的，但实际上，能够区分真正的危险和简单的不喜欢，反而会给我们带来宽慰。</li>
</ul>
</li>
</ul>
<h3>思考一下，你可能是自己生活中最大的威胁。</h3>
<p>在我的工作经验中，这个观念对人们产生了深刻的影响。</p>
<ul>
<li>通常，我们之所以过度努力，是因为我们感觉到“他人”不可靠——
<ul>
<li>担心他人会拒绝、伤害或让我们失望。</li>
<li>当你一次又一次地通过他人的认可、允许或情绪来寻求心理上的安全感时，你可能会暂时感到舒适，但这实际上破坏了你自身的安全感。
<ul>
<li>你让自己相信，维持你神经系统稳定所需的不是自己的内心权威，而是别人的同意。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这样一来，你对自己的工作量、付出或所做的事情失去了掌控，而是由别人来决定。
这常常导致过度工作。
相反，我们应该意识到，真正决定我们安全感的，只有我们自己。</p>

<h1>2024-01-09</h1><p>A发送一个带有随机初始串行号（ISN）的SYN（同步）报文给B，</p>
<ul>
<li>Seq字段=ISN_A
B接收到A的SYN报文后，返回一个 SYN-ACK 报文</li>
<li>seq字段=ISN_B</li>
<li>Ack字段=ISN_A + 1 表示下一个希望接收到的
A接收到B的SYN-ACK报文后，发送一个确认报文，</li>
<li>Seq字段=ISN_A + 1，</li>
<li>Ack字段=ISN_B + 1。
创建连接阶段：</li>
</ul>
<p>A: |------------[SYN]-------------| (Seq=ISN_A, Ack=0)</p>
<p>B: |------------[SYN-ACK]-------------| (Seq=ISN_B, Ack=ISN_A + 1)</p>
<p>A: |------------[ACK]-------------| (Seq=ISN_A + 1, Ack=ISN_B + 1)</p>
<p>数据传输阶段：</p>
<p>A: |--------[Data A]--------| (Seq=ISN_A + 1, Ack=ISN_B + 1)</p>
<p>B:             |----------------[ACK]------------------| (Ack=ISN_A + 1 + len(Data A))</p>
<p>A:                    |----------------[Data B]-----------------| (Seq=ISN_A + 1 + len(Data A), Ack=ISN_B + 1)</p>
<p>B:                               |----------------[ACK]------------------| (AckISN_A + 1 + len(Data A)+len(Data B)</p>
<p>Seq 表示这个报文序列号
ack 表示 下一次希望接收到的报文序列号</p>

<h1>Compile</h1><h1>Parse</h1>
<ul>
<li>mkdom( )  =&gt; return Children
<ul>
<li>if chsildren is tag =&gt; <a href="">[#createComponents]</a>=&gt; components</li>
<li>GetJS( ) =&gt; js</li>
</ul>
</li>
<li>{components,js}</li>
</ul>
<h2>createComponents</h2>
<ul>
<li>[[#getComponentsName]]</li>
<li>getJS( )  from component</li>
<li><a href="">[#compileNode]</a>
RETURN  string（convert from a obj）</li>
</ul>
<h3>getComponentsName</h3>
<p>用来调用nue里面创建的组件
通过</p>
<pre><code>attribs['@name'] || attribs['data-name'] || attribs.id
</code></pre>
<p>来创建
不允许有 HTML 默认的名字</p>
<h3>compileNode</h3>
<ol>
<li>处理 attributes 的语法
<ol>
<li>预处理一下语法糖
<ol>
<li>class=&quot;{}&quot; --&gt; :class=&quot;{}&quot;</li>
<li>:disabled -&gt; $disabled （if is a boolean attribute）</li>
</ol>
</li>
<li>处理@event
<ol>
<li>待续</li>
</ol>
</li>
<li>处理 :for</li>
<li>处理其他包含$或:的属性
<ol>
<li>属性对应的值包含了{}
<ol>
<li>解析 expression，并且用数组包裹，添加到expression数组里</li>
</ol>
</li>
<li>不包含
<ol>
<li>为这个值设置上下文
<ol>
<li>默认的上下文是_ (也就是 foo=&gt;_.foo )挂载到_上，由_来调用</li>
<li>如果是JS 自带对象的，则把上下文给JS自带对象</li>
</ol>
</li>
</ol>
</li>
<li>将属性对应的值变成 expression 的数组索引</li>
</ol>
</li>
</ol>
</li>
<li>处理content 中的{}
<ol>
<li>获取被{{xxx}} 包含的 字符串html</li>
<li>如果存在 html
<ol>
<li>为这个值设置上下文,并且添加到expression数组里</li>
<li>给父组件添加 :html: index in expression</li>
<li>将组件的 data值置空</li>
</ol>
</li>
<li>如果不存在 html
<ol>
<li>解析 expression，并且用数组包裹，添加到expression数组里</li>
<li>将自身的 data 改为expression的索引 格式为:index:</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3>setContext</h3>
<p>如果 split 的separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。</p>
<ul>
<li>捕获括号就是 正则表达式的 （）</li>
</ul>
<h2>Compile生成的数据</h2>
<p>name
tageName
tmpl
Impl： 一个类，绑定了所有需要的数据和方法
fns: 包含了执行函数的数组，对应了exprs ； compile 会把变换的数据变成 fns 中的下标</p>

<h1>Event</h1><h1>字体</h1>
<p>const poppins = Poppins({
subsets: ['latin'],
weight: ['400', '500', '600', '700'],
variable: '--font-poppins',// 用来标识
})
subsets 表示包含哪些字符，这里只对拉丁符号进行字体的设置
使用时在 className 用 poppins.variable</p>
<p>#tailwind
在 Tailwind CSS 中，@layer 指令用于定义样式层级，以便更好地组织和管理你的样式
@layer utilities：这个层级用于定义实用工具类，例如 bg-red-500、p-4 等。这些类通常用于快速应用一些常见的样式规则，如间距、颜色、背景等。
@layer components：在这个层级中，你可以定义组件级别的样式规则，例如按钮、卡片、导航栏等组件的样式。
@layer base：这个层级用于定义基础层级的样式规则，包括全局样式、文本样式、链接样式等。这些样式会在其他层级的样式之前加载和应用，确保了全局一致性。</p>
<h1>Home</h1>
<p>#next/page/读取参数
Params : slash 后面的参数
app/shop/[slug]/page.js	/shop/1	{ slug: '1' }
app/shop/[category]/[item]/page.js	/shop/1/2	{ category: '1', item: '2' }
SeachParams： 问号 后面的参数</p>
<p>#可选链和强制链
？防止前面的对象是空对象
!. 是空对象强制执行。
如果对象为 null 或 undefined，它会强制执行操作，即使这可能导致错误
#??的使用
与 || 操作符相比，?? 更适合处理严格的空值情况，
因为 || 在左侧的值为假值（false、0、空字符串等）时也会返回右侧的值，
而 ?? 只在左侧的值为 null 或 undefined 时才返回右侧的值</p>
<p>#css/background-size
background-size用于指定背景的现实方式，通常和background-image一起用
cover：背景图像会被等比例缩放,会裁切
contain: 比例裁切，不会裁切
(这些值 object-fit也用，object-fit用在img标签上 )</p>
<p>#css/image
object-position 用在 img 标签当中，来放置图片的位置
object-position: left bottom</p>
<h1>Header</h1>
<p>快速分布在两端
justify-between （space-between）</p>
<h2>NavItem</h2>
<p>hooks 读取路径和参数
usePathName
useParams</p>
<p>#shadcn
use the buttonVariants helper to create a link that looks like a button.
asChild 可以起同样的作用</p>
<pre><code class="language-js">&lt;Link className={buttonVariants({ variant: &quot;outline&quot; })}&gt;Click here&lt;/Link&gt;
&lt;Button asChild&gt;
  &lt;Link href=&quot;/login&quot;&gt;Login&lt;/Link&gt;
&lt;/Button&gt;
</code></pre>
<h1>Form</h1>
<p>使用revalidatePath来清除对应页面的缓存数据
allows you to purge cached data on-demand for a specific path.</p>
<h1>React hook Form</h1>
<p>使用方法 1：</p>
<ol>
<li>使用 useForm() 获得对应的 form 对象
<ol>
<li>可以通过z.infer&lt;typeof eventFormValidator&gt; 来获取 form 里面的类型</li>
</ol>
</li>
<li>使用 control={form.control} 来控制对应的 FormItem</li>
<li></li>
</ol>
<h1>MongoDB 数据库</h1>
<ol>
<li>创建一个Schema
<ol>
<li>方法： new Scheme()</li>
<li>参数对象：形如
<ol>
<li>{name: { type: String, required: true, unique: true }}</li>
</ol>
</li>
<li>By default Mongoose adds an _id property to your schemas.</li>
<li>Scheme 可以命名方法</li>
</ol>
</li>
<li>创建一个 Model
<ol>
<li>方法： model： model('Category', CategorySchema)</li>
<li>可以通过models.Category来检验是否已经创建：
<ol>
<li>models.Category || model('Category', CategorySchema)
数据库 CRUD</li>
</ol>
</li>
</ol>
</li>
<li>创建数据库条目：
<ol>
<li>Model.create(obj) Category.create({ name: categoryName })</li>
</ol>
</li>
<li>找到所有条目
<ol>
<li>Const categories = await Category.find();</li>
</ol>
</li>
<li>找到其他条目
<ol>
<li>find 里面接受一个 condition 可以用来筛选</li>
<li>$and 表示两个 condtion 都要满足</li>
<li>{ title: { $regex: query, $options: 'i' } } 表示匹配 title 是 query 的类型，
<ol>
<li>option 是 i 表示忽略大小写</li>
</ol>
</li>
<li>{$and: [titleCondition, categoryCondition ? { category: categoryCondition._id } : {}],}</li>
<li>找到的对象不能修改，返回一个 deep clone的数据</li>
</ol>
</li>
<li>更新
<ol>
<li>const updatedEvent = await Event.findByIdAndUpdate(</li>
</ol>
</li>
<li>删除
<ol>
<li>const deletedEvent = await Event.findByIdAndDelete(eventId)</li>
</ol>
</li>
</ol>
<p>Populate方法
populate lets you pull in referenced documents from another collection
它允许你从另一个文档拉取对应的信息，有点类似与left join</p>
<pre><code class="language-js">const people = await Person.create([{ name: 'James Cameron' }]);
await Movie.create({
  title: 'Terminator 2',
  director: people[0]._id,
  actors: [people[1]._id, people[2]._id]
});

// Load just the movie's director
let movie = await Movie.findOne().populate('director');
movie.director.name; // 'James Cameron'
</code></pre>
<p>If you call populate() multiple times with the same path, only the last one will take effect.</p>
<h2>aggregate</h2>
<p>接受一个数组 an array of stages</p>
<ul>
<li>A stage is an object description of how MongoDB  transform any document coming into the stage</li>
<li>The first stage feeds documents into the second stage, and so on,
$lookup用途类似于 左连接</li>
</ul>
<pre><code>    $lookup: {
      from: &quot;users&quot;,          // 关联的集合名称
      localField: &quot;userId&quot;,   // 本地集合的关联字段
      foreignField: &quot;_id&quot;,    // 外部集合的关联字段
      as: &quot;user&quot;              // 结果中嵌套的字段名
    }
</code></pre>
<p>unwind 的用途：数组类型的字段拆分成多个文档，可以在展开后的文档上执行各种聚合操作，例如计数、求和、平均值、分组等</p>
<p>project 对拆分之后的文档重新分组</p>
<pre><code class="language-js">  {
	$project: {
	  _id: 1, // 1 表示保留该选项
	  eventTitle: '$event.title', //表示对这个重新命名
	  buyer: {
		$concat: ['$buyer.firstName', ' ', '$buyer.lastName'],
		 // $concat 表示运算法，将 这两个字符串合并
	  },
	},
  },
</code></pre>
<h2>left  join</h2>
<p>返回左表的所有数据，无论有匹配的有表数据（用 NULL 代替）</p>
<pre><code class="language-sql">SELECT employees.ID, employees.Name, departments.DeptName
FROM employees
LEFT JOIN departments ON employees.DeptID = departments.DeptID;
</code></pre>
<h1>删除操作</h1>
<p>#react/startTransition
用途：不阻塞 UI 的情况下更新状态</p>
<ol>
<li>参数：state update函数（也就是 SetXX函数）
<ol>
<li>有时候你可能调用第三方包，不能拥有Set 函数，你可以使用useDeferredValue
<ol>
<li>useDeferredValue是用来对some prop or a custom Hook return value进行转换的</li>
</ol>
</li>
<li>参数必须是同步函数。</li>
<li>React 立即执行传入的函数，将其执行时发生的所有状态更新标记为转换
<ol>
<li>转换的状态更新将被其他状态更新中断</li>
</ol>
</li>
</ol>
</li>
<li>不提供isPending 状态， 需要可以用 useTransition</li>
</ol>
<h1>Event Page</h1>
<p>grid-cols-1 md:grid-cols-2
表示有一列  md 以上是两列（ grid-template-colums: 1fr）</p>
<h1>获取页面 路径的传统方法</h1>
<p>window.location获取和操作当前浏览器窗口的 URL 信息</p>
<ol>
<li>当前页面的 URL window.location.href;</li>
<li>window.location.pathname;</li>
<li>const searchParams = window.location.search;</li>
<li>可以直接修改，然后重定向到另外的界面</li>
</ol>
<p>#ts/type
searchProps 的书写
searchParams: { [key: string]: string | string[] | undefined }</p>
<p>new URLSearchParams 把 location.search 转换成一个对象</p>
<ol>
<li>get(key)  has(key) set(key,value)</li>
<li>getAllkeys，values</li>
</ol>
<h1>Search 组件的封装</h1>
<p>这里我们希望可以把 Search 的结果进行URL 分享，因此</p>
<ul>
<li>当 Input 组件变换的时候我们应该在 Path 进行参数的相关修改，然后在 Page 页面根据不同的参数来加载不同的数据</li>
<li>实现了 input 组件和 page 页面的分离
router直接 push</li>
</ul>
<ol>
<li>使用了防抖：
<ol>
<li>use Effect return 的remove timeID
useEffect 在卸载的时候把 timeID 去掉可以直接实现Debounc的效果</li>
</ol>
</li>
</ol>
<h1>Card 组件</h1>
<p>直接在 Link 里面用style={{backgroundImage: <code>url(${event.imageUrl})</code>}}
实现背景图片
父组件用grid-cols-3 固定实现 卡片展示</p>
<h3>RevalidatePath</h3>
<p>详情见 https://www.youtube.com/watch?v=RadgkoJrhu0&amp;t=492s</p>
<h1>亮点</h1>
<ol>
<li>使用 searchParams  实现筛选结果可以 url 分享</li>
<li>防抖优化 use Effect return 的remove timeID</li>
<li>响应式设计</li>
</ol>

<h1>Nuejs SSR</h1><p>selfClose
将自封闭的 tag 改成 不是自封闭的</p>
<ol>
<li>找到所有 /&gt;结尾的字符串，并一一执行一下操作
<ol>
<li>找到对应的前一个 &lt; 开头字符串</li>
<li>找到匹配的 tagName 并替代</li>
</ol>
</li>
</ol>
<p>步骤：</p>
<ol>
<li>str.replace(//g, (match,index)=&gt;{}) 可以将匹配的所有元素替换
1.1 match 表示匹配的元素，index 表示 match 在 str 的索引</li>
<li>用str.lastIndexOf('&lt;', i), 获取 前一个字符串的位置</li>
<li>/&lt;([\w-]+)/.exec(slice) 匹配 （注意 tagname 是可以包含 - 的）
<ol>
<li>同理 他返回的第一个是匹配的字符串，第二个是圆括号的内容</li>
<li>['&lt;img', 'img']。</li>
</ol>
</li>
</ol>
<pre><code class="language-js">\\{([^}]+)\\}的含义 
([^}]+) 
	（ ）表示捕获组
	[]表示匹配 []+ 表示 1 个或多个
	^} 表示除了 } 匹配所有其他字符
	
</code></pre>
<h2>render</h2>
<h2>exec执行</h2>
<p>用来执行expr:
new Function('_', 'return ' + expr)
new Function(arg1, arg2, ..., argN, functionBody) 是JavaScript中的一个构造函数，用于动态创建一个新的函数。arg1, ..., argN 是新函数的参数名，而 functionBody 是新函数的执行体。</p>
<h2>isJs判断</h2>
<p>如果是对象，数组或者函数则返回 True
原文的方法</p>
<pre><code>1. obj.constructor === Object
2. Array.isArray()
3. typeof val == 'function'
</code></pre>
<p>判断 的方法</p>
<pre><code>Object.prototype.toString.call(obj) === '[object Object]'

</code></pre>
<h2>setAttribute</h2>
<h1>JS定义属性和方法</h1>
<pre><code class="language-js">{
	num0:0
	get num1(){}//getter方法不能接受参数
	method1(){}
	method2:function(){
	}
}
</code></pre>

<h1>createComponents</h1>
<h1>interview_front_nus10.27.md</h1><ol>
<li>Can you tell me about your experience with React development and how you have utilized it in your previous projects?</li>
</ol>
<p>答案：Sure, I have extensive experience with React development. In my previous projects, I have used React to build interactive and user-friendly interfaces. For example, I have leveraged React components to create reusable UI elements and effectively manage state. Additionally, I have utilized React's virtual DOM to optimize rendering performance and improve the overall user experience.</p>
<p>注意点：在回答这个问题时，需要注意使用一些专业的词汇，例如&quot;extensive experience&quot;表示丰富的经验，&quot;interactive and user-friendly interfaces&quot;表示交互性和用户友好的界面，&quot;reusable UI elements&quot;表示可重用的UI元素，&quot;virtual DOM&quot;表示虚拟DOM。同时，要注意流利地表达自己的思路和经验。</p>
<ol start="2">
<li>How familiar are you with front-end frameworks and libraries such as Vue.js, Next.js, and Webpack?</li>
</ol>
<p>答案：I am highly familiar with front-end frameworks and libraries like Vue.js, Next.js, and Webpack. I have worked on projects where I have used these technologies extensively. For example, I have built dynamic and responsive web applications using Vue.js, and I have utilized Next.js for server-side rendering and improved SEO. Additionally, I have used Webpack for bundling and optimizing the performance of my applications.</p>
<p>注意点：在回答这个问题时，要注意使用一些形容词来表示熟悉程度，例如&quot;highly familiar&quot;表示非常熟悉，&quot;extensively&quot;表示广泛地使用。同时，要用简洁明了的语言说明自己在项目中如何使用这些技术，并强调其优势和特点。</p>
<ol start="3">
<li>Can you describe your experience with back-end technologies like Node.js and Java Spring?</li>
</ol>
<p>答案：Certainly, I have experience working with back-end technologies such as Node.js and Java Spring. In my previous projects, I have used Node.js to build RESTful APIs and handle server-side logic. I have also worked with Java Spring to develop scalable and robust back-end systems. By leveraging these technologies, I have been able to create seamless communication between the front-end and back-end, ensuring smooth data transmission and efficient user interactions.</p>
<p>注意点：在回答这个问题时，要清晰地表达自己在项目中使用这些后端技术的经验。要使用一些专业的词汇，例如&quot;RESTful APIs&quot;表示符合REST原则的API接口，&quot;scalable and robust back-end systems&quot;表示可扩展和健壮的后端系统。同时，要注意语法和用词的准确性。</p>
<ol start="4">
<li>Have you worked with version control systems like Git and continuous integration/continuous deployment (CI/CD) tools like GitHub Actions or Jenkins?</li>
</ol>
<p>答案：Yes, I have extensive experience working with version control systems like Git and CI/CD tools like GitHub Actions and Jenkins. I have used Git for managing code repositories, collaborating with team members, and ensuring version control. Additionally, I have utilized CI/CD tools like GitHub Actions and Jenkins to automate the build, testing, and deployment processes, resulting in improved efficiency and reduced development cycle time.</p>
<p>注意点：在回答这个问题时，要使用一些专业的词汇，例如&quot;version control systems&quot;表示版本控制系统，&quot;collaborating with team members&quot;表示与团队成员合作，&quot;automate the build, testing, and deployment processes&quot;表示自动化构建、测试和部署流程。要注意流畅地表达自己的经验和技能。</p>
<ol start="5">
<li>Could you give an example of a project where you have implemented agile development methodologies?</li>
</ol>
<p>答案：Certainly, I have implemented agile development methodologies in several projects. One notable example is a Question and Answer website that I developed using Next.js. Throughout the project, I adopted Scrum as the agile framework and followed iterative development cycles. I collaborated closely with the team, conducted regular sprint planning meetings, and used tools like Jira to track progress. This approach allowed us to deliver incremental releases, gather user feedback, and iterate on features to ensure a high-quality end product.</p>
<p>注意点：在回答这个问题时，要清晰地说明自己在项目中采用的敏捷开发方法论，例如Scrum或者Kanban。要强调与团队的合作和项目管理方面的经验，例如每日站会、迭代开发等。同时，要注意使用一些专业的词汇，例如&quot;iterative development cycles&quot;表示迭代开发周期，&quot;incremental releases&quot;表示增量发布，&quot;gather user feedback&quot;表示收集用户反馈。</p>
<ol start="6">
<li>How do you approach optimizing performance and improving user experience in your projects?</li>
</ol>
<p>答案：When it comes to optimizing performance and improving user experience, I follow a systematic approach. Firstly, I analyze the application's performance bottlenecks using tools like Chrome DevTools or Lighthouse. Based on the findings, I implement performance optimizations such as code splitting, lazy loading, or caching to reduce load times and improve responsiveness. Additionally, I conduct user research, usability testing, and gather feedback to identify pain points and make iterative improvements to the user interface and overall experience.</p>
<p>注意点：在回答这个问题时，要清晰地解释自己的优化方法和策略。要使用一些专业的词汇，例如&quot;performance bottlenecks&quot;表示性能瓶颈，&quot;code splitting&quot;表示代码分割，&quot;usability testing&quot;表示可用性测试。要注意用简洁明了的语言解释自己的思路和方法。</p>
<ol start="7">
<li>Can you share a challenging situation you encountered during a project and how you resolved it?</li>
</ol>
<p>答案：Certainly, I faced a challenging situation during a project where we had a tight deadline to deliver a complex feature. To overcome this challenge, I organized a brainstorming session with the team to identify potential solutions and prioritize tasks. We decided to adopt an Agile approach, breaking down the feature into smaller, manageable user stories. By leveraging the team's strengths and effectively communicating and coordinating tasks, we were able to meet the deadline and deliver a high-quality solution.</p>
<p>注意点：在回答这个问题时，要描述自己面临的具体挑战和解决方案。要强调团队合作和沟通协调的重要性，例如组织头脑风暴、采用敏捷方法、分解任务等。要注意用简洁明了的语言表达自己的思路和行动。</p>
<p>希望以上回答和注意点能对你的面试准备有所帮助。祝你面试顺利！</p>
<h1>behavior question</h1>
<ol>
<li>Can you describe a time when you had to work under pressure to meet a tight deadline? How did you handle it?</li>
</ol>
<p>答案：During my internship at Tencent, we were tasked with developing a skeleton diagram of components within a tight deadline. To manage this, I prioritized tasks effectively and collaborated closely with my team. Despite the pressure, we managed to complete the project on time, which significantly improved the user navigation experience.</p>
<p>注意点：在描述情境和任务时，要具体、直接。处理行动时，要突出你的技能和策略，比如&quot;prioritize tasks&quot;和&quot;collaborate closely&quot;。描述结果时，要强调成果和影响，如&quot;complete the project on time&quot;和&quot;improved the user navigation experience&quot;。</p>
<ol start="2">
<li>Could you give an example of a project where you had to use your problem-solving skills to overcome a challenge?</li>
</ol>
<p>答案：While working on the Next.js based Question and Answer website, I faced a challenge in establishing front-end to back-end connectivity using REST API. I researched extensively and discovered a solution to solve the issue. As a result, we ensured seamless data transmission and enabled smooth user interactions.</p>
<p>注意点：回答时，要清楚地描述你面临的问题，你是如何解决它的，以及解决问题后的结果。</p>
<ol start="3">
<li>Can you tell me about a time when you had to work on a team to achieve a common goal? How did you contribute to the team's success?</li>
</ol>
<p>答案：While developing the WeChat Mini Program, our goal was to visually represent complaint reports over a period of time. I contributed to the team by utilizing Echarts technology, which resulted in a clear and intuitive display of results. This led to improved decision-making and problem-solving for our team.</p>
<p>注意点：在回答这个问题时，要强调你的合作能力和你在团队中的贡献。同时，要清楚地描述你的行动和结果。</p>
<ol start="4">
<li>Have you ever had to adapt to a significant change during a project? How did you handle it?</li>
</ol>
<p>答案：During my time at Tencent, there was a change in the project requirements midway. To adapt to this, I quickly reassessed the project plan and reallocated resources accordingly. Despite the change, we were able to deliver the project on time and meet the new requirements.</p>
<p>注意点：在描述你如何应对变化时，要强调你的适应能力和灵活性。</p>
<ol start="5">
<li>Can you describe a time when you had to use your initiative to improve a process or solve a problem at work?</li>
</ol>
<p>答案：While working on the Question and Answer website, I noticed that the loading times were high. Using my initiative, I implemented SSR web pages using Next.js and React, which significantly improved the loading times and enhanced user experience.</p>
<p>注意点：在描述你如何主动解决问题或改进流程时，要强调你的主动性和解决问题的能力。</p>
<ol start="6">
<li>Could you give an example of a complex technical concept or tool that you had to explain to a non-technical team member or stakeholder?</li>
</ol>
<p>答案：At Tencent, I had to explain the concept of component skeleton diagrams to a non-technical stakeholder. I used simple language and analogies to make the concept understandable. The stakeholder appreciated my explanation and it helped them understand the benefits of the project better.</p>
<p>注意点：在描述你如何解释复杂的技术概念时，要强调你的沟通能力和解释复杂概念的能力。</p>
<ol start="7">
<li>Can you tell me about a time when you received constructive criticism? How did you respond and what did you learn from the experience?</li>
</ol>
<p>答案：At the National University of Singapore-ISS, a professor gave me constructive feedback on my project. I took the feedback positively, improved my project based on the suggestions, and learned the importance of continuous learning and improvement.</p>
<p>注意点：在描述你如何处理建设性批评时，要强调你的开放态度和学习能力。</p>
<h1>句式</h1>
<p>理解了。以下是一些在面试中常用的句式和单词：</p>
<p>句式：</p>
<ol>
<li>&quot;During my time at..., I was tasked with...&quot;（在我在...的时候，我被分配了...的任务）</li>
<li>&quot;To manage this, I...&quot;（为了处理这个，我...）</li>
<li>&quot;Despite the..., we...&quot;（尽管有...，我们...）</li>
<li>&quot;I faced a challenge in...&quot;（我在...面临挑战）</li>
<li>&quot;I researched extensively and...&quot;（我进行了广泛的研究并且...）</li>
<li>&quot;As a result, we...&quot;（因此，我们...）</li>
<li>&quot;Our goal was to...&quot;（我们的目标是...）</li>
<li>&quot;I contributed to the team by...&quot;（我通过...为团队做出了贡献）</li>
<li>&quot;There was a change in...&quot;（在...中有一个变化）</li>
<li>&quot;To adapt to this, I...&quot;（为了适应这个，我...）</li>
<li>&quot;I noticed that...&quot;（我注意到...）</li>
<li>&quot;Using my initiative, I...&quot;（利用我的主动性，我...）</li>
<li>&quot;I had to explain...&quot;（我不得不解释...）</li>
<li>&quot;I used simple language and...&quot;（我使用了简单的语言并且...）</li>
<li>&quot;A professor gave me constructive feedback on...&quot;（一位教授给了我关于...的建设性反馈）</li>
<li>&quot;I took the feedback positively and...&quot;（我积极接受反馈并且...）</li>
</ol>
<p>单词：</p>
<ol>
<li>Deadline（截止日期）</li>
<li>Prioritize（优先处理）</li>
<li>Collaborate（合作）</li>
<li>Challenge（挑战）</li>
<li>Research（研究）</li>
<li>Contribute（贡献）</li>
<li>Goal（目标）</li>
<li>Reallocate（重新分配）</li>
<li>Initiative（主动性）</li>
<li>Improve（改进）</li>
<li>Concept（概念）</li>
<li>Stakeholder（利益相关者）</li>
<li>Analogy（类比）</li>
<li>Constructive criticism（建设性批评）</li>
<li>Continuous learning（持续学习）</li>
</ol>
<p>这些句式和单词可以帮助你更好地表达自己的想法和经验。在面试中，你可以根据自己的经历和面试官的问题灵活运用这些句式和单词。</p>
