<h1>1-10. 入口和出口的最佳实践</h1><h1>入口和出口的最佳实践 {ignore}</h1>
<p>具体情况具体分析</p>
<p>下面是一些经典场景</p>
<h2>一个页面一个JS</h2>
<p>源码结构</p>
<pre><code>|—— src 
    |—— pageA   页面A的代码目录
        |—— index.js 页面A的启动模块
        |—— ...
    |—— pageC   页面C的代码目录
        |—— main1.js 页面C的启动模块1 例如：主功能
        |—— main2.js 页面C的启动模块2 例如：实现访问统计的额外功能
        |—— ...
    |—— common  公共代码目录
        |—— ...
</code></pre>
<p>webpack配置</p>
<pre><code class="language-js">module.exports = {
    entry:{
        pageA: &quot;./src/pageA/index.js&quot;,
        pageC: [&quot;./src/pageC/main1.js&quot;, &quot;./src/pageC/main2.js&quot;]
    },
}
</code></pre>
<p>这样打包会导致打包出来具有重复代码的问题(公共代码会被重复打包)
这种方式适用于页面之间的功能差异巨大、公共代码较少的情况，这种情况下打包出来的最终代码不会有太多重复</p>
<h2>一个页面多个JS</h2>
<pre><code>|—— src
    |—— pageA   页面A的代码目录
        |—— index.js 页面A的启动模块
        |—— ...
    |—— pageB   页面B的代码目录
        |—— index.js 页面B的启动模块
        |—— ...
    |—— statistics   用于统计访问人数功能目录
        |—— index.js 启动模块
        |—— ...
    |—— common  公共代码目录
        |—— ...
</code></pre>
<p>webpack配置</p>
<pre><code class="language-js">module.exports = {
    entry:{
        pageA: &quot;./src/pageA/index.js&quot;,
        pageB: &quot;./src/pageB/index.js&quot;,
        statistics: &quot;./src/statistics/index.js&quot;
    },
}
</code></pre>
<p>这种方式适用于页面之间有一些<strong>独立</strong>、相同的功能，专门使用一个chunk抽离这部分JS有利于浏览器更好的缓存这部分内容。</p>
<blockquote>
<p>思考 为什么不使用多启动模块的方式？</p>
</blockquote>
<p>使用这种pageA: [&quot;./src/pageC/main1.js&quot;, &quot;./src/statistics/index.js&quot;]
方法会导致 statistic 不能缓存</p>
<h2>单页应用</h2>
<p>所谓单页应用，是指整个网站（或网站的某一个功能块）只有一个页面，页面中的内容全部靠JS创建和控制。 vue和react都是实现单页应用的利器。</p>
<p>源码结构</p>
<pre><code>|—— src
    |—— subFunc   子功能目录
        |—— ...
    |—— subFunc   子功能目录
        |—— ...
    |—— common  公共代码目录
        |—— ...
    |—— index.js
</code></pre>
<p>webpack配置</p>
<pre><code class="language-js">module.exports = {
    entry: &quot;./src/index.js&quot;,
    output:{
        filename:&quot;index.[hash:5].js&quot;
    }
}
</code></pre>

<h1>1-11. loader</h1><h1>loader</h1>
<p>webpack做的事情，仅仅是分析出各种模块的依赖关系，然后形成资源列表，最终打包生成到指定的文件中。</p>
<p>更多的功能需要借助webpack loaders和webpack plugins完成。</p>
<p>webpack loader： loader本质上是一个函数，它的作用是将某个源代码的字符串转换成另一个源代码的字符串返回。</p>
<p>loader函数的将在模块解析的过程中被调用，以得到最终的源码。他处于在读取文件代码和 AST 语法树之间，可以在这个阶段对代码进行处理。</p>
<p><strong>处理loaders流程：</strong></p>
<p><img src="assets/2020-01-13-10-29-54.png" alt=""></p>
<ol>
<li>当前模块满足匹配规则(module.rules[i].test)</li>
<li>读取规则中的 (rules[i].use)数组,调用 loader 对应的函数</li>
<li>可以用 rules[i].use[j].options 传递参数</li>
</ol>
<p>loader的执行顺序是从右到左，从下到上的。</p>
<p><strong>loader配置：</strong></p>
<p><strong>完整配置</strong>
在 module 里面进行配置</p>
<pre><code class="language-js">module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: [ //匹配到后应用的规则模块
                    {  //其中一个规则
                        loader: &quot;模块路径&quot;, //loader模块的路径，该字符串会被放置到require中
                        options: { //向对应loader传递的额外参数

                        }
                    }
                ]
            }
        ]
    }
}
</code></pre>
<p><strong>简化配置</strong></p>
<pre><code class="language-js">module.exports = {
    module: { //针对模块的配置，目前版本只有两个配置，rules、noParse
        rules: [ //模块匹配规则，可以存在多个规则
            { //每个规则是一个对象
                test: /\.js$/, //匹配的模块正则
                use: [&quot;模块路径1&quot;, &quot;模块路径2&quot;]//loader模块的路径，该字符串会被放置到require中
            }
        ]
    }
}
</code></pre>
<p>这里的 use 会被webpack 直接 require(模块路径1)来调用执行</p>
<h2>loader</h2>
<p>loader 是否可以使用ES6语法？
不可以因为他在打包过程中使用的,而 webpack 使用commonjs规范
loader 不经过 ast 语法树解析,依赖记录.</p>

<h1>1-12. [练习]处理样式</h1><h2>如何在js 代码中使用 import 导入 css 代码</h2>
<p>如 import './index.css'
使用 loader 处理 css 后缀的文件
将源代码改写成 js 代码 把对应的 css 添加到 document.header 中</p>
<p>(&lt;style&gt;...&lt;/style&gt;)</p>
<h2>如何在js 代码中使用 import 导入 图片</h2>
<pre><code>1. 目的是 var src = require('./img.png')
因此使用 loader 处理图片后缀的文件,可以在 js 中获取对应的路径
(如果图片资源不大,我们可以考虑使用 base64 编码的方式,减少http请求)
我们要做的是
1. 根据图片内容生成唯一图片名字
2. 把图片移动到输出目录
3. 返回图片的路径
在 loader 中返回一下代码
return `module.exports = &quot;${url}&quot;`
</code></pre>
<p>(&lt;style&gt;...&lt;/style&gt;)</p>

<h1>1-14. plugin</h1><h1>plugin</h1>
<p>loader的功能定位是转换代码，而一些其他的操作难以使用loader完成，
他一般是完成这样的任务的</p>
<ul>
<li>当xxxx时，xxxx</li>
</ul>
<p>比如：</p>
<ul>
<li>当webpack生成文件时，顺便多生成一个说明描述文件</li>
<li>当webpack编译启动时，控制台输出一句话表示webpack启动了</li>
</ul>
<p>webpack执行过程中提供了不同的事件钩子，可以在这些钩子上注册事件处理函数，完成这些功能。
而这种事情的实现是依托于plugin的</p>
<p><img src="assets/2020-01-15-12-45-16.png" alt=""></p>
<h2>plugin和 apply</h2>
<p>plugin的<strong>本质</strong>是一个带有apply方法的对象</p>
<pre><code class="language-js">var plugin = {
    apply: function(compiler){}
}
</code></pre>
<p>通常，习惯上，我们会将该对象写成构造函数的模式</p>
<pre><code class="language-js">class MyPlugin{
    apply(compiler){}
}
var plugin = new MyPlugin();
</code></pre>
<p>要将插件应用到webpack，需要把插件对象配置到webpack的plugins数组中，如下：</p>
<pre><code class="language-js">module.exports = {
    plugins:[
        new MyPlugin()
    ]
}
</code></pre>
<h2>apply方法</h2>
<p>apply方法会在初始化阶段,<strong>创建好compiler对象后调用</strong>，并向方法传入一个compiler对象</p>
<ul>
<li>compiler对象是在初始化阶段构建的，整个webpack打包期间只有一个compiler对象，</li>
<li>后续完成打包工作的是compiler对象内部创建的compilation</li>
<li>文件发生变化的时候会重新生成 compliation,但是compiler对象不会重新生成</li>
</ul>
<h2>compiler对象</h2>
<p>compiler对象提供了大量的钩子函数（hooks，可以理解为事件），plugin的开发者可以注册这些钩子函数，参与webpack编译和生成。</p>
<p>你可以在apply方法中使用下面的代码注册钩子函数:</p>
<pre><code class="language-js">class MyPlugin{
    apply(compiler){
        compiler.hooks.事件名称.事件类型(name, function(compilation){//事件处理函数
            compilation.hooks.事件名称.事件类型(name, fn)
        })
    }
}
</code></pre>
<p><strong>事件名称</strong>
即要监听的事件名，即钩子名</p>
<p><strong>事件类型</strong>
这一部分使用的是 Tapable API，这个小型的库是一个专门用于钩子函数监听的库。
它提供了一些事件类型：</p>
<ul>
<li>tap：注册一个同步的钩子函数，函数运行完毕则表示事件处理结束</li>
<li>tapAsync：注册一个基于回调的异步的钩子函数，函数通过调用一个回调表示事件处理结束</li>
<li>tapPromise：注册一个基于Promise的异步的钩子函数，函数通过返回的Promise进入已决状态表示事件处理结束</li>
</ul>
<p><strong>处理函数</strong></p>
<p>处理函数有一个事件参数<code>compilation</code></p>

<h1>1-16. 区分环境</h1><h1>区分环境 {ignore}</h1>
<p>有些时候，我们需要针对生产环境和开发环境分别书写webpack配置</p>
<p>为了更好的适应这种要求，webpack允许配置不仅可以是一个对象，还可以是一个<strong>函数</strong></p>
<pre><code class="language-js">module.exports = env =&gt; {
    return {
        //配置内容
    }
}
</code></pre>
<p>在开始构建时，webpack如果发现配置是一个函数，会调用该函数，将函数返回的对象作为配置内容，因此，开发者可以根据不同的环境返回不同的对象</p>
<p>在调用webpack函数时，webpack会向函数传入一个参数env，该参数的值来自于webpack命令中给env指定的值，例如</p>
<pre><code class="language-shell">npx webpack --env abc # env: &quot;abc&quot;

npx webpack --env.abc # env: {abc:true}
npx webpack --env.abc=1  # env： {abc:1}
npx webpack --env.abc=1 --env.bcd=2 # env: {abc:1, bcd:2}
</code></pre>
<p>这样一来，我们就可以在命令中指定环境，在代码中进行判断，根据环境返回不同的配置结果。</p>

<h1>1-17. 其他细节配置</h1><h1>其他细节配置 {ignore}</h1>
<h2>context</h2>
<pre><code class="language-js">context: path.resolve(__dirname, &quot;app&quot;)
</code></pre>
<p>该配置会影响入口和loaders的解析，</p>
<ul>
<li>入口和loaders的相对路径会以context的配置作为基准路径，</li>
<li>可以避免写很多 /src/</li>
</ul>
<p>这样，你的配置会独立于CWD（current working directory 当前执行路径）</p>
<ul>
<li>cwd = 命令行显示的路径</li>
</ul>
<h2>output</h2>
<h3>library</h3>
<pre><code class="language-js">library: &quot;abc&quot;
</code></pre>
<p>打包后的结果中，会将自执行函数的执行结果暴露给abc
也就是把入口文件打包后的结果导出给 abc</p>
<ul>
<li>原来是仅仅会执行自执行函数,而不是导出</li>
</ul>
<h3>libraryTarget</h3>
<pre><code class="language-js">libraryTarget: &quot;var&quot;
</code></pre>
<p>该配置可以更加精细的控制如何暴露入口包的导出结果</p>
<p>其他可用的值有：</p>
<ul>
<li>var：默认值，暴露给一个普通变量</li>
<li>window：暴露给window对象的一个属性</li>
<li>this：暴露给this的一个属性</li>
<li>global：暴露给global的一个属性</li>
<li>commonjs：暴露给exports的一个属性</li>
</ul>
<h2>target</h2>
<pre><code class="language-js">target:&quot;web&quot; //默认值
</code></pre>
<p>设置打包结果最终要运行的环境，常用值有</p>
<ul>
<li>web: 打包后的代码运行在web环境中</li>
<li>node：打包后的代码运行在node环境中</li>
</ul>
<h2>module.noParse</h2>
<pre><code class="language-js">noParse: /jquery/
</code></pre>
<p>不解析正则表达式匹配的模块，通常用它来忽略那些大型的单模块库，以提高<strong>构建性能</strong></p>
<ul>
<li>注意必须是单模块,不能是引用了其他模块</li>
<li>module还接受一个rules,rules 对应一个数组</li>
</ul>
<h2>resolve</h2>
<p>resolve的相关配置主要用于控制模块解析过程
一个a = require('fs')</p>
<h3>resolve.modules</h3>
<pre><code class="language-js">modules: [&quot;node_modules&quot;]  //默认值
</code></pre>
<p>当解析模块时，如果遇到导入语句，<code>require(&quot;test&quot;)</code>，webpack会从下面的位置寻找依赖的模块</p>
<ol>
<li>当前目录下的<code>node_modules</code>目录</li>
<li>上级目录下的<code>node_modules</code>目录</li>
<li>...</li>
</ol>
<h3>resolve.extensions</h3>
<pre><code class="language-js">extensions: [&quot;.js&quot;, &quot;.json&quot;]  //默认值
</code></pre>
<p>当解析模块时，遇到无具体后缀的导入语句，例如<code>require(&quot;test&quot;)</code>，会依次测试它的后缀名</p>
<ul>
<li>test.js</li>
<li>test.json</li>
</ul>
<h3>resolve.alias</h3>
<pre><code class="language-js">alias: {
  &quot;@&quot;: path.resolve(__dirname, 'src'),
  &quot;_&quot;: __dirname
}
</code></pre>
<p>有了alias（别名）后，导入语句中可以加入配置的键名，例如<code>require(&quot;@/abc.js&quot;)</code>，webpack会将其看作是<code>require(src的绝对路径+&quot;/abc.js&quot;)</code>。</p>
<p>在大型系统中，源码结构往往比较深和复杂，别名配置可以让我们更加方便的导入依赖</p>
<h2>externals</h2>
<pre><code class="language-js">externals: {
    jquery: &quot;$&quot;,
    lodash: &quot;_&quot;
}
</code></pre>
<p>从最终的bundle中排除掉配置的配置的源码，具体的源码我们通过外部来引入
这比较适用于一些第三方库来自于外部CDN的情况，这样一来，即可以在页面中使用CDN，又让bundle的体积变得更小，还不影响源码的编写</p>
<p>例如，入口模块是</p>
<pre><code class="language-js">//index.js
require(&quot;jquery&quot;)
require(&quot;lodash&quot;)
</code></pre>
<p>生成的bundle是：</p>
<pre><code class="language-js">(function(){
    ...
})({
    &quot;./src/index.js&quot;: function(module, exports, __webpack_require__){
        __webpack_require__(&quot;jquery&quot;)
        __webpack_require__(&quot;lodash&quot;)
    },
    &quot;jquery&quot;: function(module, exports){
        //jquery的大量源码
    },
    &quot;lodash&quot;: function(module, exports){
        //lodash的大量源码
    },
})
</code></pre>
<p>但有了上面的配置后，则变成了</p>
<pre><code class="language-js">(function(){
    ...
})({
    &quot;./src/index.js&quot;: function(module, exports, __webpack_require__){
        __webpack_require__(&quot;jquery&quot;)
        __webpack_require__(&quot;lodash&quot;)
    },
    &quot;jquery&quot;: function(module, exports){
        module.exports = $;
    },
    &quot;lodash&quot;: function(module, exports){
        module.exports = _;
    },
})
</code></pre>
<h2>stats</h2>
<p>stats控制的是构建过程中控制台的输出内容</p>

<h1>2-4. 开发服务器</h1><h1>开发服务器</h1>
<p>在<strong>开发阶段</strong>，目前遇到的问题是打包、运行、调试过程过于繁琐，回顾一下我们的操作流程：</p>
<ol>
<li>编写代码</li>
<li>控制台运行命令完成打包</li>
<li>打开页面查看效果</li>
<li>继续编写代码，回到步骤2</li>
</ol>
<p>并且，我们往往希望把最终生成的代码和页面部署到服务器上，来模拟真实环境</p>
<p>为了解决这些问题，webpack官方制作了一个单独的库：<strong>webpack-dev-server</strong></p>
<p>它<strong>既不是plugin也不是loader</strong></p>
<p>先来看看它怎么用</p>
<ol>
<li>安装</li>
<li>执行<code>webpack-dev-server</code>命令</li>
</ol>
<p><code>webpack-dev-server</code>命令几乎支持所有的webpack命令参数，如<code>--config</code>、<code>-env</code>等等，你可以把它当作webpack命令使用</p>
<p>这个命令是专门为开发阶段服务的，真正部署的时候还是得使用webpack命令</p>
<p>当我们执行<code>webpack-dev-server</code>命令后，它做了以下操作：</p>
<ol>
<li>内部执行webpack命令，传递命令参数</li>
<li>开启watch</li>
<li>注册hooks：类似于plugin，webpack-dev-server会向webpack中注册一些钩子函数，主要功能如下：
<ol>
<li>将资源列表（aseets）保存起来</li>
<li>禁止webpack输出文件</li>
</ol>
</li>
<li>用express开启一个服务器，监听某个端口，当请求到达后，根据请求的路径，给予相应的资源内容</li>
</ol>
<p><strong>配置</strong></p>
<p>针对webpack-dev-server的配置，参考：https://www.webpackjs.com/configuration/dev-server/</p>
<p>他也在 webpack.config.js中配置</p>
<p>具体在 devserver 项里配置</p>
<p>常见配置有：</p>
<pre><code class="language-json">{
  devserver:{
    port：配置监听端口
		proxy：配置代理，常用于跨域访问
 	 	stats：配置控制台输出内容Ï}
}
</code></pre>
<p>使用proxy的原因</p>
<pre><code class="language-json">  proxy: {
    &quot;/api&quot;:&quot;xxxUrl&quot;,
    &quot;/api&quot;: {
      &quot;Target&quot;: &quot;&quot;
    }
  }
</code></pre>
<p>}</p>
<ul>
<li>前后端在生产环境下往往在同一个域，可以避免url 频繁改动</li>
<li>避免跨域问题</li>
<li>她只是讲请求 url 改变了，但是请求头没变
<ul>
<li>比如请求头中 host 仍然是localhost:8000</li>
<li>有时候服务器端会对 host 进行验证</li>
</ul>
</li>
</ul>

<h1>2-5. 普通文件处理</h1><p>clean-webpack-plugin</p>
<ul>
<li>当 emit 的时候自动删除 dist 目录</li>
</ul>
<p>html-webpack-plugin</p>
<ul>
<li>自动生成 html</li>
<li>可以指定生产的 html 引用的 chunk</li>
</ul>
<p>plugin 为什么用 class 而不是对象：</p>
<ul>
<li>方便多次使用，构造对象</li>
</ul>
<p>copy-webpack-plugin</p>
<ul>
<li>复制静态资源到指定文件夹</li>
</ul>
<p>file-loader: 生成依赖的文件到输出目录，然后返回输出文件的路径</p>
<p>可以用来在 js中导入图片得到对应的路径</p>
<p>但是他用的是 es6 的导出，所以要使用 default 来获取</p>
<p>Png = require(&quot;path&quot;).default</p>
<pre><code class="language-js">test:/\.(png)|(jpg)/
use:[{
  loader:&quot;file-loader&quot;,
  option:{
    
  }
}]
</code></pre>
<pre><code class="language-js">//file-loader
function loader(source){
	// source：文件内容（图片内容 buffer）
	// 1. 生成一个具有相同文件内容的文件到输出目录
	// 2. 返回一段代码   export default &quot;文件名&quot;
}
</code></pre>
<p>url-loader：将依赖的文件转换为：导出一个base64格式的字符串</p>
<pre><code class="language-js">//url-loader
function loader(source){
	// source：文件内容（图片内容 buffer）
	// 1. 根据buffer生成一个base64编码
	// 2. 返回一段代码   export default &quot;base64编码&quot;
}
</code></pre>

<h1>2-6. 解决路径问题</h1><h1>解决路径问题</h1>
<p>在使用file-loader或url-loader时，可能会遇到一个非常有趣的问题</p>
<p>比如，通过webpack打包的目录结构如下：</p>
<pre><code class="language-yaml">dist
    |—— img
        |—— a.png  #file-loader生成的文件
    |—— scripts
        |—— main.js  #export default &quot;img/a.png&quot;
    |—— html
        |—— index.html #&lt;script src=&quot;../scripts/main.js&quot; &gt;&lt;/script&gt;
</code></pre>
<p>此时 index.html导入的 main.js中的图片路径也是 img/a.png 但是，实际的图片应该是 ../img/a.png</p>
<p>这种问题发生的根本原因：模块中的路径来自于某个loader或plugin，当产生路径时，loader或plugin只有相对于dist目录的路径，并不知道该路径将在哪个资源中使用，从而无法确定最终正确的路径</p>
<p>面对这种情况，需要依靠webpack的配置output.publicPath解决,</p>
<p>publicPath 通常</p>
<ul>
<li>publicPath本质是一个字符串</li>
<li>我们可以在 js 中使用 __webpack__public__path 来引用这个变量</li>
<li>一些 loader 或者 plugin 可能会使用这个变脸
<ul>
<li>为了防止冲突，这些 plugin或者 loader 会提供传入的参数pubilcPath来选择</li>
</ul>
</li>
</ul>

<h1>2-7. webpack内置插件</h1><h1>webpack内置插件 {ignore}</h1>
<p>所有的webpack内置插件都作为webpack的静态属性存在的，使用下面的方式即可创建一个插件对象</p>
<pre><code class="language-js">const webpack = require(&quot;webpack&quot;)

new webpack.插件名(options)
</code></pre>
<h2>DefinePlugin</h2>
<p>全局常量定义插件，使用该插件通常定义一些常量值，例如：</p>
<p>注意他是``之间的值</p>
<pre><code class="language-js">new webpack.DefinePlugin({
    PI: `Math.PI`, // PI = Math.PI
    VERSION: `&quot;1.0.0&quot;`, // VERSION = &quot;1.0.0&quot;
    DOMAIN: JSON.stringify(&quot;duyi.com&quot;)
})
</code></pre>
<p>这样一来，在源码中，我们可以直接使用插件中提供的常量，当webpack编译完成后，会自动替换为常量的值</p>
<h2>BannerPlugin</h2>
<p>它可以为每个chunk生成的文件头部添加一行注释，一般用于添加作者、公司、版权等信息</p>
<pre><code class="language-js">new webpack.BannerPlugin({
  banner: `
  hash:[hash]
  chunkhash:[chunkhash]
  name:[name]
  author:yuanjin
  corporation:duyi
  `
})
</code></pre>
<h2>ProvidePlugin</h2>
<p>自动加载模块，而不必到处 import 或 require</p>
<pre><code class="language-js">new webpack.ProvidePlugin({
  $: 'jquery',
  _: 'lodash'
})
</code></pre>
<p>然后在我们任意源码中：</p>
<pre><code class="language-js">$('#item'); // &lt;= 起作用
_.drop([1, 2, 3], 2); // &lt;= 起作用
</code></pre>
