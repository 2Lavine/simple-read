<h1>HTTP 灵魂之问，巩固你的 HTTP 知识体系</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844904100035821575?searchId=2024013011484251B2AA61C86D10717F50">juejin.cn</a></p>
</blockquote>
<h2>012: 如何理解 HTTP 代理？</h2>
<p>我们知道在 HTTP 是基于<code>请求-响应</code>模型的协议，一般由客户端发请求，服务器来进行响应。
代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有<strong>双重身份</strong>。</p>
<h3>代理服务器功能</h3>
<ol>
<li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。
<ul>
<li>这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性 hash</strong>、<strong>LRU</strong><code>(最近最少使用)</code>等等</li>
</ul>
</li>
<li><strong>保障安全</strong>。利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li>
<li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</li>
</ol>
<h4>代理服务器 Via</h4>
<p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？</p>
<p>通过<code>Via</code>字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p>
<pre><code>客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器
</code></pre>
<p>在源服务器收到请求后，会在<code>请求头</code>拿到这个字段:</p>
<pre><code>Via: proxy_server1, proxy_server2
</code></pre>
<p>而源服务器响应时，最终在客户端会拿到这样的<code>响应头</code>:</p>
<pre><code>Via: proxy_server2, proxy_server1
</code></pre>
<p>可以看到，<code>Via</code>中代理的顺序即为在 HTTP 传输中报文传达的顺序。</p>
<ul>
<li>X-Forwarded-For
字面意思就是<code>为谁转发</code>, 它记录的是<strong>请求方</strong>的<code>IP</code>地址 (注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个 IP)。</li>
<li>X-Real-IP
是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP。
相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录<strong>客户端</strong> (注意哦，不包括代理) 的<code>域名</code>和<code>协议名</code>。</li>
</ul>
<h3>X-Forwarded-For 产生的问题</h3>
<p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的 IP，从<code>代理1</code>到<code>代理2</code>，这个字段就变为了代理 1 的 IP。</p>
<p>但是这会产生两个问题:</p>
<ol>
<li>意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</li>
<li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的。</li>
</ol>
<p>由此产生了<code>代理协议</code>，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:</p>
<pre><code>// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
</code></pre>
<p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了。</p>
<h2>013: 如何理解 HTTP 缓存及缓存代理？</h2>
<p>关于<code>强缓存</code>和<code>协商缓存</code>的内容，我已经在<a href="https://link.juejin.cn?target=http%3A%2F%2F47.98.159.95%2Fmy_blog%2Fperform%2F001.html" title="http://47.98.159.95/my_blog/perform/001.html">能不能说一说浏览器缓存</a>做了详细分析，小结如下:
首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p>
<ul>
<li>如果强缓存可用，直接使用</li>
<li>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>这些<strong>条件请求</strong>字段检查资源是否更新
<ul>
<li>若资源更新，返回资源和 200 状态码</li>
<li>否则，返回 304，告诉浏览器直接从缓存获取资源
这一节我们主要来说说另外一种缓存方式: <strong>代理缓存</strong>。</li>
</ul>
</li>
</ul>
<h3>为什么产生代理缓存？</h3>
<p>对于源服务器来说，它也是有缓存的，比如 <strong>Redis, Memcache</strong>，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p>
<p>由此引入了<strong>缓存代理</strong>的机制。让<code>代理服务器</code>接管一部分的服务端 HTTP 缓存，客户端缓存过期后<strong>就近</strong>到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p>
<p>那缓存代理究竟是如何做到的呢？总的来说，缓存代理的控制分为两部分，一部分是<strong>源服务器</strong>端的控制，一部分是<strong>客户端</strong>的控制。</p>
<h3>源服务器的缓存控制</h3>
<ul>
<li>private 和 public
在源服务器的响应头中，会加上<code>Cache-Control</code>这个字段进行缓存控制字段，那么它的值当中可以加入<code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者禁止，后者为允许。</li>
</ul>
<p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的<code>Cache-Control</code>设为<code>private</code>，而不是<code>public</code>。</p>
<ul>
<li>proxy-revalidate</li>
</ul>
<p><code>must-revalidate</code>的意思是<strong>客户端</strong>缓存过期就去源服务器获取，而<code>proxy-revalidate</code>则表示<strong>代理服务器</strong>的缓存过期后到源服务器获取。</p>
<ul>
<li>s-maxage</li>
</ul>
<p><code>s</code>是<code>share</code>的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的<code>max-age</code>并不冲突。</p>
<p>讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p>
<pre><code>Cache-Control: public, max-age=1000, s-maxage=2000
</code></pre>
<p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p>
<h3>客户端的缓存控制</h3>
<ul>
<li>max-stale 和 min-fresh</li>
</ul>
<p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行<strong>宽容</strong>和<strong>限制</strong>操作。比如：</p>
<pre><code>max-stale: 5
</code></pre>
<p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在 <strong>5 秒之内</strong>，还是可以从代理中获取的。</p>
<p>又比如:</p>
<pre><code>min-fresh: 5
</code></pre>
<p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在<strong>到期前 5 秒</strong>之前的时间拿，否则拿不到。</p>
<ul>
<li>only-if-cached</li>
</ul>
<h2>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回<code>504（Gateway Timeout）</code>。
014: 什么是跨域？浏览器如何拦截响应？如何解决？</h2>
<p>浏览器遵循<strong>同源政策</strong> (<code>scheme(协议)</code>、<code>host(主机)</code>和<code>port(端口)</code>都相同则为<code>同源</code>)。非同源站点有这样一些限制:</p>
<ul>
<li>不能读取和修改对方的 DOM</li>
<li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li>
<li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li>
</ul>
<p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为<code>跨域请求</code>。</p>
<p>跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？
首先要知道的是，浏览器是多进程的
<strong>WebKit 渲染引擎</strong>和 <strong>V8 引擎</strong>都在渲染进程当中。</p>
<p>当<code>xhr.send</code>被调用，即 Ajax 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的 <strong>Spectre</strong> 和 <strong>Meltdown</strong> 漏洞，采取了<code>站点隔离</code>的手段，给每一个不同的站点 (一级域名不同) 分配了沙箱，互不干扰。
在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信 (IPC，Inter Process Communication) 了。接下来我们看看 chromium 当中进程间通信是如何完成的，
总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。
好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。</p>
<p>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说) 响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。</p>
<p>接下来我们来说一说解决跨域问题的几种方案。</p>
<h3>CORS</h3>
<p>CORS 其实是 W3C 的一个标准，全称是<code>跨域资源共享</code>。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持 CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: <strong>简单请求</strong>和<strong>非简单请求</strong>。</p>
<p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于<strong>简单请求</strong>:</p>
<ul>
<li>请求方法为 GET、POST 或者 HEAD</li>
<li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li>
</ul>
<p>浏览器画了这样一个圈，在这个圈里面的就是<strong>简单请求</strong>, 圈外面的就是<strong>非简单请求</strong>，然后针对这两种不同的请求进行不同的处理。</p>
<h4>简单请求</h4>
<p>请求发出去之前，浏览器做了什么？
它会自动在请求头当中，添加一个<code>Origin</code>字段，用来说明请求来自哪个<code>源</code>。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果<code>Origin</code>不在这个字段的范围中，那么浏览器就会将响应拦截。</p>
<p>因此，<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p>
<p><strong>Access-Control-Allow-Credentials</strong>。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为<code>true</code>, 并且在前端也需要设置<code>withCredentials</code>属性:</p>
<pre><code>let xhr = new XMLHttpRequest();
xhr.withCredentials = true;
</code></pre>
<p><strong>Access-Control-Expose-Headers</strong>。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>和<code>Pragma</code>）, 还能拿到这个字段声明的<strong>响应头字段</strong>。比如这样设置:</p>
<pre><code>Access-Control-Expose-Headers: aaa
</code></pre>
<p>那么在前端可以通过 <code>XMLHttpRequest.getResponseHeader('aaa')</code> 拿到 <code>aaa</code> 这个字段的值。</p>
<h4>非简单请求</h4>
<p>非简单请求相对而言会有些不同，体现在两个方面: <strong>预检请求</strong>和<strong>响应字段</strong>。</p>
<p>我们以 PUT 方法为例。</p>
<pre><code>var url = 'http://xxx.com';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'xxx');
xhr.send();
</code></pre>
<p>当这段代码执行后，首先会发送<strong>预检请求</strong>。这个预检请求的请求行和请求体是下面这个格式:</p>
<pre><code>OPTIONS / HTTP/1.1
Origin: 当前地址
Host: xxx.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
</code></pre>
<p>预检请求的方法是<code>OPTIONS</code>，同时会加上<code>Origin</code>源地址和<code>Host</code>目标地址，这很简单。同时也会加上两个关键的字段:</p>
<ul>
<li>Access-Control-Request-Method, 列出 CORS 请求用到哪个 HTTP 方法</li>
<li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li>
</ul>
<p>这是<code>预检请求</code>。接下来是<strong>响应字段</strong>，响应字段也分为两部分，一部分是对于<strong>预检请求</strong>的响应，一部分是对于 <strong>CORS 请求</strong>的响应。</p>
<p><strong>预检请求的响应</strong>。如下面的格式:</p>
<pre><code>HTTP/1.1 200 OK
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
</code></pre>
<p>其中有这样几个关键的<strong>响应头字段</strong>:</p>
<ul>
<li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。</li>
<li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li>
<li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li>
<li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li>
<li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li>
</ul>
<p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的 <strong>CORS 请求</strong>也不会发出去了。</p>
<p><strong>CORS 请求的响应</strong>。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和<strong>简单请求</strong>的情况是一样的。浏览器自动加上<code>Origin</code>字段，服务端响应头返回 <strong>Access-Control-Allow-Origin</strong>。可以参考以上简单请求部分的内容。</p>
<h3>JSONP</h3>
<p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p>
<pre><code>const jsonp = ({ url, params, callbackName }) =&gt; {
  const generateURL = () =&gt; {
    let dataStr = '';
    for(let key in params) {
      dataStr += `${key}=${params[key]}&amp;`;
    }
    dataStr += `callback=${callbackName}`;
    return `${url}?${dataStr}`;
  };
  return new Promise((resolve, reject) =&gt; {
    // 初始化回调函数名称
    callbackName = callbackName || Math.random().toString.replace(',', ''); 
    // 创建 script 元素并加入到当前文档中
    let scriptEle = document.createElement('script');
    scriptEle.src = generateURL();
    document.body.appendChild(scriptEle);
    // 绑定到 window 上，为了后面调用
    window[callbackName] = (data) =&gt; {
      resolve(data);
      // script 执行完了，成为无用元素，需要清除
      document.body.removeChild(scriptEle);
    }
  });
}
</code></pre>
<p>当然在服务端也会有响应的操作, 以 express 为例:</p>
<pre><code>let express = require('express')
let app = express()
app.get('/', function(req, res) {
  let { a, b, callback } = req.query
  console.log(a); // 1
  console.log(b); // 2
  // 注意哦，返回给script标签，浏览器直接把这部分字符串执行
  res.end(`${callback}('数据包')`);
})
app.listen(3000)
</code></pre>
<p>前端这样简单地调用一下就好了:</p>
<pre><code>jsonp({
  url: 'http://localhost:3000',
  params: { 
    a: 1,
    b: 2
  }
}).then(data =&gt; {
  // 拿到数据进行处理
  console.log(data); // 数据包
})
</code></pre>
<p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p>
<h3>Nginx</h3>
<p>Nginx 是一种高性能的<code>反向代理</code>服务器，可以用来轻松解决跨域问题。
what？反向代理？我给你看一张图你就懂了。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd97d0b1cf15~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p>
<p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p>
<p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p>
<p>好了，那 Nginx 是如何来解决跨域的呢？</p>
<p>比如说现在客户端的域名为 <strong>client.com</strong>，服务器的域名为 <strong>server.com</strong>，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p>
<pre><code>server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
</code></pre>
<p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p>
<p>其实还有一些不太常用的方式，大家了解即可，比如<code>postMessage</code>，当然<code>WebSocket</code>也是一种方式，但是已经不属于 HTTP</p>
<h2>015: TLS1.2 握手的过程是怎样的？</h2>
<p>之前谈到了 HTTP 是明文传输的协议，传输保文对外完全透明，非常不安全，那如何进一步保证安全性呢？</p>
<p>由此产生了 <code>HTTPS</code>，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 SSL/TLS 协议，简单的讲，<strong>HTTPS = HTTP + SSL/TLS</strong>。</p>
<p>那什么是 SSL/TLS 呢？</p>
<p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层 (第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，<strong>TLS1.0 = SSL3.1</strong>。</p>
<p>现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程，这个我们放在下一节再去说。</p>
<p>TLS 握手的过程比较复杂，写文章之前我查阅了大量的资料，发现对 TLS 初学者非常不友好，也有很多知识点说的含糊不清，可以说这个整理的过程是相当痛苦了。希望我下面的拆解能够帮你理解得更顺畅些吧 : ）</p>
<h3>传统 RSA 握手</h3>
<p>先来说说传统的 TLS 握手，也是大家在网上经常看到的。我之前也写过这样的文章，<a href="https://link.juejin.cn?target=http%3A%2F%2F47.98.159.95%2Fmy_blog%2Fbrowser-security%2F003.html" title="http://47.98.159.95/my_blog/browser-security/003.html">(传统 RSA 版本)HTTPS 为什么让数据传输更安全</a>，其中也介绍到了<code>对称加密</code>和<code>非对称加密</code>的概念，建议大家去读一读，不再赘述。之所以称它为 RSA 版本，是因为它在加解密<code>pre_random</code>的时候采用的是 RSA 算法。</p>
<h3>TLS 1.2 握手过程</h3>
<p>现在我们来讲讲主流的 TLS 1.2 版本所采用的方式。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd9b35c7a81b~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<p>刚开始你可能会比较懵，先别着急，过一遍下面的流程再来看会豁然开朗。</p>
<ul>
<li>step 1: Client Hello</li>
</ul>
<p>首先，浏览器发送 client_random、TLS 版本、加密套件列表。</p>
<p>client_random 是什么？用来最终 secret 的一个参数。</p>
<p>加密套件列表是什么？我举个例子，加密套件列表一般张这样:</p>
<pre><code>TLS_ECDHE_WITH_AES_128_GCM_SHA256
</code></pre>
<p>意思是<code>TLS</code>握手过程中，使用<code>ECDHE</code>算法生成<code>pre_random</code>(这个数后面会介绍)，128 位的<code>AES</code>算法进行对称加密，在对称加密的过程中使用主流的<code>GCM</code>分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用<code>SHA256</code>算法。</p>
<p>其中值得解释一下的是这个哈希摘要算法，试想一个这样的场景，服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息呢？现在引入这个哈希摘要算法，将服务端的证书信息通过<strong>这个算法</strong>生成一个摘要 (可以理解为<code>比较短的字符串</code>)，用来<strong>标识</strong>这个服务端的身份，用私钥加密后把<strong>加密后的标识</strong>和<strong>自己的公钥</strong>传给客户端。客户端拿到<strong>这个公钥</strong>来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓<strong>数字签名</strong>的原理。其中除了哈希算法，最重要的过程是<strong>私钥加密，公钥解密</strong>。</p>
<ul>
<li>step 2: Server Hello</li>
</ul>
<p>可以看到服务器一口气给客户端回复了非常多的内容。</p>
<p><code>server_random</code>也是最后生成<code>secret</code>的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书，这都不难理解。那剩下的<code>server_params</code>是干嘛的呢？</p>
<p>我们先埋个伏笔，现在你只需要知道，<code>server_random</code>到达了客户端。</p>
<ul>
<li>step 3: Client 验证证书，生成 secret</li>
</ul>
<p>客户端验证服务端传来的<code>证书</code>和<code>签名</code>是否通过，如果验证通过，则传递<code>client_params</code>这个参数给服务器。</p>
<p>接着客户端通过<code>ECDHE</code>算法计算出<code>pre_random</code>，其中传入两个参数:<strong>server_params</strong> 和 <strong>client_params</strong>。现在你应该清楚这个两个参数的作用了吧，由于<code>ECDHE</code>基于<code>椭圆曲线离散对数</code>，这两个参数也称作<code>椭圆曲线的公钥</code>。</p>
<p>客户端现在拥有了<code>client_random</code>、<code>server_random</code>和<code>pre_random</code>，接下来将这三个数通过一个伪随机数函数来计算出最终的<code>secret</code>。</p>
<ul>
<li>step4: Server 生成 secret</li>
</ul>
<p>刚刚客户端不是传了<code>client_params</code>过来了吗？
现在服务端开始用<code>ECDHE</code>算法生成<code>pre_random</code>，接着用和客户端同样的伪随机数函数生成最后的<code>secret</code>。</p>
<h4>注意事项</h4>
<p>TLS 的过程基本上讲完了，但还有两点需要注意。</p>
<p><strong>第一</strong>、实际上 TLS 握手是一个<strong>双向认证</strong>的过程，从 step1 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？
当然是可以的。具体来说，在 <code>step3</code>中，客户端传送<code>client_params</code>，实际上给服务器传一个验证消息，让服务器将相同的验证流程 (哈希摘要 + 私钥加密 + 公钥解密) 走一遍，确认客户端的身份。</p>
<p><strong>第二</strong>、当客户端生成<code>secret</code>后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完<code>secret</code>也会向客户端发送一个收尾的消息，告诉客户端以后就直接用对称加密来通信。</p>
<p>这个收尾的消息包括两部分，一部分是<code>Change Cipher Spec</code>，意味着后面加密传输了，另一个是<code>Finished</code>消息，这个消息是对之前所有发送的数据做的<strong>摘要</strong>，对摘要进行加密，让对方验证一下。</p>
<p>当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。</p>
<h4>RSA 和 ECDHE 握手过程的区别</h4>
<ol>
<li>ECDHE 握手，也就是主流的 TLS1.2 握手中，使用<code>ECDHE</code>实现<code>pre_random</code>的加密解密，没有用到 RSA。</li>
<li>使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前<code>抢跑</code>，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫<code>TLS False Start</code>。</li>
</ol>
<h2>016: TLS 1.3 做了哪些改进？</h2>
<p>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在<code>2018年</code>就推出了 TLS1.3，对于<code>TLS1.2</code>做了一系列的改进，主要分为这几个部分: <strong>强化安全</strong>、<strong>提高性能</strong>。</p>
<h3>强化安全</h3>
<p>在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:</p>
<ul>
<li>TLS_AES_128_GCM_SHA256</li>
<li>TLS_AES_256_GCM_SHA384</li>
<li>TLS_CHACHA20_POLY1305_SHA256</li>
<li>TLS_AES_128_GCM_SHA256</li>
<li>TLS_AES_128_GCM_8_SHA256</li>
</ul>
<p>可以看到，最后剩下的对称加密算法只有 <strong>AES</strong> 和 <strong>CHACHA20</strong>，之前主流的也会这两种。分组模式也只剩下 <strong>GCM</strong> 和 <strong>POLY1305</strong>, 哈希摘要算法只剩下了 <strong>SHA256</strong> 和 <strong>SHA384</strong> 了。</p>
<p>那你可能会问了, 之前<code>RSA</code>这么重要的非对称加密算法怎么不在了？</p>
<p>我觉得有两方面的原因:</p>
<p><strong>第一</strong>、2015 年发现了<code>FREAK</code>攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。</p>
<p><strong>第二</strong>、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的<code>secret</code>，破解之前所有的密文。</p>
<p>为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成<code>pre_random</code>并用<strong>公钥</strong>加密传给服务器，服务器通过<strong>私钥</strong>解密，从而拿到真实的<code>pre_random</code>。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到<code>pre_random</code>、<code>server_random</code>和<code>client_random</code>并根据对应的随机数函数生成<code>secret</code>，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。</p>
<p>但<code>ECDHE</code>在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫<strong>前向安全性</strong>。</p>
<p><code>RSA</code> 算法不具备前向安全性，而 <code>ECDHE</code> 具备，因此在 TLS1.3 中彻底取代了<code>RSA</code>。</p>
<h2>017: HTTP/2 有哪些改进？</h2>
<p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p>
<ul>
<li>头部压缩</li>
<li>多路复用</li>
</ul>
<p>当然还有一些颠覆性的功能实现:</p>
<ul>
<li>设置请求优先级</li>
<li>服务器推送</li>
</ul>
<p>这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。</p>
<h3>头部压缩</h3>
<p>在 HTTP/1.1 及之前的时代，<strong>请求体</strong>一般会有响应的压缩编码过程，通过<code>Content-Encoding</code>头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。</p>
<p>HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：</p>
<ul>
<li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把<strong>索引</strong> (比如 0，1，2，...) 传给对方即可，对方拿到索引查表就行了。这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdaa6f41c004~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<blockquote>
<p>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个 &quot;:&quot; 前缀，用来和其它请求头区分开。</p>
</blockquote>
<ul>
<li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li>
</ul>
<h3>多路复用</h3>
<h4>HTTP 队头阻塞</h4>
<p>我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于 HTTP 基于<code>请求-响应</code>的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p>
<p>后面我们又讨论到用<strong>并发连接</strong>和<strong>域名分片</strong>的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p>
<p>而 HTTP/2 便从 HTTP 协议本身解决了<code>队头阻塞</code>问题。注意，这里并不是指的<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code>，两者并不是一回事。TCP 的队头阻塞是在<code>数据包</code>层面，单位是<code>数据包</code>，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而 HTTP 的队头阻塞是在 <code>HTTP 请求-响应</code>层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p>
<p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p>
<h4>二进制分帧</h4>
<p>首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输<code>01</code>串，方便了机器的解析。</p>
<p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用 <strong>Headers 帧</strong>存放头部字段，<strong>Data 帧</strong>存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。</p>
<p>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫做<code>流</code>(Stream)。HTTP/2 用<code>流</code>来在一个 TCP 连接上来进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念。</p>
<p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p>
<p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<strong>请求报文</strong>和<strong>响应报文</strong>。当然，在二进制帧当中还有其他的一些字段，实现了<strong>优先级</strong>和<strong>流量控制</strong>等功能，我们放到下一节再来介绍。</p>
<h3>服务器推送</h3>
<h2>另外值得一说的是 HTTP/2 的服务器推送 (Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。
018: HTTP/2 中的二进制帧是如何设计的？</h2>
<h3>帧结构</h3>
<p>HTTP/2 中传输的帧结构如下图所示:</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdc9e9c25e93~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<p>每个帧分为<code>帧头</code>和<code>帧体</code>。先是三个字节的帧长度，这个长度表示的是<code>帧体</code>的长度。</p>
<p>然后是帧类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧用来存放 HTTP 报文，控制帧用来管理<code>流</code>的传输。</p>
<p>接下来的一个字节是<strong>帧标志</strong>，里面一共有 8 个标志位，常用的有 <strong>END_HEADERS</strong> 表示头数据结束，<strong>END_STREAM</strong> 表示单方向数据发送结束。</p>
<p>后 4 个字节是<code>Stream ID</code>, 也就是<code>流标识符</code>，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求 / 响应报文。</p>
<h3>流的状态变化</h3>
<p>从前面可以知道，在 HTTP/2 中，所谓的<code>流</code>，其实就是二进制帧的<strong>双向传输的序列</strong>。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？</p>
<p>HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的<code>请求-响应</code>过程为例来说明：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdcd0abdd1ba~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<p>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</p>
<p>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</p>
<p>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</p>
<p>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2 的 31 次方，大约 21 亿个。</p>
<h3>流的特性</h3>
<p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下<code>流</code>传输的特性:</p>
<ul>
<li>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现<strong>多路</strong>复用的基础。</li>
<li>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li>
<li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为<code>发送方</code>或者<code>接收方</code>。</li>
<li>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li>
</ul>
<p>以上就是对 HTTP/2 中二进制帧的介绍，希望对你有所启发。</p>

<h1>React 期许的未来（RSC）可不能并不是国内前端想要的未来</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7291936473079480355?searchId=20240130221020658A065315F1CE364277">juejin.cn</a></p>
</blockquote>
<h2>背景</h2>
<ul>
<li><strong>代码质量应该如何保证</strong>，说实话之前工作的公司的同事水平都挺高，可为什么代码总是会变成屎山？是架构做的不好？管理不到位？时间年限太久了？还是什吗原因？</li>
<li><strong>模板化的代码有很多</strong>，这个所谓的模板化充斥在各个地方，为了降本增效公司搞了多种方案的低代码，说实话作为程序员用的真心难受
<ul>
<li>比如后台管理里的 CRUD ，无非都是表单表格弹窗，技术落地不难，恶心人的是业务和来之不尽的需求</li>
<li>比如每次创建项目都得搭一遍基础架子，由于项目和业务灵活，脚手架自动生成有用，但不好用</li>
</ul>
</li>
<li><strong>巨石应用的处理</strong>。公司有维护了超 5 年以上的大项目，当应用大到一定程度，屎到一定程度，怎么砍屎山呢？
<ul>
<li>传统的微前端做法，只能解一定程度，还得考虑线上事故，畏手畏脚</li>
<li>现有的 ssr 方案搞不定这种级别的需求</li>
<li>开发和打包难题</li>
<li>应用治理，团队协作，敏捷开发</li>
<li>项目怎么防腐，延缓屎下去</li>
</ul>
</li>
<li>前后端耦合的畸形，<strong>想要迁移技术栈</strong>，可很难迁不完全导致以畸形方式继续耦合运行</li>
</ul>
<p>这些是所有公司维护到后边最终都会面临的问题，看似我鬼扯了一堆和标题不符的话，其实我是想表达我想到个一个观点</p>
<p><strong>面向用户的前端代码的生命周期是从浏览器加载 js 的那一刻开始的，为了尽可能做到高效的用户体验，我们有太多太多的东西需要挤破头似的，需要在进入页面初期执行，可这是不现实的，都说 js 的效率低，可真的不算慢啊，而用户的耐心还有限，意味着留给首屏的时间有限</strong></p>
<p>或许可以从以下两个点解</p>
<ol>
<li><strong>生命周期前移</strong>
<code>ssr</code> 技术能让前端应用的生命周期从服务器接到请求的那一刻开始，这使得我们能做很多有意义的事情
而 <code>React</code> 团队对 <code>RSC</code> 的推广话语完美了击中了这点，我觉得我需要这项技术</li>
<li><strong>应用拆解</strong>
拆解即字面意思，我们需要做各种程度的拆解
拆应用——微前端
拆需求——别让产品把功能无脑堆首屏，哪怕首页分个屏内屏外都行
拆依赖</li>
</ol>
<p>它类似于 <code>umijs</code>，但我不在阿里，说实话 <code>umijs</code> 我用了后发现不是我想要的</p>
<ul>
<li>它只是个为了内部服务，顺便开源的产物，我需要一个自己的框架，因为总得有个东西得干那些开发者不想干的脏活累活吧</li>
</ul>
<p>挖坑到此为止，我们来围绕 <code>RSC</code> 聊聊服务端的事情</p>
<h2>官方推荐版 RSC</h2>
<p>简单来说，它就是让我们的组件内部能写服务器的代码了，我们可以很轻松做到如下事情</p>
<ol>
<li>显著减少依赖，减少产物体积 —— 有些代码如果只在首屏用到只跑一次，那么在服务端执行后，浏览器内就直接拿结果而不用加载相关依赖了</li>
<li>减少数据交流的开销 —— 前端是不存数据的，所有的都在后端，可 http 传输的开销是不可忽视的。此时就可以和后端交流，把允许的数据放 redis ，从服务端取，再把结果带到客户端然后水合，性能会大大的提高</li>
<li>极致的数据加载，流式渲染 &amp; 服务端并发 —— 流式渲染能够在组件没有全部渲染完的前提下就送给前端展示，大大提高了用户体验；nodejs 只是跑 <code>js</code> 的主线程是单线的，其他可是多线程的，怎么用取决实际情况了</li>
<li>技术栈的无缝衔接 —— 前后都是前端技术栈，我们只是在像往常一样写组件代码</li>
</ol>
<p>而能够让这些种种技术衔接起来的就是框架，我们只是在像往常一样写组件代码，就能享受到全部
你能想象一个只能看不能用的那种牙痒痒的感觉吗</p>
<p><code>RSC</code> 把组件分成了 <strong>客户端和服务端</strong> 两个概念，顾名思义，客户端就是平常用的，服务端组件是只能跑在服务端，不能带到客户端的部分</p>
<p>粗看感觉还好，挺合理，但一用就发现有蹊跷</p>
<pre><code>&quot;use server&quot;

export default function ServerComponent() {
  const configs = readFileSync(&quot;./project-configs&quot;, &quot;utf-8&quot;)//用浏览器没有的 API 读取项目配置
  const cacheData = useRedis(&quot;web-home-slids&quot;) //轮播图
  const dbData = useMysql() //除了缓存，还能查库

  return &lt;main&gt;
  	&lt;Slids images={cacheData}&gt;&lt;/Slids&gt;
    &lt;Article data={dbData}&gt;&lt;/Article&gt;
  &lt;/main&gt;
}
</code></pre>
<pre><code>&quot;use client&quot;

export default function Slids({images}) {
  const [index, setIndex] = useState(0)
  const toggleIndex = () =&gt; {}
  useEffect(() =&gt; {
    setTimeout
    
    return () =&gt; {
      clearTimeout
    }
  }, [])
  return &lt;div&gt;{images.map(...)}&lt;/div&gt;
}
</code></pre>
<p>这是一个非常简单的 demo，这是渲染新闻页的例子，有轮播图，有新闻文章，有了 RSC 在服务端就能把用到的数据全部读出来</p>
<p><code>&quot;use server&quot;</code> 开头的是只能运行在服务端的组件，它可以做各种浏览器做不到的事，并且相关的依赖都不会带到浏览器，也不会被打包到客户端的产物中；相对的关于数据的响应式变更，副作用 <code>useEffect</code> 之类的会全部失效</p>
<p><code>&quot;use client&quot;</code> 开头的是客户端组件，轮播图如果用插件的话，大多还是基于 js 的，所以纳入到客户端</p>
<p>看似一切顺利的背景下，再来想想我们经常面对的是什吗？</p>
<p>是后台管理系统，是一个<strong>重客户端，轻服务端</strong>的东西，而 <code>RSC</code> 的特点是 <strong>重服务端，轻客户端</strong> 国内外的需求和市场有有区别的</p>
<p>按照 <code>React</code> 的约定，所有组件默认是服务端，只有自己手动写上 <code>&quot;use client&quot;</code> 才是客户端组件，只要忘写就是一片红（React 的报错老长了，加上框架的更长）</p>
<p>服务端和客户端的组件数据交互需要以嵌套的形式写</p>
<pre><code>&quot;use server&quot;
function ServerComp() {
  return &lt;&gt; &lt;ClientComp&gt;{server data}&lt;/ClientComp&gt; &lt;/&gt;
}
</code></pre>
<p>框架会把编译后的服务端组件的数据字符串化注入给客户端组件，这意味着子组件无法直接引入客户端，特殊方式无法大面积铺开用</p>
<p>可以简单的认为，必须要在浏览器靠 js 运行维持功能的只能是客户端组件，而后台管理几乎全是</p>
<h2>action 技术</h2>
<p>请求方面，按照官网的推荐，我们还可以用种叫 <code>action</code> 的技术来应对请求，它可以和 <code>RSC</code> 结合到一起做请求，demo 粘贴 <a href="https://link.juejin.cn?target=https%3A%2F%2Fnextjs.org%2Fdocs%2Fapp%2Fapi-reference%2Ffunctions%2Fserver-actions" title="https://nextjs.org/docs/app/api-reference/functions/server-actions"><code>nextjs</code></a></p>
<pre><code>'use server'
export async function myAction() {
  // ...
}


'use client'
import { myAction } from './actions'
export default function ClientComponent() {
  return (
    &lt;form action={myAction}&gt;
      &lt;button type=&quot;submit&quot;&gt;Add to Cart&lt;/button&gt;
    &lt;/form&gt;
  )
}
</code></pre>
<p>简单来说就是所有关于接口出发请求，请全部放到 <code>&lt;form&gt;</code> 标签里，处理请求的是个函数，根据框架不同实现也不同</p>
<p>用 <code>remixjs</code> 框架你需要用到 <code>react-router</code> 的数据路由，并且喜提翻倍的路由打包体积</p>
<p>用 <code>nextjs</code> 你需要在服务端做校验</p>
<p>其实都相当于我们得把所有接口逻辑写到 <code>action function</code> 中，其他不变，工序喜 + n</p>
<h2>以客户端为主的 <code>RSC</code></h2>
<p>当我意识到事情开始不对劲时，第一想法是能不能转变思路，把它给强行改成客户端为主的方式
让我有这么干的勇气是因为我搞定了核心卡点</p>
<ol>
<li>流式渲染怎么做</li>
<li>流式渲染过程中产生的数据怎么带到客户端 —— 流式下和以前那种靠服务器路由钩子的做法不适用</li>
<li>怎么做到服务端和客户端的分离</li>
<li>怎么把服务端编译成数据喂给客户端组件内</li>
</ol>
<p>按照 <code>React</code> 官方规范，组件是不是服务端是以 <code>use xxx</code> 指令的形式区分的，还必须在开头
在 <code>vite</code> 插件的 <code>transform</code> 中能扫出来，区分就做到了
服务端编译成数据喂给客户端组件内可以结合插件，把扫出来的客户端组件，外边套一层自定义组件，它用于接受服务端组件传给子组件的内容</p>
<p>不收集起来就没法提前送到客户端，在客户端水合的时候放进去占位，进而引发报错</p>
<p>动态收集需要依赖上下文，流式渲染，和在什么地方什么时间把收集的送给客户端直接套 API 就行 <a href="https://link.juejin.cn?target=https%3A%2F%2Freact.docschina.org%2Freference%2Freact-dom%2Fserver%2FrenderToPipeableStream" title="https://react.docschina.org/reference/react-dom/server/renderToPipeableStream">renderToPipeableStream</a></p>
<p>解释下为什么服务端给客户端注入数据没事，而客户端里引服务端就需要动态收集的原理</p>
<ul>
<li>最终的目的是，浏览器显示正常，水合不报错，功能正常</li>
<li>客户度给服务端注入其实就不用管，套 API 服务端的就搞定了，麻烦的在客户端上的处理。这个东西文字很难讲，建议是实际体验下 nextjs 的 rsc，它会涉及到客户端多入口的问题，需要通过代码分析给扫出来，再动态编译客户端入口。在水合时，其实是从客户端组件那个点开始水合，而客户端组件没法套服务端组件，所以差异部分直接就不用管了。所以难点在怎么把那么多的服务度组件和客户端组件的临界点给找出来在做针对性的编译</li>
<li>但以客户端为主的不同，客户端组件内套着服务端，打成字符串后，本应该只在服务端处理的内容在浏览器水合阶段就参与进来了，所以必须收集相关数据，在这时进行自动填充</li>
</ul>
<p>经过这么一番折腾，原型是做出来了，也能正常跑，功能一切正常，打包没报错</p>
<p><strong>但缺点有两个，致命缺点有一个</strong></p>
<ol>
<li><code>useId</code> 坏掉了，我想了些方法弥补发现都不行</li>
<li>客户端和服务端组件的临界点，也就是通过 plugin 扫出来的给包了一层的那个，必须要一层 dom 标签</li>
<li>之所以套是因为，服务端组件返回的可以是个 dom 结构，如果直接以属性的方式放进去会变成普通字符串，所以必须操作 dom 进入注入，既然操作 dom 可能就会不安全</li>
</ol>
<pre><code>function Client() {
  return &lt;div id=&quot;root&quot;&gt;
    &lt;ServerComponent /&gt;
  &lt;/div&gt;
}

//这个组件内容是动态编译出来的，__html内才是组件原本的内容
function ServerComponent(props) {
  return  &lt;div dangerouslySetInnerHTML={{__html: &lt;OriginComp {...props} /&gt;}}&gt;&lt;/div&gt;
}

//这是原始内容
function ServerComponent(props) {
  return &lt;&gt;&lt;p&gt;server component&lt;/p&gt;&lt;p&gt;123&lt;/p&gt;&lt;/&gt;
}
</code></pre>
<pre><code>&lt;div id=&quot;root&quot;&gt;
  &lt;div&gt;
    &lt;p&gt;server component&lt;/p&gt;
    &lt;p&gt;123&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<h2>总结</h2>
<p>新的做法是提供 <code>server-hook</code> 来在客户端组件内写服务端代码，然后把数据进行动态注入</p>
<pre><code>function App() {
  const data = useServerData(&quot;id&quot;, async () =&gt; {
    return useMysql()
  })
  return &lt;div&gt;{data}&lt;/div&gt;
}
</code></pre>
<p>这是其中一种，进入是 <code>Promise</code>，返回都不用 <code>Await</code> 看起来还是挺有意思的吧
原理是相通的，所以 <code>React/Vue</code> 都能做到，其中的脏活都放到了框架的逻辑中，以插件的方式做热插拔
不过框架不是重点，重点是 <code>React</code> 团队这种 <code>all in server</code> 的做法很多想法都非常好，要不然我也不会搞这玩意搞得死去活来的，可是技术是拿来用的，它目前的运作方式并不契合国内的前端业务</p>

<h1>Session、Token 和 OAuth</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844903864458543111?searchId=2024020123354387E6C3055FA55B58B0BE">juejin.cn</a></p>
</blockquote>
<p>前端的权限控制主要有三种：</p>
<ul>
<li>路由控制（路由的跳转）</li>
<li>视图控制（按钮级别）</li>
<li>请求控制（请求拦截器）。</li>
</ul>
<p>这几种方式之后再详谈，前端做完权限控制，后台还是需要验证每一个接口，这就是鉴权。现在前后端配合鉴权的方式主要有以下几种：</p>
<ol>
<li>session-cookie</li>
<li>Token 验证 (JWT)</li>
<li>OAuth(开放授权)</li>
</ol>
<h3>session-cookie</h3>
<h4>cookie</h4>
<p>cookie 的原理是，浏览器第一次向服务器发送请求时，服务器在 response 头部设置 Set-Cookie 字段，浏览器收到响应就会设置 cookie 并存储，在下一次该浏览器向服务器发送请求时，就会在 request 头部自动带上 Cookie 字段，服务器端收到该 cookie 用以区分不同的浏览器。当然，这个 cookie 与某个用户的对应关系应该在第一次访问时就存在服务器端，这时就需要 session 了。</p>
<pre><code>const http = require('http')
http.createServer((req, res) =&gt; {
  if (req.url === '/favicon.ico') {
    return
  } else {
    res.setHeader('Set-Cookie', 'name=zhunny')
    res.end('Hello Cookie')
  }
}).listen(3000)
</code></pre>
<h4>session</h4>
<p>session 是会话的意思，浏览器第一次访问服务端，服务端就会创建一次会话，在会话中保存标识该浏览器的信息。它与 cookie 的区别就是 session 是缓存在服务端的，cookie 则是缓存在客户端，他们都由服务端生成，为了弥补 Http 协议无状态的缺陷。</p>
<h4>session-cookie 认证</h4>
<ol>
<li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion(我们可以将 seesion 保存在 内存中，也可以保存在 redis 中，推荐使用后者)，然后给这个 session 生成一个唯一的标识字符串, 然后在 响应头中种下这个唯一标识字符串。</li>
<li>签名。这一步通过秘钥对 sid 进行签名处理，避免客户端修改 sid。(非必需步骤)</li>
<li>浏览器中收到请求响应的时候会解析响应头，然后将 sid 保存在本地 cookie 中，浏览器在下次 http 请求的 请求头中会带上该域名下的 cookie 信息。</li>
<li>服务器在接受客户端请求时会去解析请求头 cookie 中的 sid，然后根据这个 sid 去找服务器端保存的该客 户端的 session，然后判断该请求是否合法。<br>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/12/16b49ecef3e6bfd8~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></li>
</ol>
<pre><code>const http = require('http')
//此时session存在内存中
const session = {}
http.createServer((req, res) =&gt; {
  const sessionKey = 'sid'
  if (req.url === '/favicon.ico') {
    return
  } else {
    const cookie = req.headers.cookie
    //再次访问，对sid请求进行认证
    if (cookie &amp;&amp; cookie.indexOf(sessionKey) &gt; -1) {
      res.end('Come Back')
    }
    //首次访问，生成sid，保存在服务器端
    else {
      const sid = (Math.random() * 9999999).toFixed()
      res.setHeader('Set-Cookie', `${sessionKey}=${sid}`)
      session[sid] = { name: 'zhunny' }
      res.end('Hello Cookie')
    }
  }
}).listen(3000)
</code></pre>
<h4>用户登录认证</h4>
<p>使用 session-cookie 做登录认证时，登录时存储 session，退出登录时删除 session，而其他的需要登录后才能操作的接口需要提前验证是否存在 session，存在才能跳转页面，不存在则回到登录页面。<br>
在 koa 中做一个验证的中间件，在需要验证的接口中使用该中间件。</p>
<pre><code>//前端代码
async login() {
    await axios.post('/login', {
        username: this.username,
        password: this.password
    })
},
async logout() {
    await axios.post('/logout')
},
async getUser() {
    await axios.get('/getUser')
}
</code></pre>
<pre><code>//中间件 auth.js
module.exports = async (ctx, next) =&gt; {
  if (!ctx.session.userinfo) {
    ctx.body = {
      ok: 0,
      message: &quot;用户未登录&quot; };
  } else {
    await next();
} };
//需要验证的接口
router.get('/getUser', require('auth'), async (ctx) =&gt; {
  ctx.body = {
    message: &quot;获取数据成功&quot;,
    userinfo: ctx.session.userinfo
  }
})
//登录
router.post('/login', async (ctx) =&gt; {
  const {
    body
  } = ctx.request
  console.log('body', body)
  //设置session
  ctx.session.userinfo = body.username;
  ctx.body = {
    message: &quot;登录成功&quot;
  }
})
//登出
router.post('/logout', async (ctx) =&gt; {
  //设置session
  delete ctx.session.userinfo
  ctx.body = {
    message: &quot;登出系统&quot;
  }
})
</code></pre>
<h3>Token</h3>
<p>token 是一个令牌，浏览器第一次访问服务端时会签发一张令牌，之后浏览器每次携带这张令牌访问服务端就会认证该令牌是否有效，只要服务端可以解密该令牌，就说明请求是合法的，令牌中包含的用户信息还可以区分不同身份的用户。一般 token 由用户信息、时间戳和由 hash 算法加密的签名构成。</p>
<h4>Token 认证流程</h4>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li>
<li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 Token（request 头部添加 Authorization），如果验证成功，就向客户端返回请求的数据，如果不成功返回 401 错误码，鉴权失败。</li>
</ol>
<h4>Token 和 session 的区别</h4>
<ol>
<li>session-cookie 的缺点：（1）认证方式局限于在浏览器中使用，cookie 是浏览器端的机制，如果在 app 端就无法使用 cookie。（2）为了满足全局一致性，我们最好把 session 存储在 redis 中做持久化，而在分布式环境下，我们可能需要在每个服务器上都备份，占用了大量的存储空间。（3）在不是 Https 协议下使用 cookie，容易受到 CSRF 跨站点请求伪造攻击。</li>
<li>token 的缺点：（1）加密解密消耗使得 token 认证比 session-cookie 更消耗性能。（2）token 比 sessionId 大，更占带宽。</li>
<li>两者对比，它们的区别显而易见：（1）token 认证不局限于 cookie，这样就使得这种认证方式可以支持多种客户端，而不仅是浏览器。且不受同源策略的影响。（2）不使用 cookie 就可以规避 CSRF 攻击。（3）token 不需要存储，token 中已包含了用户信息，服务器端变成无状态，服务器端只需要根据定义的规则校验这个 token 是否合法就行。这也使得 token 的可扩展性更强。</li>
</ol>
<h4>JWT（JSON Web Token）</h4>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，这个 JSON 对象肯定不能裸传给用户，那谁都可以篡改这个对象发送请求。因此这个 JSON 对象会被服务器端签名加密后返回给用户，返回的内容就是一张令牌，以后用户每次访问服务器端就带着这张令牌。<br>
  这个 JSON 对象可能包含的内容就是用户的信息，用户的身份以及令牌的过期时间。</p>
<h5>JWT 的组成部分</h5>
<p>在该网站 <a href="https://link.juejin.cn?target=https%3A%2F%2Fjwt.io" title="https://jwt.io">JWT</a>，可以解码或编码一个 JWT。一个 JWT 形如：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/12/16b4b35d06740f92~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt=""></p>
<p>它由三部分组成：Header（头部）、Payload（负载）、Signature（签名）。</p>
<ol>
<li>Header 部分是一个 JSON 对象，描述 JWT 的元数据。一般描述信息为该 Token 的加密算法以及 Token 的类型。<code>{&quot;alg&quot;: &quot;HS256&quot;,&quot;typ&quot;: &quot;JWT&quot;}</code>的意思就是，该 token 使用 HS256 加密，token 类型是 JWT。这个部分基本相当于明文，它将这个 JSON 对象做了一个 Base64 转码，变成一个字符串。Base64 编码解码是有算法的，解码过程是可逆的。头部信息默认携带着两个字段。</li>
<li>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。有 7 个官方字段，还可以在这个部分定义私有字段。一般存放用户名、用户身份以及一些 JWT 的描述字段。它也只是做了一个 Base64 编码，因此肯定不能在其中存放秘密信息，比如说登录密码之类的。</li>
<li>Signature 是对前面两个部分的签名，防止数据篡改，如果前面两段信息被人修改了发送给服务器端，此时服务器端是可利用签名来验证信息的正确性的。签名需要密钥，密钥是服务器端保存的，用户不知道。算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用 &quot;点&quot;（.）分隔，就可以返回给用户。</li>
</ol>
<h5>JWT 的特点</h5>
<ol>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ol>
<h5>JWT 验证用户登录</h5>
<pre><code>//前端代码
//axios的请求拦截器，在每个request请求头上加JWT认证信息
axios.interceptors.request.use(
    config =&gt; {
        const token = window.localStorage.getItem(&quot;token&quot;);
        if (token) {
        // 判断是否存在token，如果存在的话，则每个http header都加上token
        // Bearer是JWT的认证头部信息
            config.headers.common[&quot;Authorization&quot;] = &quot;Bearer &quot; + token;
        }
        return config;
    },
    err =&gt; {
        return Promise.reject(err);
    }
);
//登录方法：在将后端返回的JWT存入localStorage
async login() {
    const res = await axios.post(&quot;/login-token&quot;, {
        username: this.username,
        password: this.password
    });
    localStorage.setItem(&quot;token&quot;, res.data.token);
},
//登出方法：删除JWT
async logout() {
    localStorage.removeItem(&quot;token&quot;);
},
async getUser() {
    await axios.get(&quot;/getUser-token&quot;);
}
</code></pre>
<pre><code>//后端代码
const jwt = require(&quot;jsonwebtoken&quot;);
const jwtAuth = require(&quot;koa-jwt&quot;);
//用来签名的密钥
const secret = &quot;it's a secret&quot;;

router.post(&quot;/login-token&quot;, async ctx =&gt; {
  const { body } = ctx.request;
  //登录逻辑，略，即查找数据库，若该用户和密码合法，即将其信息生成一个JWT令牌传给用户
  const userinfo = body.username;
  ctx.body = {
    message: &quot;登录成功&quot;,
    user: userinfo,
    // 生成 token 返回给客户端
    token: jwt.sign(
      {
        data: userinfo,
        // 设置 token 过期时间，一小时后，秒为单位
        exp: Math.floor(Date.now() / 1000) + 60 * 60
      },
      secret
    )
  };
});

//jwtAuth这个中间件会拿着密钥解析JWT是否合法。
//并且把JWT中的payload的信息解析后放到state中，ctx.state用于中间件的传值。
router.get(
  &quot;/getUser-token&quot;,
  jwtAuth({
    secret
  }),
  async ctx =&gt; {
    // 验证通过，state.user
    console.log(ctx.state.user);
    ctx.body = {
      message: &quot;获取数据成功&quot;,
      userinfo: ctx.state.user.data 
    };
  }
)
//这种密码学的方式使得token不需要存储，只要服务端能拿着密钥解析出用户信息，就说明该用户是合法的。
//若要更进一步的权限验证，需要判断解析出的用户身份是管理员还是普通用户。
</code></pre>
<h3>OAuth</h3>
<p>三方登入主要基于 OAuth 2.0。OAuth 协议为用户资源的授权提供了一个安全的、开放而又简易的标 准。与以往的授权方式不同之处是 OAuth 的授权不会使第三方触及到用户的帐号信息 (如用户名与密码)， 即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此 OAuth 是安全的。我们常见的提供 OAuth 认证服务的厂商有支付宝、QQ、微信。这样的授权方式使得用户使用门槛低，可以更好的推广自己的应用。<br>
  OAuth 相关文章推荐阮一峰老师的一系列文章 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2019%2F04%2Foauth_design.html" title="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html">OAuth 2.0</a> 。</p>
<h4>OAuth 认证流程</h4>
<p>OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。<br>
  OAuth 有四种获取令牌的方式，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。<br>
  在前后端分离的情境下，我们常使用授权码方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</p>
<h5>GitHub 第三方登录示例</h5>
<p>我们用例子来理清授权码方式的流程。</p>
<ol>
<li>在 GitHub 中备案第三方应用，拿到属于它的客户端 ID 和客户端密钥。
  在 github-settings-developer settings 中创建一个 OAuth App。并填写相关内容。填写完成后 Github 会给你一个客户端 ID 和客户端密钥。</li>
<li>此时在你的第三方网站就可以提供一个 Github 登录链接，用户点击该链接后会跳转到 Github。这一步拿着客户端 ID 向 Github 请求授权码 code。</li>
</ol>
<pre><code>const config = {
  client_id: '28926186082164bbea8f',
  client_secret: '07c4fdae1d5ca458dae3345b6d77a0add5a785ca'
}

router.get('/github/login', async (ctx) =&gt; {
  var dataStr = (new Date()).valueOf();
  //重定向到认证接口,并配置参数
  var path = &quot;https://github.com/login/oauth/authorize&quot;;
  path += '?client_id=' + config.client_id;

  //转发到授权服务器
  ctx.redirect(path);
})
</code></pre>
<ol start="3">
<li>用户跳转到 Github，输入 Github 的用户名密码，表示用户同意使用 Github 身份登录第三方网站。此时就会带着授权码 code 跳回第三方网站。跳回的地址在创建该 OAuth 时已经设置好了。<code>http://localhost:3000/github/callback</code></li>
<li>第三方网站收到授权码，就可以拿着授权码、客户端 ID 和客户端密钥去向 Github 请求 access_token 令牌。</li>
<li>Github 收到请求，向第三方网站颁发令牌。</li>
<li>第三方网站收到令牌，就可以暂时拥有 Github 一些请求的权限，比如说拿到用户信息，拿到这个用户信息之后就可以构建自己第三方网站的 token，做相关的鉴权操作。</li>
</ol>
<pre><code>router.get('/github/callback', async (ctx) =&gt; {
  console.log('callback..')
  const code = ctx.query.code;
  const params = {
    client_id: config.client_id,
    client_secret: config.client_secret,
    code: code
  }
  let res = await axios.post('https://github.com/login/oauth/access_token', params)
  const access_token = querystring.parse(res.data).access_token
  res = await axios.get('https://api.github.com/user?access_token=' + access_token)
  console.log('userAccess:', res.data)
  ctx.body = `
        &lt;h1&gt;Hello ${res.data.login}&lt;/h1&gt;
        &lt;img src=&quot;${res.data.avatar_url}&quot; alt=&quot;&quot;/&gt;
    `

})
</code></pre>

<h1>个人笔记：Nextjs14 中的 RSC</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7297159273906159657?searchId=20240130221020658A065315F1CE364277">juejin.cn</a></p>
</blockquote>
<h2>CSR</h2>
<p>客户端渲染（CSR）是在用户的浏览器端进行页面渲染的一种方式，比如 Vue 和 React。在项目开发结束后，Vue 或 React 的代码会被打包成多个 bundle.js 文件。这些文件放在服务器上，当用户访问网站时，服务器会返回这些 bundle.js 。浏览器接收到这些文件后，开始解析执行它们，触发网络请求获取数据并最终渲染页面内容。</p>
<p>这个流程包含了两个主要阶段。首先是请求并解析 bundle.js 文件，然后根据其中的逻辑，发起网络请求以获取数据并完成页面渲染。然而，当 bundle.js 文件过大时，它可能会阻塞解析过程，导致网络请求的延迟，进而导致页面出现白屏现象。另外，由于返回的 js 文件对搜索引擎爬虫不友好，可能导致爬虫无法获取有用的页面信息。</p>
<h2>SSR</h2>
<p>服务端渲染（SSR）是在服务器端进行页面渲染的方式，例如古早的 php、jsp 等技术。</p>
<p>用户访问网站时，会先在服务器请求数据并将其渲染为 HTML 字符串页面。如果页面包含交互逻辑（例如 click 事件），服务器会生成相应的 js 文件，然后将 HTML 字符串页面、js 发送到客户端，让 HTML 和 js 进行融合，恢复交互逻辑。</p>
<p>不同于 CSR 需要返回 bundle.js，SSR 返回的是 HTML 字符串和少量的 js 文件，明显减少了 bundle 体积。数据请求和渲染都在服务端进行，返回的是 HTML 字符串，浏览器能够即刻识别并呈现，有利于搜索引擎优化和提升首屏加载速度。</p>
<p>但 SSR 也不是没有缺点。</p>
<ul>
<li>首先，由于在服务端渲染，因此不能像 CSR 那样写复杂的交互逻辑，只能写简单的 click 事件。其次增加服务端的开销。最后如果请求的数据量过大，会导致服务端的压力，也会造成白屏。</li>
</ul>
<h2>RSC</h2>
<p>RSC 全称为 <strong>React Server Compent</strong>，是 React 团队提出在服务端运行 React 组件的方法。RSC 是 React 新的开发范式，目前 Nextjs 已经实现了 RSC。</p>
<p>下面这段代码是 Nextjs 中实现的服务端组件：</p>
<pre><code>import prisma from &quot;@/lib/prisma&quot;

const fetcher = async () =&gt;{
  return prisma.user.findUnique({where: { id: 1 }})
}

export default async function Home() {
  const data = await fetcher()
  return (
    &lt;main&gt;
      &lt;div&gt;{data?.username}&lt;/div&gt;
      &lt;div&gt;{data?.email}&lt;/div&gt;
    &lt;/main&gt; 
  )
}
</code></pre>
<blockquote>
<p>在 Nextjs 中所有组件默认为 RSC。</p>
</blockquote>
<p>这段代码中，Home 组件通过 fetcher 函数中的 prisma 向数据库查询了 id = 1 的用户，并将部分些信息放到的 jsx 中。你可能会担心，这段代码安全吗？事实上这段代码十分的安全，它是完全运行在服务端中，拿到结果以后会渲染为 HTML 返回给浏览器。
在传统的 React 组件中，我们需要将请求放在 useEffect 里面，这样才能保证只发送一次请求。 服务端组件支持异步 ，意味着可以在组件中请求数据，而不需要 useEffect 。
也由于是服务端渲染，所以 服务端组件不能使用 useState 和 useEffect，实现不了复杂的交互逻辑，那怎么办？别急，我会在往后的小节中介绍新的客户端组件。
到目前为止，看起来 RSC 跟 SSR 没什么区别呀，其实 RSC 跟 SSR 最大的区别是，它支持流式渲染。</p>
<h3>流式渲染</h3>
<p>流式渲染顾名思义，服务端组件支持将组件一点一点地流到浏览器中，并最终形成完整的页面。
假如一个页面有 A、B、C 三个组件，它们获取到数据的时间各不同。A 获取到数据的时间比较快，先将 A 返回到浏览器，后续依次把 B、C 返回到浏览器中，最终合并成完整的页面，就不用像 SSR 那样整个页面渲染为 HTML 才返回。 流式渲染返回的是类似 json 的数据，记录的组件的 dom 元素和内容。
<strong>那怎么使用流式渲染呢？</strong>
很简单，使用流式渲染需要搭配 React 的 <code>&lt;Suspense&gt;</code>，它支持子组件没完成加载时显示预备的组件，比如 loading。
先实现一个 A 组件，等 3 秒后才返回数据。</p>
<pre><code>import React from 'react'

const fetcher = async (): Promise&lt;string[]&gt; =&gt;{
  return new Promise((resolve) =&gt; {
    setTimeout(() =&gt; {
      resolve(['大海', '河', '蝴蝶结']);
    }, 3000);
  });
}

async function A() {
  const data = await fetcher()
  return (
    &lt;div&gt;
      {data.map( i =&gt; (&lt;span key={i}&gt;{i}&lt;/span&gt;))}
    &lt;/div&gt;
  )
}

export default A
</code></pre>
<p>在 <code>src/app/page.tsx</code>里面使用 <code>&lt;Suspense&gt;</code>包裹 A 组件就开启了流式渲染。</p>
<pre><code>import React, {Suspense} from 'react'
import A from '../components/a-test'

function Home() {
  return (
    &lt;div&gt;
       &lt;h2&gt;Home Page&lt;/h2&gt;
       &lt;Suspense fallback={&lt;div&gt;Loading...&lt;/div&gt;}&gt;
         &lt;A/&gt;
       &lt;/Suspense&gt;
    &lt;/div&gt;
  )
}

export default Home
</code></pre>
<h2><strong>流式渲染是怎么实现的？</strong></h2>
<blockquote>
<p>这里描述简单的流程，而非原理。</p>
</blockquote>
<p>流式渲染返回的是一个 json 字符串，记录着 dom 元素类型，内容等，这个 json 被称为 <strong>RSC Payload</strong></p>
<ol>
<li>等包裹在<code>&lt;Suspense&gt;</code>中的组件加载完成后，会被编译为 <strong>RSC Payload</strong>。</li>
</ol>
<pre><code>&quot;a:[\&quot;$\&quot;,\&quot;div\&quot;,null,{\&quot;children\&quot;:[[\&quot;$\&quot;,\&quot;span\&quot;,\&quot;大海\&quot;,{\&quot;children\&quot;:\&quot;大海\&quot;}],[\&quot;$\&quot;,\&quot;span\&quot;,\&quot;河\&quot;,{\&quot;children\&quot;:\&quot;河\&quot;}],[\&quot;$\&quot;,\&quot;span\&quot;,\&quot;蝴蝶结\&quot;,{\&quot;children\&quot;:\&quot;蝴蝶结\&quot;}]]}]\n&quot;
</code></pre>
<ol start="2">
<li>一开始返回的 HTML 中预留着 <code>&lt;tamplate&gt;</code>和<code>&lt;!--$?--&gt;</code>注释。</li>
</ol>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/725168f82ba54190837a140a33580b89~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=353&amp;h=141&amp;s=10464&amp;e=png&amp;b=fffefe" alt=""></p>
<ol start="3">
<li>服务端返回 <strong>RSC Payload</strong> 并且渲染后，会通过 dom 操作查找到两个<code>&lt;!--$?--&gt;</code>和 <code>&lt;tamplate&gt;</code>并将它们替换掉。</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f20e7183801b405aa0cd6e0653ef339d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=884&amp;h=540&amp;s=62536&amp;e=png&amp;b=ffffff" alt=""></p>
<h3>客户端组件</h3>
<p>在 RSC 范式中，传统的 React 组件被成为客户端组件 <strong>React Clinet Compent</strong>。在 客户端组件 中可以使用 <code>useEffect</code>、<code>useState</code>这些 hook，弥补了服务端组件不能进行复杂的交互逻辑的缺点。
那如何识别客户端组件呢？很简单，有 <code>use clinet</code>的就是 客户端组件。</p>
<pre><code>'use client'
import React, { useState } from 'react'

function Count() {
  const [num, setNum] = useState(0)

  const handleClick = () =&gt; {
    const t = num + 1
    setNum(t)
  }
  return (
    &lt;button onClick={handleClick}&gt;{num}&lt;/button&gt;
  )
}

export default Count
</code></pre>
<p>注意！不要看到 Client 就以为 客户端组件 只会在客户端渲染，在 Nextjs 中客户端组件也会在服务端预渲染一遍，但不会执行 <code>useEffect</code>，如果<code>useState</code>有初始值，也会渲染到页面中。</p>
<p>由于预渲染时 node 环境没有 dom，因此对于 dom 操作要将其放在 <code>useEffect</code>或者触发事件的函数里面。</p>
<h3>边界</h3>
<p>如果客户端组件包裹着服务端组组件，并且状态不断改变，那么服务端组件会重新渲染吗？
比如：</p>
<pre><code>function server() {
  return (
    &lt;div&gt;RSC&lt;/div&gt;
  )
}
</code></pre>
<pre><code>'use client'

import React, { useState } from 'react'
import Server from './server'

function Count() {
  const [num, setNum] = useState(0)

  const handleClick = () =&gt; {
    const t = num + 1
    setNum(t)
  }
  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt;{num}&lt;/button&gt;
      &lt;Server/&gt;
    &lt;/&gt;
    
  )
}
</code></pre>
<p>答案是会。因为，即使服务端组件已经在服务端完成了渲染，当它被引入到客户端组件并随着客户端组件的状态变化而重新渲染时，它也应该一同被重新渲染。</p>
<p>因此，Next.js 引入了一项新规则：在客户端组件中使用服务端组件时，将自动转换为客户端组件。
<strong>那我就想在客户端组件使用服务端组件呢？</strong></p>
<p>其实也可以，将服务端组件以 children 的形式传到客户端组件中，服务端组件就不会为变为客户端组件。</p>
<pre><code>function ServerCompent() {
  console.log('on server')
  return (
    &lt;div&gt;ServerCompent&lt;/div&gt;
  )
}
</code></pre>
<pre><code>'use client'
import React, { useState } from 'react'

function Count({
  children,
}: {
  children: React.ReactNode
}) {
  const [num, setNum] = useState(0)
  const handleClick = () =&gt; {
    const t = num + 1
    setNum(t)
  }
  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt;{num}&lt;/button&gt;
      {children}
    &lt;/&gt;
  )
}
</code></pre>
<p>在服务端组件中使用 Count 并且将 ServerCompent 以 children 的形式传进去。</p>
<pre><code>import React from 'react'
import Count from '../components/count'
import ServerCompent from '../components/server'

function About() {
  return (
    &lt;&gt;
      &lt;Count&gt;
        &lt;ServerCompent/&gt;
      &lt;/Count&gt;
    &lt;/&gt;
  )
}
</code></pre>
<p>我们提到过在客户端组件中使用的组件默认都是客户端组件。然而在服务端组件中，将其他服务端组件以 children 形式传入客户组件中，那该组件就不会变为客户端组件。</p>
<p>例如，About 和 ServerCompent 都是服务端组件，Count 是客户端组。在 About 中将 ServerCompent 以 children 的形式传入 Count 中， ServerCompent 依旧是客户端组件</p>
<p>为什么会这样呢？</p>
<p>在服务端组件的范围内属于服务端渲染，那么在服务端组件中使用客户端组件，客户端组件应该也要预渲染一遍，不然以 children 形式传入的服务端组件，怎么在服务端渲染。</p>

<h1>关于 useEffect 中请求数据以及竞态</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7072971408452059143">juejin.cn</a></p>
</blockquote>
<h2>背景</h2>
<p>一切起因皆是因为下面这段代码而起，甚至跟小伙伴们讨论了很久，大家可以先上个眼，后面会细说，戳 👉 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fuseeffectzhi-nan-krlz2v%3Ffile%3D%2Fsrc%2FApp.js" title="https://codesandbox.io/s/useeffectzhi-nan-krlz2v?file=/src/App.js">codesandbox</a></p>
<pre><code class="language-js">function Article({ id }) {
  const [article, setArticle] = useState(null)
  useEffect(() =&gt; {
    let didCancel = false
    console.log('effect', didCancel)
    async function fetchData() {
      console.log('setArticle begin', didCancel)
      new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          resolve(id)
        }, id);
      }).then(article =&gt; {
        // 快速点击 Add id 的 button，这里为什么会打印 true
        console.log('setArticle end', didCancel, article)
        // if (!didCancel) { // 把这一行代码注释就会出现错误覆盖状态值的情况
          setArticle(article)
        // }
      })
    }
    console.log('fetchData begin', didCancel)
    fetchData()
    console.log('fetchData end', didCancel)

    return () =&gt; {
      didCancel = true
      console.log('clear', didCancel)
    }

  }, [id])

  return &lt;div&gt;{article}&lt;/div&gt;
}

function App() {
  const [id, setId] = useState(5000)
  function handleClick() {
    setId(id-1000)
  }
  return (
    &lt;&gt;
      &lt;button onClick={handleClick}&gt;add id&lt;/button&gt;
      &lt;Article id={id}/&gt;
    &lt;/&gt;
  );
}

export default App;
</code></pre>
<p>关键代码是在 useEffect 中通过清除副作用函数来修改 didCancel 的值，再根据 didCancel 的值来判断是否立马执行 setState 的操作，其实就是为了解决 <code>竞态</code> 的情况。</p>
<blockquote>
<p>竞态，就是在混合了 async/await 和自顶向下数据流的代码中（props 和 state 可能会在 async 函数调用过程中发生改变），出现错误覆盖状态值的情况</p>
</blockquote>
<p>例如上面的例子，我们快速点击两次 button 后，在页面上我们会先看到 <code>3000</code> ，再看到 <code>4000</code> 的结果，这就是因为状态为 <code>4000</code> 的先执行，但是更晚返回，所以会覆盖上一次的状态，所以我们最后看到的是 <code>4000</code></p>
<h2>useEffect 清除副作用函数</h2>
<p>我们知道，如果在 useEffect 函数中返回一个函数，那么这个函数就是<code>清除函数</code>，它会在组件销毁的时候执行，但是其实，它会在组件每次重新渲染时执行，并且清除上一个 effect 的副作用。</p>
<blockquote>
<p>副作用是指一个 function 做了和本身运算返回值无关的事，比如：修改了全局变量、修改了传入的参数、甚至是 console.log()，所以 ajax 操作，修改 dom ，计时器，其他异步操作，其他会对外部产生影响的操作都是算作副作用</p>
</blockquote>
<pre><code>useEffect(() =&gt; {
  ChatAPI.subscribeToFriendStatus(props.id, handleStatusChange);
  return () =&gt; {
    ChatAPI.unsubscribeFromFriendStatus(props.id, handleStatusChange);
  };
});
</code></pre>
<p>假如第一次渲染的时候 props 是 {id: 10}，第二次渲染的时候是 { id: 20 }。你可能会认为发生了下面这些事：</p>
<ul>
<li>React 清除了 <code>{id: 10}</code>的 effect</li>
<li>React 渲染<code>{id: 20}</code>的 UI</li>
<li>React 运行<code>{id: 20}</code>的 effect</li>
</ul>
<p>事实并不是这样
React 只会在<code>浏览器绘制</code>后运行 effects。</p>
<ul>
<li>这使得你的应用更流畅因为大多数 effects 并不会阻塞屏幕的更新。</li>
<li>Effect 的清除同样被延迟了，上一次的 effect 会在重新渲染后被清除：</li>
</ul>
<ul>
<li>React 渲染<code>{id: 20}</code>的 UI</li>
<li>浏览器绘制，在屏幕上看到<code>{id: 20}</code>的 UI</li>
<li>React 清除<code>{id: 10}</code>的 effect</li>
<li>React 运行<code>{id: 20}</code>的 effect</li>
</ul>
<p>这里就会出现让大家迷惑的点，如果清除上一次的 effect 发生在 props 变成<code>{id: 20}</code>之后，那它为什么还能拿到旧的<code>{id: 10}</code></p>
<blockquote>
<p>因为组件内的每一个函数（包括事件处理函数，effects，定时器或者 API 调用等等）会捕获定义它们的那次渲染中的 props 和 state</p>
</blockquote>
<p>所以，effect 的清除并不会读取最新的 props，它只能读取到定义它的那次渲染中的 props 值</p>
<h2>分析最开始的🌰</h2>
<h3>分析</h3>
<p>回到我们最开始的例子，把注释掉的代码放开，就有了下面的分析。第一次渲染后</p>
<pre><code>function Article() {
  ...
  useEffect(() =&gt; {
    let didCancel = false
    async function fetchData() {
      new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
          resolve(id)
        }, id);
      }).then(article =&gt; {
        if (!didCancel) {
          setArticle(article)
        }
      })
    }
    fetchData()
  }, [5000])
  return () =&gt; {
    // 清除本次渲染副作用，给它编号 NO1，这里有个隐藏信息，此时这个函数内，还未执行前 didCancel = false
    didCancel = true
  }
}
// 等待 5s 后，页面显示 5000，
</code></pre>
<p>可以在<code>console.log('setArticle end', didCancel, article)</code>这行代码上打上断点，我们可以更直观的分析接下来的操作 👉 快速点击两次<code>button</code></p>
<pre><code>/**
    第一次点击，在页面绘制完成后，执行 useEffect
    首先执行上一次的清除函数，即函数 NO1，NO1 将上一次 effect 闭包内的 didCancel 设置为了 true
*/
function Article() {
  ...
  useEffect(() =&gt; {
    let didCancel = false
    async function fetchData() {
      new Promise((resolve) =&gt; {
        setTimeout(() =&gt; { // setTimeout1
          resolve(id)
        }, id);
      }).then(article =&gt; {
        if (!didCancel) {
          setArticle(article)
        }
      })
    }
    fetchData()
  }, [4000])
  return () =&gt; {
    // 清除本次渲染副作用，给它编号 NO2，这里有个隐藏信息，此时这个函数内作用域中的 didCancel = false
    didCancel = true
  }
}
</code></pre>
<p>从<code>DevTools</code>中可以看到：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32e7fe3a7b8e49bbb8409d307c5e3109~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p>
<pre><code>/**
    第二次点击，在页面绘制完成后，执行 useEffect
    首先执行上一次的清除函数，即函数 NO2，NO2 将上一次 effect 闭包内的 didCancel 设置为了 true
*/
function Article() {
  ...
  useEffect(() =&gt; {
    let didCancel = false
    async function fetchData() {
      new Promise((resolve) =&gt; {
        setTimeout(() =&gt; { // setTimeout2
          resolve(id)
        }, id);
      }).then(article =&gt; {
        if (!didCancel) {
          setArticle(article)
        }
      })
    }
    fetchData()
  }, [3000])
  return () =&gt; {
    // 清除本次渲染副作用，给它编号 NO3，这里有个隐藏信息，此时这个函数内作用域中的 didCancel = false
    didCancel = true
  }
}
</code></pre>
<p>从<code>DevTools</code>中可以看到：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5569e7301eab4016bf0da74c4c8ce7a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt=""></p>
<h3>结论</h3>
<p>第二次点击后，setTimeout2 先执行完，此时 didCancel 值为 false，所以会执行<code>setArticle</code>的操作，页面展示<code>3000</code>，为什么这里的 didCancel 为 false 呢，因为此时 NO2 的清除函数没有执行，它会在组件下一次重新渲染，或者组件卸载时执行。</p>
<p>再等待差不多 1s 后，setTimeout2 执行完，此时 didCancel 的值被 NO2 的清除函数设置为了 true，所以它不会执行<code>setArticle</code>的操作。这样就不会出现，先看到<code>4000</code>然后再变成<code>3000</code>的情况。</p>
<h2>useEffect 请求数据的方式</h2>
<h3>使用 async/await 获取数据</h3>
<pre><code>// 有同学想在组件挂在时请求初始化数据，可能就会用下面的写法
function App() {
    const [data, setData] = useState()
    useEffect(async () =&gt; {
        const result = await axios('/api/getData')
        
        setData(result.data)
    })
}
</code></pre>
<p>但是我们会发现，在控制台中有警告信息：
<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54192a2fa45243dc92667367e72eaaf4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?" alt="">
意思就是在 useEffect 中不能直接使用 async，因为 async 函数声明定义一个异步函数，该函数默认会返回一个隐式 Promise，但是，在 effect hook 中我们应该不返回任何内容或者返回一个清除函数。所以我们可以改成下面这样</p>
<pre><code>function App() {
    const [data, setData] = useState()
    useEffect(() =&gt; {
        const fetchData = async () =&gt; {
          const result = await axios(
            '/api/getData',
          );
          setData(result.data);
        };
        fetchData();
    })
}
</code></pre>
<h3>准确告诉 React 你的依赖项</h3>
<pre><code>function Greeting({ name }) {
  const [counter, setCounter] = useState(0);

  useEffect(() =&gt; {
    document.title = 'Hello, ' + name;
  });

  return (
    &lt;h1 class&gt;
      Hello, {name}
      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;Increment&lt;/button&gt;
    &lt;/h1&gt;
  );
}
</code></pre>
<p>我们每次点击 button 使 counter+1 的时候，effect hook 都会执行，这是没必要的，我们可以将<code>name</code>加到 effect 的依赖数组中，相当于告诉 React，当我<code>name</code>的值变化时，你帮我执行 effect 中的函数。</p>
<p>如果我们在依赖中添加所有 effect 中用到的组件内的值，有时效果也不太理想。比如：</p>
<pre><code>useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        setCount(count+1)
    }, 1000)
    return () =&gt; clearInterval(id)
}, [count])
</code></pre>
<p>虽然，每次 count 变化时会触发 effect 执行，但是每次执行时定时器会重新创建，效果不是最理想。我们添加<code>count</code>依赖，是因在<code>setCount</code>调用中用到了<code>count</code>，其他地方并没有用到<code>count</code>，所以我们可以将<code>setCount</code>的调用改成函数形式，让<code>setCount</code>在每次定时器更新时，自己就能拿到当前的<code>count</code>值。所以在 effect 依赖数组中，我们可以踢掉<code>count</code></p>
<pre><code>useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
        setCount(count =&gt; count+1)
    }, 1000)
    return () =&gt; clearInterval(id)
}, [])
</code></pre>
<h3>解耦来自 Actions 的更新</h3>
<p>我们修改上面的例子让它包含两个状态：<code>count</code>和<code>step</code></p>
<pre><code>function Counter() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(1);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      setCount(c =&gt; c + step);    
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [step]);
  return (
    &lt;&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;input value={step} onChange={e =&gt; setStep(Number(e.target.value))} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>此时，我们修改<code>step</code>又会重启定时器，因为它是依赖性之一。假如我们不想在<code>step</code>改变后重启定时器呢，该如何从 effect 中移除对<code>step</code>的依赖。
当你想更新一个状态，并且这个状态更新依赖于另一个状态的时候，在例子中就是<code>count</code>依赖<code>step</code>，我们可以用<code>useReducer</code>去替换它们</p>
<pre><code>function Counter() {
  const [state, dispatch] = useReducer(reducer, initState)
  const { count, step } = state
  
  const initState = {
      count: 0,
      step: 1
  }
  
  function reducer(state, action) {
      const { count, step } = state
      switch (action.type) {
          case 'tick':
              return { count: count + step, step }
          case 'step':
              return { count, step: action.step }
          default:
              throw new Error()
      }
  }

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      dispatch({ type: 'tick' })   
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [dispatch]);
  
  return (
    &lt;&gt;
      &lt;h1&gt;{count}&lt;/h1&gt;
      &lt;input value={step} onChange={e =&gt; setStep(Number(e.target.value))} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>上面代码中将<code>dispatch</code>作为 effect 依赖不会每次都触发 effect 的执行，因为 React 会保证<code>dispatch</code>在组件的声明周期内保持不变，所以不会重新创建定时器。</p>
<blockquote>
<p>你可以从依赖中去除<code>dispatch</code>，<code>setState</code>，<code>useRef</code>包裹的值，因为 React 会确保它们是静态的</p>
</blockquote>
<p>相比于直接在 effect 里面读取状态，它<code>dispatch</code>了一个<code>action</code>来描述发生了什么，这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由<code>reducer</code>去统一处理</p>
<blockquote>
<p>当你 dispatch 的时候，React 只是记住了 action，它会在下一次渲染中再次调用 reducer，所以 reducer 可以访问到组件中最新的<code>props</code></p>
</blockquote>

<h1>利用 WebSocket 和 EventSource 实现服务端推送</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844903736830066695?searchId=20240118154711D0B7224F42C488B76A60">juejin.cn</a></p>
</blockquote>
<p>可能有很多的同学有用 setInterval 控制 ajax 不断向服务端请求最新数据的经历 (轮询) 看</p>
<pre><code>setInterval(function() {
    $.get('/get/data-list', function(data, status) {
        console.log(data)
    })
}, 5000)
</code></pre>
<p>这样每隔 5 秒前端会向后台请求一次数据，实现上看起来很简单但是有个很重要的问题，就是我们没办法控制网速的稳定，不能保证在下次发请求的时候上一次的请求结果已经顺利返回，这样势必会有隐患，有聪明的同学马上会想到用 setTimeout 配合递归看下面的代码：</p>
<pre><code>function poll() {
    setTimeout(function() {
        $.get('/get/data-list', function(data, status) {
            console.log(data)
            poll()
        })
    }, 5000)
}
</code></pre>
<p>当结果返回之后再延时触发下一次的请求，这样虽然没办法保证两次请求之间的间隔时间完全一致但是至少可以保证数据返回的节奏是稳定的，看似已经实现了需求但是这么搞我们先不去管他的性能就代码结构也算不上优雅，</p>
<ul>
<li>为了解决这个问题可以让服务端长时间和客户端保持连接进行数据互通 h5新增了 WebSocket 和 EventSource 用来实现长轮询，下面我们来分析一下这两者的特点以及使用场景。</li>
</ul>
<h2>WebSocket</h2>
<p><strong>是什么：</strong> WebSocket 是一种通讯手段，基于 TCP 协议，默认端口也是 80 和 443，协议标识符是 ws（加密为 wss），它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据，不受跨域的限制。</p>
<p><strong>有什么用：</strong> WebSocket 用来解决 http 不能持久连接的问题，因为可以双向通信所以可以用来实现聊天室，以及其他由服务端主动推送的功能例如 实时天气、股票报价、余票显示、消息通知等。</p>
<h2>EventSource</h2>
<p><strong>是什么：</strong> EventSource 的官方名称应该是 Server-sent events（缩写 SSE）服务端派发事件，EventSource 基于 http 协议只是简单的单项通信，实现了服务端推的过程客户端无法通过 EventSource 向服务端发送数据。</p>
<ul>
<li>虽然不能实现双向通信但是在功能设计上他也有一些优点比如可以自动重连接, event IDs, 以及发送随机事件的能力（WebSocket 要借助第三方库比如 socket.io 可以实现重连。）</li>
</ul>
<p><strong>有什么用：</strong> 因为受单项通信的限制 EventSource 只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。</p>
<ul>
<li>EventSource 的使用更加便捷这也是他的优点。</li>
</ul>
<h2>WebSocket &amp; EventSource 的区别</h2>
<ol>
<li>WebSocket 基于 TCP 协议，EventSource 基于 http 协议。</li>
<li>EventSource 是单向通信，而 websocket 是双向通信。</li>
<li>EventSource 只能发送文本，而 websocket 支持发送二进制数据。</li>
<li>在实现上 EventSource 比 websocket 更简单。</li>
<li>EventSource 有自动重连接（不借助第三方）以及发送随机事件的能力。</li>
<li>websocket 的资源占用过大 EventSource 更轻量。</li>
<li>websocket 可以跨域，EventSource 基于 http 跨域需要服务端设置请求头。</li>
</ol>
<h2>EventSource 的实现案例</h2>
<p>客户端代码</p>
<pre><code>// 实例化 EventSource 参数是服务端监听的路由
var source = new EventSource('/EventSource-test')
source.onopen = function (event) { // 与服务器连接成功回调
  console.log('成功与服务器连接')
}
// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)
source.onmessage = function (event) { // 监听未命名事件
  console.log('未命名事件', event.data)
}
source.onerror = function (error) { // 监听错误
  console.log('错误')
}
// 监听指定类型的事件（可以监听多个）
source.addEventListener(&quot;myEve&quot;, function (event) {
  console.log(&quot;myEve&quot;, event.data)
})
</code></pre>
<p>服务端代码（node.js）</p>
<pre><code>const fs = require('fs')
const express = require('express') // npm install express
const app = express()

// 启动一个简易的本地server返回index.html
app.get('/', (req, res) =&gt; {
  fs.stat('./index.html', (err, stats) =&gt; {
    if (!err &amp;&amp; stats.isFile()) {
      res.writeHead(200)
      fs.createReadStream('./index.html').pipe(res)
    } else {
      res.writeHead(404)
      res.end('404 Not Found')
    }
  })
})

// 监听EventSource-test路由服务端返回事件流
app.get('/EventSource-test', (ewq, res) =&gt; {
  // 根据 EventSource 规范设置报头
  res.writeHead(200, {
    &quot;Content-Type&quot;: &quot;text/event-stream&quot;, // 规定把报头设置为 text/event-stream
    &quot;Cache-Control&quot;: &quot;no-cache&quot; // 设置不对页面进行缓存
  })
  // 用write返回事件流，事件流仅仅是一个简单的文本数据流，每条消息以一个空行(\n)作为分割。
  res.write(':注释' + '\n\n')  // 注释行
  res.write('data:' + '消息内容1' + '\n\n') // 未命名事件

  res.write(  // 命名事件
    'event: myEve' + '\n' +
    'data:' + '消息内容2' + '\n' +
    'retry:' + '2000' + '\n' +
    'id:' + '12345' + '\n\n'
  )

  setInterval(() =&gt; { // 定时事件
    res.write('data:' + '定时消息' + '\n\n')
  }, 2000)
})

// 监听 6788
app.listen(6788, () =&gt; {
  console.log(`server runing on port 6788 ...`)
})
</code></pre>
<p>客户端访问 <code>http://127.0.0.1:6788/</code> 会看到如下的输出：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/13/167a6bf535ecd347~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>来总结一下相关的 api，客户端的 api 很简单都在注释里了，服务端有一些要注意的地方：</p>
<h4>事件流格式？</h4>
<p>事件流仅仅是一个简单的文本数据流，文本应该使用 UTF-8 格式的编码。每条消息后面都由一个空行作为分隔符。以冒号开头的行为注释行，会被忽略。</p>
<h4>注释有何用？</h4>
<p>注释行可以用来防止连接超时，服务器可以定期发送一条消息注释行，以保持连接不断。</p>
<h4>EventSource 规范中规定了那些字段？</h4>
<p><code>event：</code> 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的 EventSource 对象上触发一个事件，事件类型就是该字段的字段值，你可以使用 addEventListener() 方法在当前 EventSource 对象上监听任意类型的命名事件，如果该条消息没有 event 字段，则会触发 onmessage 属性上的事件处理函数。 <code>data：</code> 消息的数据字段，如果该条消息包含多个 data 字段, 则客户端会用换行符把它们连接成一个字符串来作为字段值。 <code>id：</code> 事件 ID，会成为当前 EventSource 对象的内部属性 &quot;最后一个事件 ID&quot; 的属性值。 <code>retry：</code> 一个整数值，指定了重新连接的时间 (单位为毫秒)，如果该字段值不是整数，则会被忽略。</p>
<p>上文提过 retry 字段是用来指定重连时间的，那为什么要重连呢，我们拿 node 来说，大家知道node 的特点是单线程异步 io，单线程就意味着如果 server 端报错那么服务就会停掉，当然在node 开发的过程中会处理这些异常，但是一旦服务停掉了这时就需要用 pm2 之类的工具去做重启操作，这时候 server 虽然正常了，但是客户端的 EventSource 链接还是断开的这时候就用到了重连。</p>
<h4>EventSource案例中消息要用 \ n 结尾？</h4>
<p>\n 是换行的转义字符，EventSource 规范规定每条消息后面都由一个空行作为分隔符，结尾加一个 \ n 表示一个字段结束，加两个 \ n 表示一条消息结束。(两个 \ n 表示换行之后又加了一个空行)</p>
<p><em>注: 如果一行文本中不包含冒号，则整行文本会被解析成为字段名，其字段值为空。</em></p>
<h2>WebSocket 的实现案例</h2>
<h4>WebSocket 的客户端原生 api</h4>
<p><code>var ws = new WebSocket('ws://localhost:8080')</code> WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。
<code>ws.onopen = function(){}</code> 用于指定连接成功后的回调函数。
<code>ws.onclose = function(){}</code> 用于指定连接关闭后的回调函数
<code>ws.onmessage = function(){}</code> 用于指定收到服务器数据后的回调函数
<code>ws.send('data')</code> 实例对象的 send() 方法用于向服务器发送数据
<code>socket.onerror = function(){}</code> 用于指定报错时的回调函数</p>
<h4>socket.io 和 ws 有什么不同</h4>
<p><code>Socket.io：</code> Socket.io 是一个 WebSocket 库，包括了客户端的 js 和服务器端的 nodejs，它会自动根据浏览器从 WebSocket、AJAX 长轮询、Iframe 流等等各种方式中选择最佳的方式来实现网络实时应用（不支持 WebSocket 的情况会降级到 AJAX 轮询），非常方便和人性化，兼容性非常好，支持的浏览器最低达 IE5.5。屏蔽了细节差异和兼容性问题，实现了跨浏览器 / 跨设备进行双向数据通信。
<code>ws：</code> 不像 <a href="https://link.juejin.cn?target=http%3A%2F%2Fsocket.io" title="http://socket.io">socket.io</a> 模块， ws 是一个单纯的 websocket 模块，不提供向上兼容，不需要在客户端挂额外的 js 文件。在客户端不需要使用二次封装的 api 使用浏览器的原生 Websocket API 即可通信。</p>
<h4>基于 socket.io 实现 WebSocket 双向通信</h4>
<p>客户端代码</p>
<pre><code>&lt;button id=&quot;closeSocket&quot;&gt;断开连接&lt;/button&gt;
&lt;button id=&quot;openSocket&quot;&gt;恢复连接&lt;/button&gt;
&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
// 建立连接 默认指向 window.location
let socket = io('http://127.0.0.1:6788')

openSocket.onclick = () =&gt; {
  socket.open()  // 手动打开socket 也可以重新连接
}
closeSocket.onclick = () =&gt; {
  socket.close() // 手动关闭客户端对服务器的链接
}

socket.on('connect', () =&gt; { // 连接成功
  // socket.id是唯一标识，在客户端连接到服务器后被设置。
  console.log(socket.id)
})

socket.on('connect_error', (error) =&gt; {
  console.log('连接错误')
})
socket.on('disconnect', (timeout) =&gt; {
  console.log('断开连接')
})
socket.on('reconnect', (timeout) =&gt; {
  console.log('成功重连')
})
socket.on('reconnecting', (timeout) =&gt; {
  console.log('开始重连')
})
socket.on('reconnect_error', (timeout) =&gt; {
  console.log('重连错误')
})

// 监听服务端返回事件
socket.on('serverEve', (data) =&gt; {
  console.log('serverEve', data)
})

let num = 0
setInterval(() =&gt; {
  // 向服务端发送事件
  socket.emit('feEve', ++num)
}, 1000)
</code></pre>
<p>服务端代码（node.js）</p>
<pre><code>const app = require('express')()
const server = require('http').Server(app)
const io = require('socket.io')(server, {})

// 启动一个简易的本地server返回index.html
app.get('/', (req, res) =&gt; {
  res.sendfile(__dirname + '/index.html')
})

// 监听 6788
server.listen(6788, () =&gt; {
  console.log(`server runing on port 6788 ...`)
})

// 服务器监听所有客户端 并返回该新连接对象
// 每个客户端socket连接时都会触发 connection 事件
let num = 0
io.on('connection', (socket) =&gt; {

  socket.on('disconnect', (reason) =&gt; {
    console.log('断开连接')
  })
  socket.on('error', (error) =&gt; {
    console.log('发生错误')
  })
  socket.on('disconnecting', (reason) =&gt; {
    console.log('客户端断开连接但尚未离开')
  })

  console.log(socket.id) // 获取当前连接进入的客户端的id
  io.clients((error, ids) =&gt; {
    console.log(ids)  // 获取已连接的全部客户机的ID
  })

  // 监听客户端发送的事件
  socket.on('feEve', (data) =&gt; {
    console.log('feEve', data)
  })
  // 给客户端发送事件
  setInterval(() =&gt; {
    socket.emit('serverEve', ++num)
  }, 1000)
})

/*
  io.close()  // 关闭所有连接
*/
</code></pre>
<p><code>const io = require('socket.io')(server, {})</code> 第二个参数是配置项，可以传入如下参数：</p>
<ul>
<li>path: '/socket.io' 捕获路径的名称</li>
<li>serveClient: false 是否提供客户端文件</li>
<li>pingInterval: 10000 发送消息的时间间隔</li>
<li>pingTimeout: 5000 在该时间下没有数据传输连接断开</li>
<li>origins: '*' 允许跨域</li>
<li>...</li>
</ul>
<p>上面基于 socket.io 的实现中 <code>express</code> 做为 socket 通信的依赖服务基础 <code>socket.io</code> 作为 socket 通信模块，实现了双向数据传输。最后，需要注意的是，在服务器端 <code>emit</code> 区分以下三种情况：</p>
<ul>
<li><code>socket.emit()</code> ：向建立该连接的客户端发送</li>
<li><code>socket.broadcast.emit()</code> ：向除去建立该连接的客户端的所有客户端发送</li>
<li><code>io.sockets.emit()</code> ：向所有客户端发送 等同于上面两个的和</li>
<li><code>io.to(id).emit()</code> : 向指定 id 的客户端发送事件</li>
</ul>
<h4>基于 ws 实现 WebSocket 双向通信</h4>
<p>客户端代码</p>
<pre><code>let num = 0
let ws = new WebSocket('ws://127.0.0.1:6788')
ws.onopen = (evt) =&gt; {
  console.log('连接成功')
  setInterval(() =&gt; {
    ws.send(++ num)  // 向服务器发送数据
  }, 1000)
}
ws.onmessage = (evt) =&gt; {
  console.log('收到服务端数据', evt.data)
}
ws.onclose = (evt) =&gt; {
  console.log('关闭')
}
ws.onerror = (evt) =&gt; {
  console.log('错误')
}
closeSocket.onclick = () =&gt; {
  ws.close()  // 断开连接
}
</code></pre>
<p>服务端代码（node.js）</p>
<pre><code>const fs = require('fs')
const express = require('express')
const app = express()

// 启动一个简易的本地server返回index.html
const httpServer = app.get('/', (req, res) =&gt; {
  res.writeHead(200)
  fs.createReadStream('./index.html').pipe(res)
}).listen(6788, () =&gt; {
  console.log(`server runing on port 6788 ...`)
})

// ws
const WebSocketServer = require('ws').Server
const wssOptions = {  
  server: httpServer,
  // port: 6789,
  // path: '/test'
}
const wss = new WebSocketServer(wssOptions, () =&gt; {
  console.log(`server runing on port ws 6789 ...`)
})

let num = 1
wss.on('connection', (wsocket) =&gt; {
  console.log('连接成功')

  wsocket.on('message', (message) =&gt; {
    console.log('收到消息', message)
  })
  wsocket.on('close', (message) =&gt; {
    console.log('断开了')
  })
  wsocket.on('error', (message) =&gt; {
    console.log('发生错误')
  })
  wsocket.on('open', (message) =&gt; {
    console.log('建立连接')
  })

  setInterval(() =&gt; {
    wsocket.send( ++num )
  }, 1000)
})
</code></pre>
<p>上面代码中在 <code>new WebSocketServer</code> 的时候传入了 <code>server: httpServer</code> 目的是统一端口，虽然 WebSocketServer 可以使用别的端口，但是统一端口还是更优的选择，其实 express 并没有直接占用 6788 端口而是 express 调用了内置 http 模块创建了 http.Server 监听了 6788。express 只是把响应函数注册到该 http.Server 里面。类似的，WebSocketServer 也可以把自己的响应函数注册到 http.Server 中，这样同一个端口，根据协议，可以分别由 express 和 ws 处理。我们拿到 express 创建的 http.Server 的引用，再配置到 wssOptions.server 里让 WebSocketServer 根据我们传入的 http 服务来启动，就实现了统一端口的目的。</p>
<p>要始终注意，浏览器创建 WebSocket 时发送的仍然是标准的 HTTP 请求。无论是 WebSocket 请求，还是普通 HTTP 请求，都会被 http.Server 处理。具体的处理方式则是由 express 和 WebSocketServer 注入的回调函数实现的。WebSocketServer 会首先判断请求是不是 WS 请求，如果是，它将处理该请求，如果不是，该请求仍由 express 处理。所以，WS 请求会直接由 WebSocketServer 处理，它根本不会经过 express。</p>
<ul>
<li>案例仓库：https://github.com/cp0725/YouChat/tree/master/webSocket-eventSource-test* * 部分概念参考自 https://www.w3cschool.cn/socket/*</li>
</ul>

<h1>受控和非受控组件真的那么难理解吗？(React 实际案例详解)</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6858276396968951822?searchId=202402011426002E0BAE0A227ECB1B2AAC">juejin.cn</a></p>
</blockquote>
<h3>受控组件基本概念</h3>
<p>通过名称，我们可以猜测一下这两个词是什么意思：</p>
<ul>
<li>受控组件：受我们控制的组件</li>
<li>非控组件：不受我们控制的组件</li>
</ul>
<p>其实也就是我们<strong>对某个组件状态的掌控，它的值是否只能由用户设置，而不能通过代码控制</strong>。</p>
<p>我们知道，在<code>React</code>中定义了一个<code>input</code>输入框的话，它并没有类似于<code>Vue</code>里<code>v-model</code>的这种双向绑定功能。</p>
<ul>
<li>也就是说，我们并没有一个指令能够将数据和输入框结合起来，用户在输入框中输入内容，然后数据同步更新。</li>
</ul>
<p>在 HTML 的表单元素中，它们通常自己维护一套<code>state</code>，并随着用户的输入自己进行<code>UI</code>上的更新，这种行为是不被我们程序所管控的。
如果将<code>React</code>里的<code>state</code>属性和表单元素的值建立依赖关系，再通过<code>onChange</code>事件与<code>setState()</code>结合更新<code>state</code>属性，就能达到控制用户输入过程中表单发生的操作。被<code>React</code>以这种方式控制取值的表单输入元素就叫做<strong>受控组件</strong>。</p>
<h3>select 受控组件</h3>
<p>对于其它的表单元素使用起来也差不多，可能就是属性名和事件不同而已。
例如<code>input</code>类型为<code>text</code>的表单元素中使用的是：</p>
<ul>
<li><code>value</code></li>
<li><code>onChange</code>
对于<code>textarea</code>标签也和它一样是使用<code>value</code>和<code>onChange</code>：</li>
</ul>
<pre><code>&lt;textarea value={this.state.value} onChange={this.handleChange} /&gt;
</code></pre>
<h4>单选 select</h4>
<p>对于<code>select</code>表单元素来说，<code>React</code>中将其转化为受控组件可能和原生<code>HTML</code>中有一些区别。
在原生中，我们默认一个<code>select</code>选项选中使用的是<code>selected</code>，比如下面这样：</p>
<pre><code>&lt;select&gt;
  &lt;option value=&quot;sunshine&quot;&gt;阳光&lt;/option&gt;
  &lt;option value=&quot;handsome&quot;&gt;帅气&lt;/option&gt;
  &lt;option selected value=&quot;cute&quot;&gt;可爱&lt;/option&gt;
  &lt;option value=&quot;reserved&quot;&gt;高冷&lt;/option&gt;
&lt;/select&gt;
</code></pre>
<p>但是如果是使用<code>React</code>受控组件来写的话就不用那么麻烦了，因为它允许在根<code>select</code>标签上使用<code>value</code>属性，去控制选中了哪个。这样的话，对于我们也更加便捷，在用户每次重选之后我们只需要在根标签中更新它，就像是这个案例🌰：</p>
<pre><code>class SelectComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { value: 'cute' };
  }
  handleChange(event) {
    this.setState({value: event.target.value});
  }
  handleSubmit(event) {
    alert('你今日相亲对象的类型是: ' + this.state.value);
    event.preventDefault();
  }
  render() {
    return (
      &lt;form onSubmit={(e) =&gt; this.handleSubmit(e)}&gt;
        &lt;label&gt;
          你今日相亲对象的类型是:
          &lt;select value={this.state.value} onChange={(e) =&gt; this.handleChange(e)}&gt;
            &lt;option value=&quot;sunshine&quot;&gt;阳光&lt;/option&gt;
            &lt;option value=&quot;handsome&quot;&gt;帅气&lt;/option&gt;
            &lt;option value=&quot;cute&quot;&gt;可爱&lt;/option&gt;
            &lt;option value=&quot;reserved&quot;&gt;高冷&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
export default SelectComponent;
</code></pre>
<p>可以看到不论是<code>input</code>类型为<code>text</code>的控件还是<code>textarea、select</code>在实现为<strong>受控组件</strong>上都差不多。</p>
<h4>多选 select</h4>
<p>多选<code>select</code>的话，对比单选来说，只有这两处改动：</p>
<ul>
<li>给<code>select</code>标签设置<code>multiple</code>属性为<code>true</code></li>
<li><code>select</code>标签<code>value</code>绑定的值为一个数组</li>
</ul>
<p>呆呆这里也来小小的写一个案例吧：</p>
<pre><code>class SelectComponent extends React.Component {
  constructor(props) {
    super(props);
    // this.state = { value: 'cute' };
    this.state = { value: ['cute'] };
  }

  handleChange(event) {
    console.log(event.target.value)
    const val = event.target.value;
    const oldValue = this.state.value;
    const i = this.state.value.indexOf(val);
    const newValue = i &gt; -1 ? [...oldValue].splice(i, 1) : [...oldValue, val];
    this.setState({value: newValue});
  }

  handleSubmit(event) {
    alert('你今日相亲对象的类型是: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      &lt;form onSubmit={(e) =&gt; this.handleSubmit(e)}&gt;
        &lt;label&gt;
          你今日相亲对象的类型是:
          &lt;select multiple={true} value={this.state.value} onChange={(e) =&gt; this.handleChange(e)}&gt;
            &lt;option value=&quot;sunshine&quot;&gt;阳光&lt;/option&gt;
            &lt;option value=&quot;handsome&quot;&gt;帅气&lt;/option&gt;
            &lt;option value=&quot;cute&quot;&gt;可爱&lt;/option&gt;
            &lt;option value=&quot;reserved&quot;&gt;高冷&lt;/option&gt;
          &lt;/select&gt;
        &lt;/label&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    );
  }
}
export default SelectComponent;
</code></pre>
<h3>动态表单受控组件案例</h3>
<p>上面👆咱们实现了一些简单的受控组件案例，接着来玩个稍微难点的。
先看一下我们的需求：
实现一个组件，传入以下数组，自动渲染出表单：
(<code>CInput</code>代表一个输入框，<code>CSelect</code>代表一个选择框)</p>
<pre><code>// 决定表单的结构
const formConfig = [
  {
    Component: CInput,
    label: '姓名',
    field: 'name',
  },
  {
    Component: CSelect,
    label: '性别',
    field: 'sex',
    options: [{ label: '男', value: 'man' }, { label: '女', value: 'woman' }]
  }
]
// 决定表单的内容
this.state = {
  name: '霖呆呆',
  sex: 'man'
}
</code></pre>
<p>效果：
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/269c41a5c93f4d1ca41c65cd430a1896~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p>
<p>也就是来实现一个简单的动态表单，看看受控组件在其中的应用。</p>
<ul>
<li><code>formConfig</code>决定了表单的结构，也就是定义表单中会有哪些项</li>
<li><code>this.state</code>中定义了表单中各项的值是什么，它与<code>formConfig</code>是靠<code>formConfig</code>中各项的<code>field</code>字段来建立链接的。</li>
</ul>
<p>知道了上面👆这些东西，我们就能很快写出这个动态表单组件的大概样子了：</p>
<p>(我们就把这个组件命名为<code>formComponent</code>吧，重点看<code>render</code>部分)</p>
<pre><code>import React, { Component } from 'react';
import { CInput, CSelect } from './components'
export default class FormComponent extends Component {
	constructor (props) {
    super(props);
    this.state = {
      name: '霖呆呆',
      sex: 'man'
    }
  }
  formConfig = [
    {
      Component: CInput,
      label: '姓名',
      field: 'name',
    },
    {
      Component: CSelect,
      label: '性别',
      field: 'sex',
      options: [{ label: '男', value: 'man' }, { label: '女', value: 'woman' }]
    }
  ]
  render () { // 重点在这
    return (
      &lt;form style={{marginTop: '50px'}}&gt;
        {
          this.formConfig.map((item) =&gt; { // 枚举formConfig
            const { Type, field, name } = item;
            const ControlComponent = item.Component; // 提取Component
            return (
              &lt;ControlComponent key={field} /&gt;
            )
          })
        }
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>可以看到，<code>render</code>部分我们做了这么几件事：</p>
<ul>
<li>枚举<code>formConfig</code>数组</li>
<li>提取出每一项里的<code>Component</code>，赋值给<code>ControlComponent</code></li>
<li>渲染出每一项<code>Component</code></li>
</ul>
<p><code>ControlComponent</code>变量的意义在于告诉<code>React</code>，需要渲染出哪一个组件，如果<code>item.Component</code>是<code>CInput</code>，那么最终渲染出的就是<code>&lt;CInput /&gt;</code>。</p>
<p>这样就保证了能把<code>formConfig</code>数组中的每一个表单项都渲染出来，但是这些表单项现在还是不受我们控制的，我们需要用前面学到的<code>value</code>和<code>onChange</code>和每个<code>ControlComponent</code>建立联系，就像是这样：</p>
<pre><code>&lt;ControlComponent
  key={field}
  name={field}
  value={this.state[field]}
  onChange={this.onChange}
  {...item}
/&gt;
</code></pre>
<p>我们把<code>this.state[field]</code>设置到<code>value</code>上，把<code>this.onChange</code>设置到<code>onChange</code>属性上。(可想而之，<code>CInput</code>和<code>CSelect</code>组件中就能用<code>this.props</code>来接收传入的属性了，例如<code>this.props.value</code>)</p>
<p>那么这时候<code>value</code>已经确定了，它就是由<code>this.state[field]</code>决定的，如果<code>field</code>是<code>&quot;sex&quot;</code>的话，<code>value</code>的值就是<code>&quot;man&quot;</code>。</p>
<p>所以来看看<code>onChange</code>方法该怎样写：</p>
<pre><code>onChange = (event, field) =&gt; {
  const target = event.target;
  this.setState({
    [field]: target.value
  })
}
</code></pre>
<p>这个方法其实也很简单，它接受一个<code>event</code>和<code>field</code>，在<code>event</code>中就可以获取到用户输入 / 选择的值了。</p>
<p>好的👌，接下来让我们快速的看一下<code>CInput</code>和<code>CSelect</code>是如何实现的吧：</p>
<p><em>components/CInput.jsx</em>:</p>
<pre><code>import React, { Component } from 'react';

export default class CInput extends Component {
  constructor (props) {
    super(props);
  }
  render () {
    const { name, field, value, onChange } = this.props;
    return (
      &lt;&gt;
        &lt;label&gt;
          {name}
        &lt;/label&gt;
        &lt;input name={field} value={value} onChange={(e) =&gt; onChange(e, field)} /&gt;
      &lt;/&gt;
    )
  }
}
</code></pre>
<p><em>components/CSelect.jsx</em>:</p>
<pre><code>import React, { Component } from 'react';

export default class CSelect extends Component {
  constructor (props) {
    super(props);
  }
  render () {
    const { name, field, options, value, onChange } = this.props;
    return (
      &lt;&gt;
        &lt;label&gt;
          {name}
        &lt;/label&gt;
        &lt;select name={field} value={value} onChange={(e) =&gt; onChange(e, field)}&gt;
          {options.length&gt;0 &amp;&amp; options.map(option =&gt; {
            return &lt;option key={option.value} value={option.value}&gt;{option.label}&lt;/option&gt;
          })}
        &lt;/select&gt;
      &lt;/&gt;
    )
  }
}
</code></pre>
<h3>非受控组件</h3>
<p>上面👆向大家展示的是受控组件的一些基本概念还有相关操作，</p>
<ul>
<li>对于受控组件，我们需要为每个<code>状态更新</code>(例如<code>this.state.username</code>) 编写一个<code>事件处理程序</code>(例如<code>this.setState({ username: e.target.value })</code>)。
那么还有一种场景是：我们仅仅是想要获取某个表单元素的值，而不关心它是如何改变的。对于这种场景，我们有什么应对的方法吗🤔️？
唔...<code>input</code>标签它实际也是一个<code>DOM</code>元素，那么我们是不是可以用获取<code>DOM</code>元素信息的方式来获取表单元素的值呢？也就是使用<code>ref</code>。
就像下面👇这个案例一样：</li>
</ul>
<pre><code>import React, { Component } from 'react';

export class UnControll extends Component {
  constructor (props) {
    super(props);
    this.inputRef = React.createRef();
  }
  handleSubmit = (e) =&gt; {
    console.log('我们可以获得input内的值为', this.inputRef.current.value);
    e.preventDefault();
  }
  render () {
    return (
      &lt;form onSubmit={e =&gt; this.handleSubmit(e)}&gt;
        &lt;input defaultValue=&quot;lindaidai&quot; ref={this.inputRef} /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>在输入框输入内容后，点击提交按钮，我们可以通过<code>this.inputRef</code>成功拿到<code>input</code>的<code>DOM</code>属性信息，包括用户输入的值，这样我们就不需要像受控组件一样，单独的为每个表单元素维护一个状态。</p>
<p>同时我们也可以用<code>defaultValue</code>属性来指定表单元素的默认值。</p>
<h3>特殊的文件 file 标签</h3>
<p>另外在<code>input</code>中还有一个比较特殊的情况，那就是<code>file</code>类型的表单控件。
<strong>对于 file 类型的表单控件它始终是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。</strong>
例如我现在想要通过状态更新来控制它：</p>
<pre><code>import React, { Component } from 'react';

export default class UnControll extends Component {
  constructor (props) {
    super(props);
    this.state = {
      files: []
    }
  }
  handleSubmit = (e) =&gt; {
    e.preventDefault();
  }
  handleFile = (e) =&gt; {
    console.log(e.target.files);
    const files = [...e.target.files];
    console.log(files);
    this.setState({
      files
    })
  }
  render () {
    return (
      &lt;form onSubmit={e =&gt; this.handleSubmit(e)}&gt;
        &lt;input type=&quot;file&quot; value={this.state.files} onChange={(e) =&gt; this.handleFile(e)} /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>在选择了文件之后，我试图用<code>setState</code>来更新，结果却报错了：
所以我们应当使用非受控组件的方式来获取它的值，可以这样写：</p>
<pre><code>import React, { Component } from 'react';

export default class FileComponent extends Component {
  constructor (props) {
    super(props);
    this.fileRef = React.createRef();
  }
  handleSubmit = (e) =&gt; {
    console.log('我们可以获得file的值为', this.fileRef.current.files);
    e.preventDefault();
  }
  render () {
    return (
      &lt;form onSubmit={e =&gt; this.handleSubmit(e)}&gt;
        &lt;input type=&quot;file&quot; ref={this.fileRef} /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
      &lt;/form&gt;
    )
  }
}
</code></pre>
<p>这里获取到的<code>files</code>是一个数组哈，当然，如果你没有开启多选的话，这个数组的长度始终是<code>1</code>，开启多选也非常简单，只需要添加<code>multiple</code>属性即可：</p>
<pre><code>&lt;input type=&quot;file&quot; multiple ref={this.fileRef} /&gt;
</code></pre>
<p>React 官方的话来说，绝大部分时候推荐使用<code>受控组件</code>来实现表单，因为在受控组件中，表单数据由<code>React</code>组件负责处理；当然如果选择<code>受受控组件</code>的话，表单数据就由<code>DOM</code>本身处理。</p>
<p>另外在学习两者的时候，呆呆也发现了一些写的比较好的文章，比这篇更深入，推荐给大家哟：</p>
<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F37579677" title="https://zhuanlan.zhihu.com/p/37579677">《在实际业务中如何灵活运用受控组件与非受控组件》</a></li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fneoveee%2Farticle%2Fdetails%2F95873911" title="https://blog.csdn.net/neoveee/article/details/95873911">《关于受控组件的思考》</a></li>
</ul>

<h1>同学，请实现一个扫码登录</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7326268998490865673?utm_source=gold_browser_extension">juejin.cn</a></p>
</blockquote>
<p><strong>0. 什么叫轮询？</strong>
所谓的轮询就是</p>
<ul>
<li>由后端维护某个状态，或是一种连续多篇的数据（如分页、分段）</li>
<li>由前端决定按序访问的方式将所有片段依次查询，直到后端给出终止状态的响应（结束状态、分页的最后一页等）
<strong>1. 轮询的方案？</strong>
一般有两种解决方案：</li>
<li>一种是使用<code>websocket</code>，可以让后端主动推送数据到前端；</li>
<li>一种是前端主动轮询（上网查了下细分为长轮询和短轮询），通过大家熟悉的定时器（<code>setInterval</code>和<code>setTimeout</code>）实现。</li>
</ul>
<h2><strong>遇到的问题：</strong></h2>
<p>1、由于看需求文档上交互流程比较清晰，最开始没去网上查找实现方案，自己直接整了一版<code>setInterval</code>的轮询实现。在跟后台联调的过程中发现定时器每 1s 请求一次接口，发现很多接口没等响应就开启下一次的请求，很多请求都还在 pending 中，</p>
<ul>
<li>可以通过<code>setTimeout</code>来优化，具体就是用<code>setTimeout</code>递归调用方式模拟<code>setInterval</code>的效果，达到只有上一次请求成功后才开启下一次的请求。</li>
</ul>
<p>2、在自测了过程中又发现了另外一个问题，<code>stopPolling</code>方法中<code>clearTimeout</code>似乎无法阻止<code>setTimeout</code>的执行，二维码失效后请求仍在不停发出，这就很奇怪了。
虽然 clearTimeout 已经清除了定时器，但此时有请求已经在进行中，导致再次进入了循环体，重新开启了定时器。解决办法就是，需要手动声明一个标识位<code>isStop</code>来阻止循环体的执行。</p>
<pre><code>stopPolling() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
        // 标记终止轮询(仅clearTimeout无法阻止)
        this.isStop = true;
      }
    },
</code></pre>
<p>3、解决了上面提到的问题，就在以为万事大吉，只待提测的时候。后台同事发现了一个问题（点赞后台同事的尽责之心）：他在反复切换登录方式（扫码登录 &lt;-&gt; 账号密码登录）的过程中，发现后台日志有一段时间打印的<code>qrcId</code>不是最新的。然后我这边试了下，确实在切换频率过高时，此时有未完成的请求仍在进行中，导致<code>qrcId</code>被重新赋值了。虽然已经在<code>beforeDestroy</code>里调用了<code>stopPolling</code>清除定时器, 但此时请求是未停止的。聪明的小伙伴们肯定想到<code>axios</code>的<code>cancelToken</code>可以取消未完成的请求</p>

<h1>带你深度解锁 Webpack 系列 (基础篇)</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6844904079219490830?searchId=2024013109533719B9C5AE5C320162A1DF">juejin.cn</a></p>
</blockquote>
<h3>1.webpack 是什么？</h3>
<p><code>webpack</code> 是一个现代 <code>JavaScript</code> 应用程序的静态模块打包器，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。</p>
<h3>2.webpack 的核心概念</h3>
<ul>
<li>entry: 入口</li>
<li>output: 输出</li>
<li>loader: 模块转换器，用于把模块原内容按照需求转换成新内容</li>
<li>插件 (plugins): 扩展插件，在 webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情</li>
</ul>
<h3>3. 初始化项目</h3>
<p>为了更清楚得查看打包后的代码，使用 <code>development</code> 模式。
可以看到项目下多了个 <code>dist</code> 目录，里面有一个打包出来的文件 <code>main.js</code>。
<code>webpack</code> 有默认的配置，如默认的入口文件是 <code>./src</code>，默认打包到<code>dist/main.js</code>
查看 <code>dist/main.js</code> 文件，可以看到，<code>src/index.js</code> 并没有被转义为低版本的代码，这显然不是我们想要的。</p>
<pre><code>{
    &quot;./src/index.js&quot;:
        (function (module, exports) {

            eval(&quot;class Animal {\n    constructor(name) {\n        this.name = name;\n    }\n    getName() {\n        return this.name;\n    }\n}\n\nconst dog = new Animal('dog');\n\n//# sourceURL=webpack:///./src/index.js?&quot;);

        })
}
</code></pre>
<h3>4. 将 JS 转义为低版本</h3>
<p>前面我们说了 <code>webpack</code> 的四个核心概念，其中之一就是 <code>loader</code>，<code>loader</code> 用于对源代码进行转换，这正是我们现在所需要的。
将 JS 代码向低版本转换，我们需要使用 <code>babel-loader</code>。</p>
<p>新建 <code>webpack.config.js</code>，如下:</p>
<pre><code>//webpack.config.js
module.exports = {
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                use: ['babel-loader'],
                exclude: /node_modules/ //排除 node_modules 目录
            }
        ]
    }
}
</code></pre>
<h4>创建一个 .babelrc</h4>
<p>我们可以在 <code>.babelrc</code> 中编写 <code>babel</code> 的配置，也可以在 <code>webpack.config.js</code> 中进行配置。
配置如下：</p>
<pre><code>{
    &quot;presets&quot;: [&quot;@babel/preset-env&quot;],
    &quot;plugins&quot;: [
        [
            &quot;@babel/plugin-transform-runtime&quot;,
            {
                &quot;corejs&quot;: 3
            }
        ]
    ]
}
</code></pre>
<p>现在，我们重新执行 <code>npx webpack --mode=development</code>，查看 <code>dist/main.js</code>，会发现已经被编译成了低版本的 JS 代码。</p>
<h4>在 webpack 中配置 babel</h4>
<pre><code>//webpack.config.js
module.exports = {
    // mode: 'development',
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: [&quot;@babel/preset-env&quot;],
                        plugins: [
                            [
                                &quot;@babel/plugin-transform-runtime&quot;,
                                {
                                    &quot;corejs&quot;: 3
                                }
                            ]
                        ]
                    }
                },
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<p>这里有几点需要说明：</p>
<ul>
<li><code>loader</code> 需要配置在 <code>module.rules</code> 中，<code>rules</code> 是一个数组。</li>
<li><code>loader</code> 的格式为:</li>
</ul>
<pre><code>{
    test: /\.jsx?$/,//匹配规则
    use: 'babel-loader'
}
</code></pre>
<p>或者也可以像下面这样:</p>
<pre><code>//适用于只有一个 loader 的情况
{
    test: /\.jsx?$/,
    loader: 'babel-loader',
    options: {
        //...
    }
}
</code></pre>
<h2><code>use</code> 字段</h2>
<p><code>use</code> 字段有几种写法</p>
<ul>
<li>可以是一个字符串，例如上面的 <code>use: 'babel-loader'</code></li>
<li><code>use</code> 字段可以是一个数组，例如处理 CSS 文件是，<code>use: ['style-loader', 'css-loader']</code></li>
<li><code>use</code> 数组的每一项既可以是字符串也可以是一个对象，当我们需要在<code>webpack</code> 的配置文件中对 <code>loader</code> 进行配置，就需要将其编写为一个对象，并且在此对象的 <code>options</code> 字段中进行配置，如：</li>
</ul>
<pre><code>rules: [
    {
        test: /\.jsx?$/,
        use: {
            loader: 'babel-loader',
            options: {
                presets: [&quot;@babel/preset-env&quot;]
            }
        },
        exclude: /node_modules/
    }
]
</code></pre>
<h3>5.mode</h3>
<p>一直运行的都是 <code>npx webpack --mode=development</code> 是否可以将 <code>mode</code> 配置在 <code>webpack.config.js</code> 中呢？显然是可以的。
将 <code>mode</code> 增加到 <code>webpack.config.js</code> 中:</p>
<pre><code>module.exports = {
    //....
    mode: &quot;development&quot;,
    module: {
        //...
    }
}
</code></pre>
<p><code>mode</code> 配置项，告知 <code>webpack</code> 使用相应模式的内置优化。
<code>mode</code> 配置项，支持以下两个配置:</p>
<ul>
<li><code>development</code>：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>development</code>，启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></li>
<li><code>production</code>：将 <code>process.env.NODE_ENV</code> 的值设置为 <code>production</code>，启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code></li>
</ul>
<p>现在，我们直接使用 <code>npx webpack</code> 进行编译即可。</p>
<h3>6. 在浏览器中查看页面</h3>
<p>查看页面，难免就需要 <code>html</code> 文件，有小伙伴可能知道，有时我们会指定打包文件中带有 <code>hash</code>，那么每次生成的 <code>js</code> 文件名会有所不同，总不能让我们每次都人工去修改 <code>html</code>，这样不是显得我们很蠢嘛~</p>
<p>我们可以使用 <code>html-webpack-plugin</code> 插件来帮助我们完成这些事情。</p>
<p>首先，安装一下插件:</p>
<pre><code>npm install html-webpack-plugin -D
</code></pre>
<p>新建 <code>public</code> 目录，并在其中新建一个 <code>index.html</code> 文件 ( 文件内容使用 <code>html:5</code> 快捷生成即可)</p>
<p>修改 <code>webpack.config.js</code> 文件。</p>
<pre><code>//首先引入插件
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
    //...
    plugins: [
        //数组 放着所有的webpack插件
        new HtmlWebpackPlugin({
            template: './public/index.html',
            filename: 'index.html', //打包后的文件名
            minify: {
                removeAttributeQuotes: false, //是否删除属性的双引号
                collapseWhitespace: false, //是否折叠空白
            },
            // hash: true //是否加上hash，默认是 false
        })
    ]
}
</code></pre>
<p>此时执行 <code>npx webpack</code>，可以看到 <code>dist</code> 目录下新增了 <code>index.html</code> 文件，并且其中自动插入了 <code>&lt;script&gt;</code> 脚本，引入的是我们打包之后的 js 文件。</p>
<p>这里要多说一点点东西，<code>HtmlWebpackPlugin</code> 还为我们提供了一个 <code>config</code> 的配置，这个配置可以说是非常有用了。</p>
<h4>html-webpack-plugin 的 config 的妙用</h4>
<p>有时候，我们的脚手架不仅仅给自己使用，也许还提供给其它业务使用，<code>html</code> 文件的可配置性可能很重要，比如：你公司有专门的部门提供 M 页的公共头部 / 公共尾部，埋点 jssdk 以及分享的 jssdk 等等，但是不是每个业务都需要这些内容。</p>
<p>一个功能可能对应多个 <code>js</code> 或者是 <code>css</code> 文件，如果每次都是业务自行修改 <code>public/index.html</code> 文件，也挺麻烦的。首先他们得搞清楚每个功能需要引入的文件，然后才能对 <code>index.html</code> 进行修改。</p>
<p>此时我们可以增加一个配置文件，业务通过设置 <code>true</code> 或 <code>false</code> 来选出自己需要的功能，我们再根据配置文件的内容，为每个业务生成相应的 <code>html</code> 文件，岂不是美美的。</p>
<p>首先，我们在 <code>public</code> 目录下新增一个 <code>config.js</code> (文件名你喜欢叫什么就叫什么)，将其内容设置为:</p>
<pre><code>//public/config.js 除了以下的配置之外，这里面还可以有许多其他配置，例如,pulicPath 的路径等等
module.exports = {
    dev: {
        template: {
            title: '你好',
            header: false,
            footer: false
        }
    },
    build: {
        template: {
            title: '你好才怪',
            header: true,
            footer: false
        }
    }
}
</code></pre>
<p>现在，我们修改下我们的 <code>webpack.config.js</code>:</p>
<pre><code>//webpack.config.js
const HtmlWebpackPlugin = require('html-webpack-plugin');
const isDev = process.env.NODE_ENV === 'development';
const config = require('./public/config')[isDev ? 'dev' : 'build'];

modue.exports = {
    //...
    mode: isDev ? 'development' : 'production'
    plugins: [
        new HtmlWebpackPlugin({
            template: './public/index.html',
            filename: 'index.html', //打包后的文件名
            config: config.template
        })
    ]
}
</code></pre>
<p>相应的，我们需要修改下我们的 <code>public/index.html</code> 文件 (嵌入的 js 和 css 并不存在，仅作为示意)：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta &gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
    &lt;% if(htmlWebpackPlugin.options.config.header) { %&gt;
    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//common/css/header.css&quot;&gt;
    &lt;% } %&gt;
    &lt;title&gt;&lt;%= (htmlWebpackPlugin.options.config.title) %&gt;&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt; 
&lt;% if(htmlWebpackPlugin.options.config.header) { %&gt;
&lt;script src=&quot;//common/header.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 
&lt;% } %&gt;
&lt;/html&gt;
</code></pre>
<p><code>process.env</code> 中默认并没有 <code>NODE_ENV</code>，这里配置下我们的 <code>package.json</code> 的 <code>scripts</code>.</p>
<p>为了兼容 Windows 和 Mac，我们先安装一下 <code>cross-env</code>:</p>
<pre><code>npm install cross-env -D
</code></pre>
<pre><code>{
    &quot;scripts&quot;: {
        &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack&quot;,
        &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;
    }
}
</code></pre>
<p>然后我们运行 <code>npm run dev</code> 和 运行 <code>npm run build</code> ，对比下 <code>dist/index.html</code> ，可以看到 <code>npm run build</code>，生成的 <code>index.html</code> 文件中引入了对应的 <code>css</code> 和 <code>js</code>。并且对应的 <code>title</code> 内容也不一样。</p>
<p>你说这里是不是非得是用 <code>NODE_ENV</code> 去判断？当然不是咯，你写 <code>aaa=1</code> ，<code>aaa=2</code> 都行（当然啦，<code>webpack.config.js</code> 和 <code>scripts</code> 都需要进行相应修改）</p>
<h4>如何在浏览器中实时展示效果</h4>
<p>说了这么多，到现在还没能在浏览器中实时查看效果，是不是已经有点捉急了，先看一下如何实时查看效果吧，不然都不知道自己配得对不对。
话不多说，先装依赖:</p>
<pre><code>npm install webpack-dev-server -D
</code></pre>
<p>修改下咱们的 <code>package.json</code> 文件的 <code>scripts</code>：</p>
<pre><code>&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server&quot;,
    &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;
},
</code></pre>
<p>在控制台执行 <code>npm run dev</code>，启动正常，页面上啥也没有，修改下我们的 JS 代码，往页面中增加点内容，正常刷新 (也就是说不需要进行任何配置就可以使用了)。
原来在配置了 <code>html-webpack-plugin</code> 的情况下， <code>contentBase</code> 不会起任何作用，也就是说我以前都是白配了，这是一个悲伤的故事。
不过呢，我们还是可以在 <code>webpack.config.js</code> 中进行 <code>webpack-dev-server</code> 的其它配置，例如指定端口号，设置浏览器控制台消息，是否压缩等等:</p>
<pre><code>//webpack.config.js
module.exports = {
    //...
    devServer: {
        port: '3000', //默认是8080
        quiet: false, //默认不启用
        inline: true, //默认开启 inline 模式，如果设置为false,开启 iframe 模式
        stats: &quot;errors-only&quot;, //终端仅打印 error
        overlay: false, //默认不启用
        clientLogLevel: &quot;silent&quot;, //日志等级
        compress: true //是否启用 gzip 压缩
    }
}
</code></pre>
<ul>
<li>启用 <code>quiet</code> 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 <code>webpack</code> 的错误或警告在控制台不可见 ———— 我是不会开启这个的，看不到错误日志，还搞个锤子</li>
<li><code>stats</code>: &quot;errors-only&quot; ， 终端中仅打印出 <code>error</code>，注意当启用了 <code>quiet</code> 或者是 <code>noInfo</code> 时，此属性不起作用。 ————— 这个属性个人觉得很有用，尤其是我们启用了 <code>eslint</code> 或者使用 <code>TS</code>进行开发的时候，太多的编译信息在终端中，会干扰到我们。</li>
<li>启用 <code>overlay</code> 后，当编译出错时，会在浏览器窗口全屏输出错误，默认是关闭的。</li>
<li><code>clientLogLevel</code>: 当使用内联模式时，在浏览器的控制台将显示消息，如：在重新加载之前，在一个错误之前，或者模块热替换启用时。如果你不喜欢看这些信息，可以将其设置为 <code>silent</code> (<code>none</code> 即将被移除)。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee5021f55a7~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<h3>7.devtool</h3>
<p><code>devtool</code> 中的一些设置，可以帮助我们将编译后的代码映射回原始源代码。不同的值会明显影响到构建和重新构建的速度。</p>
<p>对我而言，能够定位到源码的行即可，因此，综合构建速度，在开发模式下，我设置的 <code>devtool</code> 的值是 <code>cheap-module-eval-source-map</code>。</p>
<pre><code>//webpack.config.js
module.exports = {
    devtool: 'cheap-module-eval-source-map' //开发环境下使用
}
</code></pre>
<p>生产环境可以使用 <code>none</code> 或者是 <code>source-map</code>，使用 <code>source-map</code> 最终会单独打包出一个 <code>.map</code> 文件，我们可以根据报错信息和此 <code>map</code> 文件，进行错误解析，定位到源代码。</p>
<p><code>source-map</code> 和 <code>hidden-source-map</code> 都会打包生成单独的 <code>.map</code> 文件，区别在于，<code>source-map</code> 会在打包出的 js 文件中增加一个引用注释，以便开发工具知道在哪里可以找到它。<code>hidden-source-map</code> 则不会在打包的 js 中增加引用注释。</p>
<p>但是我们一般不会直接将 <code>.map</code> 文件部署到 CDN，因为会直接映射到源码，更希望将<code>.map</code> 文件传到错误解析系统，然后根据上报的错误信息，直接解析到出错的源码位置。</p>
<p>还可以设置其他的 <a href="https://link.juejin.cn?target=http%3A%2F%2Fwebpack.html.cn%2Fconfiguration%2Fdevtool.html" title="http://webpack.html.cn/configuration/devtool.html">devtool 值</a>，你可以使用不同的值，构建对比差异。</p>
<p>现在我们已经说了 <code>html</code>、<code>js</code> 了，并且也可以在浏览器中实时看到效果了，现在就不得不说页面开发三巨头之一的 <code>css</code> 。</p>
<h3>8. 如何处理样式文件呢</h3>
<p><code>webpack</code> 不能直接处理 <code>css</code>，需要借助 <code>loader</code>。如果是 <code>.css</code>，我们需要的 <code>loader</code> 通常有： <code>style-loader</code>、<code>css-loader</code>，考虑到兼容性问题，还需要 <code>postcss-loader</code>，而如果是 <code>less</code> 或者是 <code>sass</code> 的话，还需要 <code>less-loader</code> 和 <code>sass-loader</code>，这里配置一下 <code>less</code> 和 <code>css</code> 文件 (<code>sass</code> 的话，使用 <code>sass-loader</code>即可):</p>
<p>先安装一下需要使用的依赖:</p>
<pre><code>npm install style-loader less-loader css-loader postcss-loader autoprefixer less -D
</code></pre>
<pre><code>//webpack.config.js
module.exports = {
    //...
    module: {
        rules: [
            {
                test: /\.(le|c)ss$/,
                use: ['style-loader', 'css-loader', {
                    loader: 'postcss-loader',
                    options: {
                        plugins: function () {
                            return [
                                require('autoprefixer')({
                                    &quot;overrideBrowserslist&quot;: [
                                        &quot;&gt;0.25%&quot;,
                                        &quot;not dead&quot;
                                    ]
                                })
                            ]
                        }
                    }
                }, 'less-loader'],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<p>测试一下，新建一个 <code>less</code> 文件，<code>src/index.less</code>:</p>
<pre><code>//src/index.less
@color: red;
body{
    background: @color;
    transition: all 2s;
}
</code></pre>
<p>再在入口文件中引入此 <code>less</code>:</p>
<pre><code>//src/index.js
import './index.less';
</code></pre>
<p>我们修改了配置文件，重新启动一下服务: <code>npm run dev</code>。可以看到页面的背景色变成了红色。</p>
<p>OK，我们简单说一下上面的配置：</p>
<ul>
<li><code>style-loader</code> 动态创建 <code>style</code> 标签，将 <code>css</code> 插入到 <code>head</code> 中.</li>
<li><code>css-loader</code> 负责处理 <code>@import</code> 等语句。</li>
<li><code>postcss-loader</code> 和 <code>autoprefixer</code>，自动生成浏览器兼容性前缀 —— 2020 了，应该没人去自己徒手去写浏览器前缀了吧</li>
<li><code>less-loader</code> 负责处理编译 <code>.less</code> 文件, 将其转为 <code>css</code></li>
</ul>
<p>这里，我们之间在 <code>webpack.config.js</code> 写了 <code>autoprefixer</code> 需要兼容的浏览器，仅是为了方便展示。推荐大家在根目录下创建 <code>.browserslistrc</code>，将对应的规则写在此文件中，除了 <code>autoprefixer</code> 使用外，<code>@babel/preset-env</code>、<code>stylelint</code>、<code>eslint-plugin-conmpat</code> 等都可以共用。</p>
<p><strong>注意：</strong></p>
<p><code>loader</code> 的执行顺序是从右向左执行的，也就是后面的 <code>loader</code> 先执行，上面 <code>loader</code> 的执行顺序为: <code>less-loader</code> ---&gt; <code>postcss-loader</code> ---&gt; <code>css-loader</code> ---&gt; <code>style-loader</code></p>
<p>当然，<code>loader</code> 其实还有一个参数，可以修改优先级，<code>enforce</code> 参数，其值可以为: <code>pre</code>(优先执行) 或 <code>post</code> (滞后执行)。</p>
<p>现在，我们已经可以处理 <code>.less</code> 文件啦，<code>.css</code> 文件只需要修改匹配规则，删除 <code>less-loader</code> 即可。</p>
<p>现在的一切看起来都很完美，但是假设我们的文件中使用了本地的图片，例如:</p>
<pre><code>body{
    background: url('../images/thor.png');
}
</code></pre>
<p>你就会发现，报错啦啦啦，那么我们要怎么处理图片或是本地的一些其它资源文件呢。不用想，肯定又需要 <code>loader</code> 出马了。</p>
<h3>9. 图片 / 字体文件处理</h3>
<p>我们可以使用 <code>url-loader</code> 或者 <code>file-loader</code> 来处理本地的资源文件。<code>url-loader</code> 和 <code>file-loader</code> 的功能类似，但是 <code>url-loader</code> 可以指定在文件大小小于指定的限制时，返回 <code>DataURL</code>，因此，个人会优先选择使用 <code>url-loader</code>。</p>
<p>首先安装依赖:</p>
<pre><code>npm install url-loader -D
</code></pre>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee506dad2eb~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>安装 <code>url-loader</code> 的时候，控制台会提示你，还需要安装下 <code>file-loader</code>，听人家的话安装下就行 (新版 <code>npm</code> 不会自动安装 <code>peerDependencies</code>)：</p>
<pre><code>npm install file-loader -D
</code></pre>
<p>在 <code>webpack.config.js</code> 中进行配置：</p>
<pre><code>//webpack.config.js
module.exports = {
    //...
    modules: {
        rules: [
            {
                test: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 10240, //10K
                            esModule: false 
                        }
                    }
                ],
                exclude: /node_modules/
            }
        ]
    }
}
</code></pre>
<p>此处设置 <code>limit</code> 的值大小为 10240，即资源大小小于 <code>10K</code> 时，将资源转换为 <code>base64</code>，超过 10K，将图片拷贝到 <code>dist</code> 目录。<code>esModule</code> 设置为 <code>false</code>，否则，<code>&lt;img src={require('XXX.jpg')} /&gt;</code> 会出现 <code>&lt;img src=[Module Object] /&gt;</code></p>
<p>将资源转换为 <code>base64</code> 可以减少网络请求次数，但是 <code>base64</code> 数据较大，如果太多的资源是 <code>base64</code>，会导致加载变慢，因此设置 <code>limit</code> 值时，需要二者兼顾。</p>
<p>默认情况下，生成的文件的文件名就是文件内容的 <code>MD5</code> 哈希值并会保留所引用资源的原始扩展名，例如我上面的图片 (thor.jpeg) 对应的文件名如下：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee50ad69750~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>当然，你也可以通过 <code>options</code> 参数进行修改。</p>
<pre><code>//....
use: [
    {
        loader: 'url-loader',
        options: {
            limit: 10240, //10K
            esModule: false,
            name: '[name]_[hash:6].[ext]'
        }
    }
]
</code></pre>
<p>重新编译，在浏览器中审查元素，可以看到图片名变成了: <code>thor_a5f7c0.jpeg</code>。</p>
<p>当本地资源较多时，我们有时会希望它们能打包在一个文件夹下，这也很简单，我们只需要在 <code>url-loader</code> 的 <code>options</code> 中指定 <code>outpath</code>，如: <code>outputPath: 'assets'</code>，构建出的目录如下:</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee50d59a0cf~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>更多的 <code>url-loader</code> 配置可以<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.webpackjs.com%2Floaders%2Furl-loader%2F" title="https://www.webpackjs.com/loaders/url-loader/">查看</a></p>
<p>到了这里，有点<strong>岁月静好</strong>的感觉了。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee545e78629~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>不过还没完，如果你在 <code>public/index.html</code> 文件中，使用本地的图片，例如，我们修改一下 <code>public/index.html</code>：</p>
<pre><code>&lt;img src=&quot;./a.jpg&quot; /&gt;
</code></pre>
<p>重启本地服务，虽然，控制台不会报错，但是你会发现，浏览器中根本加载不出这张图片，Why？因为构建之后，通过相对路径压根找不着这张图片呀。</p>
<p>How？怎么解决呢？</p>
<h3>10. 处理 html 中的本地图片</h3>
<p>安装 <code>html-withimg-loader</code> 来解决咯。</p>
<pre><code>npm install html-withimg-loader -D
</code></pre>
<p>修改 <code>webpack.config.js</code>：</p>
<pre><code>module.exports = {
    //...
    module: {
        rules: [
            {
                test: /.html$/,
                use: 'html-withimg-loader'
            }
        ]
    }
}
</code></pre>
<p>然后在我们的 <code>html</code> 中引入一张文件测试一下（图片地址自己写咯，这里只是示意）:</p>
<pre><code>&lt;!-- index.html --&gt;
&lt;img src=&quot;./thor.jpeg&quot; /&gt;
</code></pre>
<p>重启本地服务，图片并没能加载，审查元素的话，会发现图片的地址显示的是 <code>{&quot;default&quot;:&quot;assets/thor_a5f7c0.jpeg&quot;}</code>。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/2/17098ee552daf18d~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png" alt=""></p>
<p>我当前 <code>file-loader</code> 的版本是 5.0.2，5 版本之后，需要增加 <code>esModule</code> 属性：</p>
<pre><code>//webpack.config.js
module.exports = {
    //...
    modules: {
        rules: [
            {
                test: /\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 10240, //10K
                            esModule: false
                        }
                    }
                ]
            }
        ]
    }
}
</code></pre>
<p>再重启本地服务，就搞定啦。</p>
<p>话说使用 <code>html-withimg-loader</code> 处理图片之后，<code>html</code> 中就不能使用 <code>vm</code>, <code>ejs</code> 的模板了，如果想继续在 <code>html</code> 中使用 <code>&lt;% if(htmlWebpackPlugin.options.config.header) { %&gt;</code> 这样的语法，但是呢，又希望能使用本地图片，可不可以？鱼和熊掌都想要，虽然很多时候，能吃个鱼就不错了，但是这里是可以的哦，像下面这样编写图片的地址，并且删除<code>html-withimg-loader</code>的配置即可。</p>
<pre><code>&lt;!-- index.html --&gt;
&lt;img src=&quot;&lt;%= require('./thor.jpeg') %&gt;&quot; /&gt;
</code></pre>
<p>图片加载 OK 啦，并且 <code>&lt;% %&gt;</code> 语法也可以正常使用，吼吼吼~~~</p>
<p>虽然，<code>webpack</code> 的默认配置很好用，但是有的时候，我们会有一些其它需要啦，例如，我们不止一个入口文件，这时候，该怎么办呢？</p>
<h3>11. 入口配置</h3>
<p>入口的字段为: <code>entry</code></p>
<pre><code>//webpack.config.js
module.exports = {
    entry: './src/index.js' //webpack的默认配置
}
</code></pre>
<p><code>entry</code> 的值可以是一个字符串，一个数组或是一个对象。</p>
<p>字符串的情况无需多说，就是以对应的文件为入口。</p>
<p>为数组时，表示有 “多个主入口”，想要多个依赖文件一起注入时，会这样配置。例如:</p>
<pre><code>entry: [
    './src/polyfills.js',
    './src/index.js'
]
</code></pre>
<p><code>polyfills.js</code> 文件中可能只是简单的引入了一些 <code>polyfill</code>，例如 <code>babel-polyfill</code>，<code>whatwg-fetch</code> 等，需要在最前面被引入（我在 webpack2 时这样配置过）。</p>
<p>那什么时候是对象呢？不要捉急，后面将多页配置的时候，会说到。</p>
<h3>12. 出口配置</h3>
<p>配置 <code>output</code> 选项可以控制 <code>webpack</code> 如何输出编译文件。</p>
<pre><code>const path = require('path');
module.exports = {
    entry: './src/index.js',
    output: {
        path: path.resolve(__dirname, 'dist'), //必须是绝对路径
        filename: 'bundle.js',
        publicPath: '/' //通常是CDN地址
    }
}
</code></pre>
<p>例如，你最终编译出来的代码部署在 CDN 上，资源的地址为: '<a href="https://link.juejin.cn?target=https%3A%2F%2FAAA%2FBBB%2FYourProject%2FXXX" title="https://AAA/BBB/YourProject/XXX">https://AAA/BBB/YourProject/XXX</a>'，那么可以将生产的 <code>publicPath</code> 配置为: <code>//AAA/BBB/</code>。</p>
<p>编译时，可以不配置，或者配置为 <code>/</code>。可以在我们之前提及的 <code>config.js</code> 中指定 <code>publicPath</code>（<code>config.js</code> 中区分了 <code>dev</code> 和 <code>public</code>）， 当然还可以区分不同的环境指定配置文件来设置，或者是根据 <code>isDev</code> 字段来设置。</p>
<p>除此之外呢，考虑到 CDN 缓存的问题，我们一般会给文件名加上 <code>hash</code>.</p>
<pre><code>//webpack.config.js
module.exports = {
    output: {
        path: path.resolve(__dirname, 'dist'), //必须是绝对路径
        filename: 'bundle.[hash].js',
        publicPath: '/' //通常是CDN地址
    }
}
</code></pre>
<p>如果你觉得 <code>hash</code> 串太长的话，还可以指定长度，例如 <code>bundle.[hash:6].js</code>。使用 <code>npm run build</code> 打包看看吧。</p>
<p>问题出现啦，每次文件修改后，重新打包，导致 <code>dist</code> 目录下的文件越来越多。要是每次打包前，都先清空一下目录就好啦。可不可以做到呢？必须可以！</p>
<h3>13. 每次打包前清空 dist 目录</h3>
<p>反正我是懒得手动去清理的，只要你足够懒，你总是会找到好办法的，懒人推动科技进步。这里，我们需要插件: <code>clean-webpack-plugin</code></p>
<p>安装依赖:</p>
<pre><code>npm install clean-webpack-plugin -D
</code></pre>
<p>以前，<code>clean-webpack-plugin</code> 是默认导出的，现在不是，所以引用的时候，需要注意一下。另外，现在构造函数接受的参数是一个对象，可缺省。</p>
<pre><code>//webpack.config.js
const { CleanWebpackPlugin } = require('clean-webpack-plugin');

module.exports = {
    //...
    plugins: [
        //不需要传参数喔，它可以找到 outputPath
        new CleanWebpackPlugin() 
    ]
}
</code></pre>
<p>现在你再修改文件，重现构建，生成的 hash 值和之前 dist 中的不一样，但是因为每次 <code>clean-webpack-plugin</code> 都会帮我们先清空一波 <code>dist</code> 目录，所以不会出现太多文件，傻傻分不清楚究竟哪个是新生成文件的情况。</p>
<h4>希望 dist 目录下某个文件夹不被清空</h4>
<p>不过呢，有些时候，我们并不希望整个 <code>dist</code> 目录都被清空，比如，我们不希望，每次打包的时候，都删除 <code>dll</code> 目录，以及 <code>dll</code> 目录下的文件或子目录，该怎么办呢？</p>
<p><code>clean-webpack-plugin</code> 为我们提供了参数 <code>cleanOnceBeforeBuildPatterns</code>。</p>
<pre><code>//webpack.config.js
module.exports = {
    //...
    plugins: [
        new CleanWebpackPlugin({
            cleanOnceBeforeBuildPatterns:['**/*', '!dll', '!dll/**'] //不删除dll目录下的文件
        })
    ]
}
</code></pre>
<p>此外，<code>clean-webpack-plugin</code> 还有一些其它的配置，不过我使用的不多，大家可以查看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjohnagan%2Fclean-webpack-plugin" title="https://github.com/johnagan/clean-webpack-plugin">clean-webpack-plugin</a></p>
<p>至此，我们算是完成了一个基础配置。但是这不够完美，或者说有些时候，我们还会有一些其它的需求。下一篇关于<code>webpack</code>配置的文章会介绍一些其它的情况。</p>

<h1>探秘神奇的 IntersectionObserver：释放网页性能的黑科技！</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7247045258842996794?searchId=202402012325316CE94CF6E1922963D4F6">juejin.cn</a></p>
</blockquote>
<h1>引言</h1>
<p>介绍 <code>IntersectionObserver</code> 在应用场景多达 <strong>10</strong> 个：
*   图片懒加载
*   无限滚动加载
*   广告展示控制
*   有效曝光埋点
*   用户兴趣埋点
*   可视区域内外动画 / 视频暂停（腾讯视频列表效果）
*   视差效果与动画
*   标题和导航联动
*   虚拟列表优化
*   消息已读状态标记（各聊天软件）
3.  <strong>哪些坑</strong>：介绍 <code>IntersectionObserver</code> 怎么<strong>测试</strong>和<strong>调试</strong>以及一些<strong>限制</strong></p>
<h1>IntersectionObserver 的概述</h1>
<h2>1.1 起源</h2>
<p>在现代网页开发中，动态加载和按需展示内容已成为提升用户体验和网页性能的重要手段。传统的方法通常依赖于滚动事件或定时器来监测元素与视窗的交叉状态，但这些方法效率低下且容易导致性能问题。为了解决这个问题，<code>W3C</code> 于 2016 年引入了 <code>IntersectionObserver API</code>。</p>
<h2>1.3 IntersectionObserver 的特性</h2>
<ul>
<li><strong>异步执行</strong>：<code>IntersectionObserver</code> 是异步执行的，它使用浏览器的内部优化机制，不会阻塞主线程，从而避免了性能问题。</li>
<li><strong>节省资源</strong>：相比于传统的滚动事件或定时器，<code>IntersectionObserver</code> 可以精确地观察元素与视窗的交叉状态，避免了不必要的计算和回调触发，从而节省了资源的消耗。</li>
<li><strong>多目标观察</strong>：<code>IntersectionObserver</code> 可以同时观察多个目标元素，通过回调函数逐个通知开发者它们的交叉状态，方便进行批量操作。</li>
<li><strong>自定义阈值</strong>：开发者可以设定一个或多个阈值，用来定义元素与视窗的交叉比例。当交叉比例超过或低于阈值时，会触发相应的回调函数。</li>
</ul>
<p>通过使用 <code>IntersectionObserver</code>，开发者可以实现一些常见的功能，如图片懒加载、无限滚动加载、广告展示控制等，以提升网页的性能和用户体验。</p>
<h1>3 IntersectionObserver 的工作原理</h1>
<p><code>IntersectionObserver</code> 的工作原理涉及到观察目标元素、目标元素与视窗的交叉区域、回调函数和阈值等方面。<code>MDN</code> 官方介绍请<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FIntersection_Observer_API" title="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API">移步</a></p>
<h2>3.1 观察目标元素</h2>
<p><code>IntersectionObserver</code> 首先需要指定要观察的目标元素。这可以通过创建一个 <code>IntersectionObserver</code> 实例，并传入一个回调函数来实现。回调函数会在目标元素的交叉状态发生变化时被调用。</p>
<h2>3.2 目标元素与视窗的交叉区域</h2>
<p><code>IntersectionObserver</code> 会根据目标元素与视窗的交叉区域来确定它们的交叉状态。交叉区域可以分为以下几种情况：</p>
<ul>
<li><strong>进入视窗</strong>：当目标元素的一部分进入视窗时，被称为进入视窗。</li>
<li><strong>完全进入视窗</strong>：当目标元素完全进入视窗时，被称为完全进入视窗。</li>
<li><strong>离开视窗</strong>：当目标元素完全离开视窗时，被称为离开视窗。</li>
<li><strong>部分离开视窗</strong>：当目标元素的一部分离开视窗时，被称为部分离开视窗。</li>
</ul>
<p><code>IntersectionObserver</code> 可以精确地计算目标元素与视窗的交叉区域，并根据交叉区域的变化来确定它们的交叉状态。</p>
<h2>3.3 回调函数和阈值</h2>
<p>当目标元素的交叉状态发生变化时，注册的回调函数将被触发。开发者可以在回调函数中定义相应的操作，如加载或显示元素。</p>
<p>此外，<code>IntersectionObserver</code> 还支持自定义阈值。阈值是一个介于 <code>0.0</code> 和 <code>1.0</code> 之间的值，用来定义目标元素与视窗的交叉比例。当交叉比例超过或低于设定的阈值时，会触发回调函数。</p>
<h2>3.4 IntersectionObserver 的运行机制</h2>
<p><code>IntersectionObserver</code> 在内部采用了一些高效的运行机制来实现元素交叉状态的观察和回调触发。下面更详细地介绍下 <code>IntersectionObserver</code> 的运行机制。</p>
<ol>
<li>
<p><strong>惰性计算</strong><br>
为了避免性能问题和不必要的计算，<code>IntersectionObserver</code> 采用了惰性计算的策略。它并不实时地计算目标元素与视窗的交叉状态，而是在特定时机进行计算。<br>
当一个目标元素进入或离开视窗的边界区域时，浏览器会通知 <code>IntersectionObserver</code> 进行交叉状态的计算。这样可以避免对所有元素进行持续的计算，从而节省了资源并提高了性能。</p>
</li>
<li>
<p><strong>队列处理</strong><br>
为了保证运行的平滑性，<code>IntersectionObserver</code> 使用了队列处理的机制。当目标元素的交叉状态发生变化时，会将变化的目标元素放入一个队列中。<br>
<code>IntersectionObserver</code> 会在下一个动画帧或微任务中处理队列中的元素。这种延迟处理的方式可以避免在一帧内频繁触发大量回调函数，从而提供更流畅的用户体验。</p>
</li>
<li>
<p><strong>优化算法</strong><br>
为了提高性能和减少回调触发的次数，<code>IntersectionObserver</code> 使用了一些优化算法。它会将目标元素进行分组，并按照它们在文档中的顺序进行观察。<br>
当观察到交叉状态变化时，<code>IntersectionObserver</code> 会将变化的目标元素放入队列中，并按照它们在文档中的顺序进行处理。这样可以确保回调函数的触发顺序与元素在文档中的顺序一致，避免出现混乱或错误的情况。</p>
</li>
</ol>
<p>通过采用惰性计算、队列处理和优化算法，<code>IntersectionObserver</code> 实现了高效而平滑的元素交叉状态观察和回调触发，为开发者提供了一种优雅且性能优化的解决方案。</p>
<h1>4 IntersectionObserver 的应用场景</h1>
<h2>4.1 图片懒加载</h2>
<p>图片懒加载是 <code>IntersectionObserver</code> 在网页开发中常见的应用场景之一。传统情况下，网页加载时所有的图片都会同时加载，无论它们是否在视窗中可见。这会导致不必要的网络请求和资源浪费。<br>
通过使用 <code>IntersectionObserver</code>，可以延迟加载图片，只在它们进入视窗时才开始加载。这样可以减少初始页面加载时间，并节省带宽和资源。<br>
实现图片懒加载的步骤如下：</p>
<ol>
<li>创建 <code>IntersectionObserver</code> 实例，并指定观察的目标元素。</li>
<li>在回调函数中，判断目标元素是否进入视窗。</li>
<li>若目标元素进入视窗，将其真实的图片地址赋给元素的 <code>src</code> 属性，触发图片加载。</li>
</ol>
<p>示例代码如下：</p>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src; // 将真实的图片地址赋给 src 属性
      observer.unobserve(img); // 停止观察该图片
    }
  });
});

const lazyImages = document.querySelectorAll('.lazy-image');
lazyImages.forEach((img) =&gt; {
  observer.observe(img); // 开始观察每个图片元素
});
</code></pre>
<p>通过使用 <code>IntersectionObserver</code> 实现图片懒加载，可以显著提升页面加载性能，尤其在包含大量图片的页面中效果更为明显。</p>
<h2>4.2 无限滚动加载</h2>
<p>无限滚动加载是 <code>IntersectionObserver</code> 另一个常见的应用场景，特别适用于需要展示大量数据的页面，如社交媒体流、新闻列表等。<br>
传统的无限滚动加载通常基于滚动事件来触发数据加载，但这种方式在性能和用户体验上存在一些问题。而使用 <code>IntersectionObserver</code> 可以更高效地实现无限滚动加载。<br>
实现无限滚动加载的步骤如下：</p>
<ol>
<li>创建 <code>IntersectionObserver</code> 实例，并指定观察的目标元素，通常是页面底部的加载指示器或占位符元素。</li>
<li>在回调函数中，判断目标元素是否进入视窗。</li>
<li>若目标元素进入视窗，触发数据加载的操作，并更新页面内容。</li>
</ol>
<p>示例代码如下：</p>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting) {
      loadMoreData(); // 触发数据加载操作
    }
  });
});

const loader = document.querySelector('.loader');
observer.observe(loader); // 开始观察加载指示器元素
</code></pre>
<p>通过使用 <code>IntersectionObserver</code> 实现无限滚动加载，可以提供更平滑和快速的加载体验。它避免了频繁的滚动事件触发，只在需要加载更多数据时才进行相应操作，减少了无效的请求和资源消耗。</p>
<p>vue 组件代码示例：</p>
<pre><code>&lt;template&gt;
  &lt;div
    class=&quot;load-more-sentinel&quot;
    v-show=&quot;sentinelEnabled&quot;
    ref=&quot;loadMoreSentinel&quot;
  &gt;
    &lt;div v-show=&quot;showLoading&quot; class=&quot;load-more&quot;&gt;
      &lt;slot&gt;
        &lt;span v-for=&quot;i in 5&quot; :style=&quot;`--order:${i}`&quot; :key=&quot;`circle${i}`&quot;&gt;&lt;/span&gt;
      &lt;/slot&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import debounce from 'lodash/debounce';

export default {
  name: 'load-more',
  props: {
    sentinelEnabled: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      showLoading: false,
    };
  },
  watch: {
    sentinelEnabled: {
      handler() {
        // 因为浏览器渲染机制会在微任务执行之后执行渲染线程，之后执行宏任务，所以 setTimeout 可以保证dom已经更新
        if (!this.observer &amp;&amp; this.$refs.loadMoreSentinel) {
          this.timer = setTimeout(() =&gt; {
            const node = this.$refs.loadMoreSentinel;
            if (node) {
              const options = {
                threshold: [0],
              };
              this.observer = new IntersectionObserver(
                debounce(this.insideViewportCb, 50),
                options
              );
              this.observer.observe(node);
            }
          }, 20);
        }
      },
      immediate: true,
    },
  },
  created() {
    this.observer = null;
    this.timer = null;
  },
  destroyed() {
    if (this.observer) this.observer.disconnect();
    if (this.timer) = clearTimeout(this.timer);
  },
  methods: {
    insideViewportCb([entry]) {
      if (this.sentinelEnabled &amp;&amp; entry &amp;&amp; entry.isIntersecting) {
        this.showLoading = true;
        this.$emit('load-more');
      }
    },
    finish() {
      this.showLoading = false;
    },
  },
};
&lt;/script&gt;
</code></pre>
<h2>4.3 广告展示控制</h2>
<p><code>IntersectionObserver</code> 在广告展示控制方面也有应用。传统的做法是通过滚动事件或定时器来检测广告元素是否在视窗中，并根据条件来显示或隐藏广告。<br>
使用 <code>IntersectionObserver</code> 可以更精确地控制广告的展示。通过观察广告元素与视窗的交叉状态，可以实现以下功能：</p>
<ol>
<li>延迟加载广告：只有当广告元素进入视窗时才开始加载广告内容，从而减少不必要的请求和资源消耗。</li>
<li>动态展示广告：可以根据广告元素与视窗的交叉比例来决定广告的展示方式。例如，可以在广告元素完全进入视窗后才显示广告，或者在广告元素的一部分进入视窗时展示部分广告内容。</li>
<li>预加载广告：可以在广告元素进入视窗之前提前加载广告内容，以减少展示广告的延迟时间。
示例代码如下：</li>
</ol>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting) {
      showAd(entry.target); // 显示广告
      observer.unobserve(entry.target); // 停止观察该广告元素
    } else {
      hideAd(entry.target); // 隐藏广告
    }
  });
});

const ads = document.querySelectorAll('.ad');
ads.forEach((ad) =&gt; {
  observer.observe(ad); // 开始观察每个广告元素
});
</code></pre>
<p>通过使用 <code>IntersectionObserver</code> 来控制广告的展示，可以提高广告的可视性和用户体验。只有在广告元素真正进入视窗时才展示广告，避免了不必要的展示和资源浪费。</p>
<h2>4.4 有效曝光埋点</h2>
<p>有效曝光埋点是 <code>IntersectionObserver</code> 的另一个重要应用场景。在网页或应用中，我们常常需要追踪用户对某些元素的曝光情况，以便进行数据分析、广告计费和用户行为研究等，但如何识别曝光为<strong>有效</strong>的，也就是真实的出现在视口范围内，是一个难点。<br>
<code>IntersectionObserver</code> 提供了一个可靠且高效的方式来实现有效曝光埋点。通过观察目标元素与视窗的交叉状态，可以确定元素是否在视窗中完全或部分可见，从而进行曝光统计。</p>
<p>实现有效曝光埋点的步骤如下：</p>
<ol>
<li>创建 <code>IntersectionObserver</code> 实例，并指定观察的目标元素。</li>
<li>在回调函数中，根据目标元素的交叉状态判断是否曝光。</li>
<li>根据业务需求，记录曝光数据或触发相应的操作。</li>
</ol>
<p>示例代码如下：</p>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting) {
      trackExposure(entry.target); // 记录曝光数据或触发相应操作
      observer.unobserve(entry.target); // 停止观察该目标元素
    }
  });
});

const elements = document.querySelectorAll('.exposure-element');
elements.forEach((element) =&gt; {
  observer.observe(element); // 开始观察每个目标元素
});
</code></pre>
<p>通过使用 <code>IntersectionObserver</code> 进行有效曝光埋点，可以准确地追踪用户对指定元素的曝光情况，而无需依赖滚动事件或定时器。这样可以提供更准确的数据分析和用户行为洞察。</p>
<h2>4.5 用户兴趣埋点</h2>
<p>用户兴趣埋点是一个类似有效曝光埋点的功能。通过观察用户与特定元素的交叉状态，可以获取用户对该元素的兴趣程度，从而进行个性化推荐、内容优化和用户行为分析等。 注意：兴趣埋点规则是一种定义用户对特定元素兴趣的规则。在本文中，规则是当某元素在视口停留时间达到 2 秒以上时，被认为用户对该元素感兴趣。 实现该规则的步骤如下：</p>
<ol>
<li>创建 <code>IntersectionObserver</code> 实例，并指定观察的目标元素。</li>
<li>在回调函数中，根据目标元素的交叉状态判断用户对该元素的兴趣。</li>
<li>根据规则判断适口停留时间是否满足条件。</li>
<li>如果满足条件，则记录兴趣数据或触发相应操作。 示例代码如下：</li>
</ol>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting &amp;&amp;
        entry.intersectionRatio &gt;= 0.5 &amp;&amp;
        entry.intersectionRect.width &gt;= entry.boundingClientRect.width * 0.5 &amp;&amp;
        entry.intersectionRect.height &gt;= entry.boundingClientRect.height * 0.5 &amp;&amp;
        entry.time &gt;= 2000
      ) {
      trackInterest(entry.target); // 记录兴趣数据或触发相应操作
    }
  });
});

const elements = document.querySelectorAll('.interest-element');
elements.forEach((element) =&gt; {
  observer.observe(element); // 开始观察每个目标元素
});
</code></pre>
<p>在上述示例中，除了判断目标元素是否交叉以外，还添加了其他条件来确保兴趣的准确性。例如，使用 <code>intersectionRatio</code> 判断元素的可见比例是否超过一定阈值，使用 <code>intersectionRect</code> 和 <code>boundingClientRect</code> 比较元素的交叉区域与元素自身的尺寸，确保元素的大部分内容都在视口中可见。<br>
通过将适口停留时间（<code>entry.time</code>）与 2 秒进行比较，可以判断用户对元素的兴趣是否达到规定的时间阈值。</p>
<p>充分利用 <code>IntersectionObserver</code>，开发者可以更好地了解用户的需求和行为，提供更有针对性的用户体验和增值服务。用户兴趣埋点为产品优化和业务决策提供了重要的数据，可以更精确地了解用户的兴趣和行为模式，从而提供更个性化和有价值的用户体验。</p>
<blockquote>
<p>ps: 具体的兴趣埋点规则可能因业务需求而异，以上示例仅提供了一种可能的实现方式。在实际应用中，可以根据业务需求和用户行为模式进行相应调整和定制化。</p>
</blockquote>
<h2>4.6 可视区域内外动画 / 视频暂停（腾讯视频 app 列表效果）</h2>
<p>可视区域内外视频暂停也可以用 <code>IntersectionObserver</code> 实现。通过观察视频元素与视窗的交叉状态，可以控制视频的播放和暂停，以提升用户体验和优化资源消耗。</p>
<p>具体应用场景包括：</p>
<ol>
<li>自动播放与暂停：当视频元素完全进入视窗时，自动播放视频；当视频元素完全离开视窗时，暂停视频的播放。这样可以确保只有在用户可见的范围内才播放视频，避免不必要的资源浪费和带宽消耗。</li>
<li>音频控制：当视频元素进入视窗时，开始播放视频的音频；当视频元素完全离开视窗时，暂停视频的音频。这样可以确保只有在用户可见的范围内才播放视频的声音，避免用户同时播放多个视频的声音干扰。</li>
<li>视频列表优化：当网页中包含多个视频列表时，只有在用户滚动或浏览到特定视频时才播放该视频，其他视频则保持暂停状态。这样可以减少同时加载和播放多个视频对带宽和性能的压力，提升页面加载速度和用户体验。</li>
<li>节省用户流量：当用户在移动设备上浏览网页时，可以通过 <code>IntersectionObserver</code> 监测视频元素与视窗的交叉状态，仅当视频元素进入视窗时才加载和播放视频。这样可以避免不必要的流量消耗，节省用户的数据流量。</li>
</ol>
<p>示例代码如下：</p>
<pre><code>const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    const video = entry.target;
    if (entry.isIntersecting) {
      video.play(); // 播放视频
    } else {
      video.pause(); // 暂停视频
    }
  });
});

const videos = document.querySelectorAll('video');
videos.forEach((video) =&gt; {
  observer.observe(video); // 开始观察每个视频元素
});
</code></pre>
<p>通过使用 <code>IntersectionObserver</code> 控制视频的播放和暂停，可以优化用户体验、减少资源消耗，提升页面性能和加载速度。</p>
<blockquote>
<p>具体的应用场景和交互方式可能因实际需求而异。开发者可以根据自己的业务需求和用户体验目标，合理运用 <code>IntersectionObserver</code> 来实现可视区域内外视频的暂停和播放控制。</p>
</blockquote>
<h2>4.7 视差效果与动画</h2>
<p>视差效果与动画也可以通过 <code>IntersectionObserver</code> 实现精准的控制。通过观察元素与视窗的交叉状态，可以触发或控制视差效果和动画，为网页或应用添加更丰富的交互和视觉效果。</p>
<p>以下是视差效果和动画的一些具体应用场景：</p>
<ol>
<li>滚动视差效果：当网页中的元素与视窗交叉时，根据滚动的位置和速度，以不同的速率和方向来移动元素，创造出立体感和深度感。例如，背景图片或图层随滚动动态移动，给用户带来视觉上的差异感和沉浸感。</li>
<li>动态加载和过渡效果：当元素进入视窗时，根据预定义的动画效果或过渡效果，使元素以流畅和吸引人的方式进入页面。例如，图片或文本逐渐渐显现，元素从一种状态平滑过渡到另一种状态，为用户提供更优雅的页面加载和内容展示。</li>
<li>触发动画效果：当特定元素进入视窗时，通过 <code>IntersectionObserver</code> 触发相应的动画效果，增加用户与页面的互动性。例如，当用户滚动到某个区域时，元素以动画形式弹出、旋转、渐变等，吸引用户的注意力和参与度。</li>
<li>动态内容加载：当用户滚动到页面底部或特定区域时，通过 <code>IntersectionObserver</code> 触发动态加载更多的内容。这种技术常用于实现无限滚动列表或延迟加载，提供流畅的用户体验，避免一次性加载大量内容带来的性能问题。</li>
<li>页面交互控制：通过观察元素与视窗的交叉状态，根据需要触发特定的交互控制。例如，当特定元素完全进入视窗时，启用按钮、链接或其他交互元素；当元素完全离开视窗时，禁用或隐藏相关元素。</li>
</ol>
<h2>4.8 标题和导航联动</h2>
<p>标题和导航联动是 <code>IntersectionObserver</code> 的一种常见应用场景，通过观察元素与视窗的交叉状态，实现标题与导航之间的联动效果，提升用户导航的便利性和可视性。<br>
此场景<strong>张鑫旭</strong>大佬已经有一篇非常详细的文章，这里不做过多介绍，请<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.zhangxinxu.com%2Fwordpress%2F2020%2F12%2Fjs-intersectionobserver-nav%2F" title="https://www.zhangxinxu.com/wordpress/2020/12/js-intersectionobserver-nav/">移步</a></p>
<h2>4.9 虚拟列表优化</h2>
<p>虚拟列表中的滚动是一个重要的性能考量因素。传统的滚动监听需要在滚动事件中实时计算列表项的位置，并判断其可见性。而使用 <code>IntersectionObserver</code>，可以将交叉状态的监测交给浏览器进行异步处理，避免了频繁的计算操作，从而提高了滚动的流畅性和性能。</p>
<h2>4.10 消息已读状态标记</h2>
<p>在消息已读状态场景中，<code>IntersectionObserver</code> 可以被用于实现即时的状态追踪。<br>
通常，当用户滚动浏览消息列表时，我们需要确定哪些消息已经出现在可视区域内，以便标记它们为已读状态。<br>
通过使用<code>IntersectionObserver</code>，我们可以监测消息列表中每个消息元素与可视区域的交叉情况。一旦某个消息元素进入可视区域，我们可以触发一个回调函数来处理相应的逻辑，例如将该消息标记为已读。</p>
<p>以下是一个简单的示例，演示了<code>IntersectionObserver</code>在消息已读状态场景中的应用：</p>
<pre><code>// 创建一个 IntersectionObserver 实例
const observer = new IntersectionObserver((entries) =&gt; {
  entries.forEach((entry) =&gt; {
    if (entry.isIntersecting) {
      // 当消息元素进入可视区域时，将其标记为已读
      markMessageAsRead(entry.target);
    }
  });
});

// 获取所有消息元素
const messageElements = document.querySelectorAll('.message');

// 监测每个消息元素与可视区域的交叉情况
messageElements.forEach((messageElement) =&gt; {
  observer.observe(messageElement);
});

// 标记消息为已读的逻辑
function markMessageAsRead(messageElement) {
  // 将消息标记为已读状态，例如改变消息的样式或发送已读状态的请求
  messageElement.classList.add('read');
  // 其他处理逻辑...
}
</code></pre>
<p>在上面的代码中，我们创建了一个<code>IntersectionObserver</code>实例，并为其指定了一个回调函数。当消息元素进入可视区域时，该回调函数会被触发。然后，我们可以在回调函数中执行将消息标记为已读的逻辑。</p>
<p>通过将消息元素与<code>IntersectionObserver</code>进行关联，我们可以动态地监测它们与可视区域的交叉情况，无需依赖用户的滚动行为或其他事件来触发状态的更新。这种方式可以提供更即时、精确的消息已读状态更新，增强用户体验。</p>
<h2>4.11 更多应用</h2>
<p>好了，已经列举 10 个场景了，以上应用场景展示了 <code>IntersectionObserver</code> 的灵活性和实用性，除了这些应用场景，<code>IntersectionObserver</code> 在 <code>Web</code> 开发中还有许多其他用途，开发者可以根据项目需求，结合 <code>IntersectionObserver</code> 的功能，实现各种交互效果、性能优化和用户体验提升，根据具体需求进行灵活的应用和扩展，使得 <code>Web</code> 开发更加便捷和可靠。</p>
<ol start="5">
<li>
<p>进阶技巧与最佳实践
============</p>
</li>
<li>
<p><strong>选择合适的根元素</strong><br>
根据你的需求，选择合适的根元素进行监听。根元素可以是整个文档或特定的容器元素。确保选择的根元素能够包含你要监听的目标元素。</p>
</li>
<li>
<p><strong>优化阈值设置</strong><br>
设置合适的交叉比例阈值可以减少不必要的回调函数触发。过多的阈值设置可能会导致频繁的回调函数执行，因此需要根据具体情况进行优化。</p>
</li>
<li>
<p><strong>避免频繁的回调函数执行</strong><br>
由于 <code>IntersectionObserver</code> 可能在短时间内多次触发回调函数，为了避免频繁的操作或网络请求，可以使用节流（<code>throttling</code>）或防抖（<code>debouncing</code>）技术进行处理。节流可以限制回调函数的执行频率，而防抖可以在指定时间内的连续触发中只执行最后一次。</p>
</li>
<li>
<p><strong>优化性能与资源消耗</strong><br>
尽管 <code>IntersectionObserver</code> 可以提供更好的性能，但当处理大量元素或复杂布局时，仍需考虑性能和资源消耗。可以结合使用时间间隔、限制最大触发次数等策略，确保在合理的范围内处理交叉状态变化。</p>
</li>
<li>
<p><strong>控制监听范围</strong><br>
仅监听真正需要监测的元素，避免不必要的监听。过多的监听会增加性能消耗，并可能导致不必要的回调函数触发。</p>
</li>
<li>
<p><strong>谨慎使用多个 <code>IntersectionObserver</code></strong><br>
当需要监测多个元素时，使用多个 <code>IntersectionObserver</code> 可能会增加代码复杂性和性能开销。在这种情况下，可以考虑合并监听逻辑，减少 <code>IntersectionObserver</code> 的数量。</p>
</li>
<li>
<p><strong>处理边界情况</strong><br>
注意处理边界情况，如元素尺寸变化、容器滚动等。在这些情况下，<code>IntersectionObserver</code> 可能无法及时检测到交叉状态的变化，需要进行额外的处理。</p>
</li>
<li>
<p><strong>考虑兼容性</strong><br>
尽管大多数现代浏览器都支持 <code>IntersectionObserver</code>，但在一些旧版本浏览器中可能不被支持。为了确保兼容性，可以使用 <code>IntersectionObserver</code> 的 <code>polyfill</code> 或提供降级方案。</p>
</li>
<li>
<p><strong>处理 <code>IntersectionObserver</code> 回调中的异步操作</strong></p>
<ul>
<li>取消异步操作：在某些情况下，当元素离开视窗或不再需要异步操作时，可能需要取消正在进行的异步操作。例如，当用户迅速滚动页面时，可能需要取消之前触发的异步操作，以避免不必要的网络请求或计算。可以使用适当的方法，如取消 <code>Promise</code> 或中断正在进行的异步任务。</li>
<li>性能优化：对于耗时的异步操作，需要注意性能优化。考虑使用并发执行、缓存结果或其他优化策略，以减少延迟和资源消耗。</li>
</ul>
</li>
<li>
<p><strong>清理资源</strong><br>
当不再需要 <code>IntersectionObserver</code> 监听或元素被销毁时，确保正确地清理和释放相关的资源。取消监听、解除绑定和清理回调函数，以避免内存泄漏和不必要的资源占用。</p>
</li>
<li>
<p>测试和调试方法
==========</p>
</li>
</ol>
<ul>
<li>使用 <code>console.log()</code> 在回调函数中输出相关信息，例如元素的交叉状态、触发的次数等</li>
<li>在 <code>Elements</code> 面板中，你可以检查元素的状态、样式和位置，以验证是否正确地添加和移除 <code>IntersectionObserver</code> 监听。</li>
<li>在开发者工具的设备模式中，可以模拟不同的视口大小和设备类型。这样可以测试不同屏幕尺寸下的元素交叉状态变化</li>
<li>编写单元测试来验证 <code>IntersectionObserver</code> 的功能和效果。使用测试框架和断言库，编写针对回调函数和交叉状态的测试用例，并确保代码在各种情况下都能正常工作。</li>
<li>将 <code>IntersectionObserver</code> 集成到实际的网页或应用中，并进行真实场景的测试。测试不同交互操作、滚动行为、布局变化等情况下的效果，并确保交互和性能的预期达到。</li>
</ul>
<h1>7 总结</h1>
<p><strong>优势</strong></p>
<ol>
<li><strong>减少性能开销</strong>：与传统的滚动事件相比，<code>IntersectionObserver</code> 监听元素的可见性变化，而不是每次滚动都触发事件。这样可以大大减少性能开销，尤其在处理大量元素或复杂布局的情况下效果更为显著。</li>
<li><strong>精确可靠的交叉检测</strong>：<code>IntersectionObserver</code> 提供了精确可靠的元素交叉检测功能。它使用几何学算法，无论是元素进入视窗、完全可见还是离开视窗，都可以准确地检测到，而不会受到滚动速度、滚动方向或缩放等因素的影响。</li>
<li><strong>异步执行</strong>：<code>IntersectionObserver</code> 是通过异步执行回调函数来处理交叉状态变化的。这意味着浏览器可以优化执行顺序，并且不会阻塞主线程。这对于优化页面性能和流畅度非常有益。</li>
<li><strong>支持懒加载和动态加载</strong>：通过 <code>IntersectionObserver</code>，可以实现懒加载图片、延迟加载内容块等动态加载的功能。只有当元素进入视窗时，才会触发加载操作，可以节省带宽和资源，并提高页面加载速度。</li>
</ol>
<p><strong>限制</strong></p>
<ol>
<li><strong>兼容性</strong>：尽管现代浏览器大多支持 <code>IntersectionObserver</code>，但在一些旧版本的浏览器中可能不被支持。为了确保广泛的兼容性，开发者需要根据项目需求考虑是否需要提供降级方案或使用 <code>polyfill</code>。</li>
<li><strong>事件顺序不确定性</strong>：由于 <code>IntersectionObserver</code> 是异步执行的，不同元素的回调函数执行顺序是不确定的。这可能会导致在处理相关逻辑时需要额外的注意，以确保正确的顺序和逻辑关联性。</li>
<li><strong>对于某些特殊情况的支持不完整</strong>：<code>IntersectionObserver</code> 在一些特殊情况下的支持可能不完整，例如浏览器缩放或滚动容器的变化。在这些情况下，可能需要额外的处理来确保准确的交叉状态检测。</li>
<li><strong>性能监控的限制</strong>：虽然 <code>IntersectionObserver</code> 可以监测元素的可见性，但并不能直接提供元素的具体位置信息。如果需要精确的元素位置信息来进行性能监控或其他操作，可能需要额外的计算或结合其他技术来实现。</li>
</ol>
