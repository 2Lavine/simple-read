<h1>24-01-18-EventSource  Web API 接口参考  MDN-H88B53D</h1><p>一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 text/event-stream 格式发送事件，此连接会一直保持开启直到通过调用 EventSource.close() 关闭。</p>
<p>对于处理如社交媒体状态更新、消息来源（news feed）或将数据传递到客户端存储机制（如 IndexedDB 或 web 存储）之类的，EventSource 无疑是一个有效方案</p>
<p>当不使用 HTTP/2 时，服务器发送事件（SSE）受到打开连接数的限制，这个限制是对于浏览器的，并且设置为非常低的数字（6）</p>
<p>这个限制是每个浏览器和域名的，这意味着你可以在所有标签页中打开 6 个 SSE 连接到 www.example1.com，以及另外 6 个 SSE 连接到 www.example2.com（来源：Stackoverflow）。当使用 HTTP/2 时，最大并发 HTTP 流的数量是由服务器和客户端协商的（默认为 100）。</p>
<p>EventSource()
创建一个新的 EventSource，用于从指定的 URL 接收服务器发送事件，可以选择开启凭据模式</p>

<h1>24-01-18-Location  Web API 接口参考  MDN-H88B5B6</h1><p>Location.href
包含整个 URL 的一个DOMString</p>
<p>Location.origin (en-US) 只读
包含页面来源的域名的标准形式DOMString。</p>

<h1>24-01-18-OKR 与 KPI有什么区别</h1><p>不要忘记 K。
KPI 的使用本应迫使您将真正重要的（关键指标）与其他指标区分开来，但许多人忘记了这一点
要设定良好的 OKR，您应该评估业务的不同方面，并确定绩效变化会产生最大影响的方面，同时保持其他要素处于稳定状态
战略是决定目的地的过程。它可以帮助您决定要去哪里。
OKR 是您的 GPS、汽车的导航系统：它将帮助您跟踪您是否走在正确的道路上，并在需要时纠正路线。而且就像 GPS 一样，OKR 不会帮助你决定目的地，也不会帮助你制定策略。
监控 KPI 是汽车仪表板上的刻度盘，它们会告诉您其他一切是否正常。</p>

<h1>24-01-18-Window：location 属性</h1><p>Window.location 只读属性返回一个 Location 对象</p>

<h1>24-01-18-href和 origin</h1><p>href 属性包含整个 URL（Uniform Resource Locator），即当前页面的完整地址。
origin 属性包含当前页面的协议、主机和端口部分，但不包含路径或查询字符串。</p>
<h1>24-01-18-link：外部资源链接元素</h1><p>Link标签
rel此属性命名链接文档与当前文档的关系。</p>
<ul>
<li>该属性必须是链接类型值的用空格分隔的列表。</li>
<li>将rel设定为preload，表示浏览器应该预加载该资源</li>
<li>rel 为prefetch 非标准 安全上下文
<ul>
<li>此属性标识下一个导航可能需要的资源，用户代理应检索该资源。这允许用户代理在将来请求资源时更快地做出响应。
你可以在media属性中提供媒体类型或查询; 然后，只有在媒体条件为 true 时，才会加载此资源</li>
</ul>
</li>
</ul>

<h1>24-01-18-商业模型图</h1><p>在商业模型图设计范本的9个构面中，又区分成4大导向</p>
<ul>
<li>供给或资源导向</li>
<li>价值导向</li>
<li>需求导向</li>
<li>财务导向</li>
</ul>

<h1>Fiber</h1><h2><strong>Fiber 是什么？</strong></h2>
<p>当我们写 React 组件并使用 JSX 时，React 在底层会将 JSX 转换为元素的对象结构。例如：</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre>
<p>上述代码会被转换为以下形式：</p>
<pre><code>const element = React.createElement(
  'h1',
  null,
  'Hello, world'
);
</code></pre>
<p>createElement的 Element 是什么？</p>
<ul>
<li>一种内部实例，一个 JavaScript 对象,用来追踪该组件的所有信息和状态。</li>
<li>在早期版本的 React 中，我们称之为 “实例” 或“虚拟 DOM 对象”。</li>
<li>但在 Fiber 架构中，这个新的工作单元就叫做 Fiber。</li>
</ul>
<h2>Fiber 对象</h2>
<p>一个简化的 Fiber 对象长这样：</p>
<pre><code>{
  type: 'h1',  // 组件类型
  key: null,   // React key
  props: { ... }, // 输入的props
  state: { ... }, // 组件的state (如果是class组件或带有state的function组件)
  child: Fiber | null,  // 第一个子元素的Fiber
  sibling: Fiber | null,  // 下一个兄弟元素的Fiber
  return: Fiber | null,  // 父元素的Fiber
  // ...其他属性
}
</code></pre>
<p>当 React 开始工作时，它会沿着 Fiber 树形结构进行，试图完成每个 Fiber 的工作（例如，比较新旧 props，确定是否需要更新组件等）。如果主线程有更重要的工作（例如，响应用户输入），则 React 可以中断当前工作并返回执行主线程上的任务。</p>
<p>因此，Fiber 不仅仅是代表组件的一个内部对象，它还是 React 的调度和更新机制的核心组成部分。</p>
<h2><strong>为什么需要 Fiber？</strong></h2>
<p>在 React 16 之前的版本中，是使用递归的方式处理组件树更新，称为<strong>堆栈调和（Stack Reconciliation）</strong>，这种方法一旦开始就不能中断，直到整个组件树都被遍历完。</p>
<ul>
<li>处理大量数据或复杂视图时可能导致主线程被阻塞，从而使应用无法及时响应用户的输入或其他高优先级任务。</li>
</ul>
<p>Fiber 的引入改变了这一情况。</p>
<ul>
<li>Fiber 可以理解为是 React 自定义的一个带有链接关系的 DOM 树，</li>
<li>每个 Fiber 都代表了一个工作单元，</li>
<li>React 可以在处理任何 Fiber 之前判断是否有足够的时间完成该工作，并在必要时中断和恢复工作。</li>
</ul>
<h2>Fiber 的结构</h2>
<p>我们来看一下源码里 FiberNode 的结构：</p>
<pre><code class="language-js">function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  // 基本属性
  this.tag = tag; // 描述此Fiber的启动模式的值（LegacyRoot = 0; ConcurrentRoot = 1）
  this.key = key; // React key
  this.elementType = null; // 描述React元素的类型。例如，对于JSX&lt;App /&gt;，elementType是App
  this.type = null; // 组件类型
  this.stateNode = null; // 对于类组件，这是类的实例；对于DOM元素，它是对应的DOM节点。

  // Fiber链接
  this.return = null; // 指向父Fiber
  this.child = null; // 指向第一个子Fiber
  this.sibling = null; // 指向其兄弟Fiber
  this.index = 0; // 子Fiber中的索引位置

  this.ref = null; // 如果组件上有ref属性，则该属性指向它
  this.refCleanup = null; // 如果组件上的ref属性在更新中被删除或更改，此字段会用于追踪需要清理的旧ref

  // Props &amp; State
  this.pendingProps = pendingProps; // 正在等待处理的新props
  this.memoizedProps = null; // 上一次渲染时的props
  this.updateQueue = null; // 一个队列，包含了该Fiber上的状态更新和副作用
  this.memoizedState = null; // 上一次渲染时的state
  this.dependencies = null; // 该Fiber订阅的上下文或其他资源的描述

  // 工作模式
  this.mode = mode; // 描述Fiber工作模式的标志（例如Concurrent模式、Blocking模式等）。

  // Effects
  this.flags = NoFlags; // 描述该Fiber发生的副作用的标志（十六进制的标识）
  this.subtreeFlags = NoFlags; // 描述该Fiber子树中发生的副作用的标志（十六进制的标识）
  this.deletions = null; // 在commit阶段要删除的子Fiber数组

  this.lanes = NoLanes; // 与React的并发模式有关的调度概念。
  this.childLanes = NoLanes; // 与React的并发模式有关的调度概念。

  this.alternate = null; // Current Tree和Work-in-progress (WIP) Tree的互相指向对方tree里的对应单元

    // 如果启用了性能分析
  if (enableProfilerTimer) {
    // ……
  }

    // 开发模式中
  if (__DEV__) {
    // ……
  }
}
</code></pre>
<p>其实可以理解为是一个更强大的虚拟 DOM。</p>
<h2>Fiber 工作原理</h2>
<p>Fiber 核心的点就是：可以中断和恢复，这个特性增强了 React 的并发性和响应性。
实现可中断和恢复的原因就在于：</p>
<ul>
<li>Fiber 的数据结构里提供的信息让 React 可以追踪工作进度、管理调度和同步更新到 DOM</li>
</ul>
<p>为什么 FIber 的数据结构支持可中断和恢复?</p>
<ul>
<li><strong>单元工作</strong>：每个 Fiber 节点代表一个单元，所有 Fiber 节点共同组成一个 Fiber 链表树（有链接属性，同时又有树的结构），这种结构让 React 可以细粒度控制节点的行为。</li>
<li><strong>链接属性</strong>：<strong><code>child</code></strong>、<strong><code>sibling</code></strong> 和 <strong><code>return</code></strong> 字段构成了 Fiber 之间的链接关系，使 React 能够遍历组件树并知道从哪里开始、继续或停止工作。</li>
<li><strong>双缓冲技术：</strong>
<ul>
<li>React 在更新时，会根据现有的 Fiber 树（<strong>Current Tree</strong>）创建一个新的临时树（<strong>Work-in-progress (WIP) Tree</strong>），</li>
<li>WIP-Tree 是在后台进行更新，包含更新受影响的最高节点直至其所有子孙节点。
<ul>
<li>WIP-Tree 更新完成后会复制其它节点，并最终替换掉 Current Tree，成为新的 Current Tree。</li>
</ul>
</li>
<li>Current Tree 是当前显示在页面上的视图</li>
<li>因为 React 在更新时总是维护了两个 Fiber 树，所以可以随时进行比较、中断或恢复等操作，而且这种机制让 React 能够同时具备拥有优秀的渲染性能和 UI 的稳定性。</li>
</ul>
</li>
<li><strong>State 和 Props：<code>memoizedProps</code></strong>、<strong><code>pendingProps</code></strong> 和 <strong><code>memoizedState</code></strong> 字段让 React 知道组件的上一个状态和即将应用的状态。通过比较这些值，React 可以决定组件是否需要更新，从而避免不必要的渲染，提高性能。</li>
<li><strong>副作用的追踪</strong>：<strong><code>flags</code></strong> 和 <strong><code>subtreeFlags</code></strong> 字段标识 Fiber 及其子树中需要执行的副作用，例如 DOM 更新、生命周期方法调用等。React 会积累这些副作用，然后在 Commit 阶段一次性执行，从而提高效率。</li>
</ul>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/v2-f6aafc4408e74bf10af13f8a5abe3a6d_r.jpg" alt=""></p>
<h2>Fiber 工作流程</h2>
<h3>第一阶段：Reconciliation（调和）</h3>
<ul>
<li><strong>目标</strong>: 确定哪些部分的 UI 需要更新。</li>
<li><strong>原理</strong>: 这是 React 构建工作进度树的阶段，会比较新的 props 和旧的 Fiber 树来确定哪些部分需要更新。
调和阶段又分为三个小阶段：</li>
</ul>
<h3>1、创建与标记更新节点：<code>beginWork</code></h3>
<ol>
<li><strong>判断 Fiber 节点是否要更新：</strong></li>
</ol>
<pre><code>// packages/react-reconciler/src/ReactFiberBeginWork.js
// 以下只是核心逻辑的代码，不是beginWork的完整源码
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
    if (current !== null) {
        // 这是旧节点，需要检查props和context是否有变化再确认是否需要更新节点
        const oldProps = current.memoizedProps;
        const newProps = workInProgress.pendingProps;

        if(oldProps !== newProps || hasLegacyContextChanged()) {
            didReceiveUpdate = true; // props和context有变化，说明节点有更新
        } else {
            // 其它特殊情况的判断
        }
    } else {
        didReceiveUpdate = false; // 这是新节点，要创建，而不是更新
    }

    workInProgress.lanes = NoLanes; // 进入beginWork表示开始新的工作阶段，所以要把旧的workInProgress优先级清除掉

    switch (workInProgress.tag) {
        // 通过workInProgress的tag属性来确定如何处理当前的Fiber节点
        // 每一种tag对应一种不同的Fiber类型，进入不同的调和过程（reconcileChildren()）
        case IndeterminateComponent: // 尚未确定其类型的组件
        case LazyComponent: // 懒加载组件
        case FunctionComponent: // 函数组件
        case ClassComponent: // 类组件

        // 其它多种Fiber类型
        // case ……
    }
}
</code></pre>
<ol>
<li><strong>判断 Fiber 子节点是更新还是复用：</strong></li>
</ol>
<pre><code>// packages/react-reconciler/src/ReactFiberBeginWork.js
export function reconcileChildren(
  current: Fiber | null,
  workInProgress: Fiber,
  nextChildren: any, // 要调和的新的子元素
  renderLanes: Lanes,
) {
  if (current === null) {
    // 如果current为空，说明这个Fiber是首次渲染，React会为nextChildren生成一组新的Fiber节点
    workInProgress.child = mountChildFibers(
      workInProgress,
      null,
      nextChildren,
      renderLanes,
    );
  } else {
    // 当current非空时，React会利用现有的Fiber节点（current.child）和新的子元素（nextChildren）进行调和
    workInProgress.child = reconcileChildFibers(
      workInProgress,
      current.child,
      nextChildren,
      renderLanes,
    );
  }
}
</code></pre>
<p><strong><code>mountChildFibers</code><strong>和</strong><code>reconcileChildFibers</code><strong>最终会进入同一个方法</strong><code>createChildReconciler</code></strong>，执行 Fiber 节点的调和（处理诸如新的 Fiber 创建、旧 Fiber 删除或现有 Fiber 更新等操作）。而整个 <strong><code>beginWork</code></strong> 完成后，就会进入 <strong><code>completeWork</code></strong> 流程。</p>
<h3>2、收集副作用列表：<code>completeUnitOfWork</code>和<code>completeWork</code></h3>
<p><strong><code>completeUnitOfWork</code></strong> 负责遍历 Fiber 节点，同时记录了有副作用节点的关系。下面从源码上理解它的工作：
<strong><code>completeWork</code></strong> 在 <strong><code>completeUnitOfWork</code></strong> 中被调用，下面是 <strong><code>completeWork</code></strong> 的逻辑，主要是根据 tag 进行不同的处理，真正的核心逻辑在 <strong><code>bubbleProperties</code></strong> 里面</p>
<h2>completeUnitOfWork</h2>
<p>completeUnitOfWork`** 负责遍历 Fiber 节点，同时记录了有副作用节点的关系。下面从源码上理解它的工作：</p>
<pre><code>// packages/react-reconciler/src/ReactFiberWorkLoop.js
// 以下只是核心逻辑的代码，不是completeUnitOfWork的完整源码
function completeUnitOfWork(unitOfWork: Fiber): void {
    let completedWork: Fiber = unitOfWork; // 当前正在完成的工作单元
    do {
        const current = completedWork.alternate; // 当前Fiber节点在另一棵树上的版本
        const returnFiber = completedWork.return; // 当前Fiber节点的父节点

        let next;
        next = completeWork(current, completedWork, renderLanes); // 调用completeWork函数

        if (next !== null) {
          // 当前Fiber还有工作要完成
          workInProgress = next;
          return;
        }
        const siblingFiber = completedWork.sibling;
        if (siblingFiber !== null) {
          // 如果有兄弟节点，则进入兄弟节点的工作
          workInProgress = siblingFiber;
          return;
        }
        // 如果没有兄弟节点，回到父节点继续
        completedWork = returnFiber;
        workInProgress = completedWork;
    } while (completedWork !== null);

    // 如果处理了整个Fiber树，更新workInProgressRootExitStatus为RootCompleted，表示调和已完成
  if (workInProgressRootExitStatus === RootInProgress) {
    workInProgressRootExitStatus = RootCompleted;
  } 
}
</code></pre>
<h2>completeWork</h2>
<p><strong><code>completeWork</code></strong> 在 <strong><code>completeUnitOfWork</code></strong> 中被调用，下面是 <strong><code>completeWork</code></strong> 的逻辑，主要是根据 tag 进行不同的处理，真正的核心逻辑在 <strong><code>bubbleProperties</code></strong> 里面</p>
<pre><code>// packages/react-reconciler/src/ReactFiberCompleteWork.js
// 以下只是核心逻辑的代码，不是completeWork的完整源码
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  const newProps = workInProgress.pendingProps;
    switch (workInProgress.tag) {
    // 多种tag
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
         bubbleProperties(workInProgress)
         return null;
    case ClassComponent:
         // 省略逻辑
         // ……
         bubbleProperties(workInProgress)
         return null;
    case HostComponent:
         // 省略逻辑
         // ……
         return null;
    // 多种tag
        // ……
  }
}
</code></pre>
<p><strong><code>bubbleProperties</code></strong> 为 <strong><code>completeWork</code></strong> 完成了两个工作：</p>
<ol>
<li><strong>记录 Fiber 的副作用标志</strong></li>
<li><strong>为子 Fiber 创建链表</strong></li>
</ol>
<p>这两个工作都从下面这段代码中看出来：</p>
<pre><code>// packages/react-reconciler/src/ReactFiberCompleteWork.js
// 以下只是核心逻辑的代码，不是bubbleProperties的完整源码
function bubbleProperties(completedWork: Fiber) {
    const didBailout =
    completedWork.alternate !== null &amp;&amp;
    completedWork.alternate.child === completedWork.child; // 当前的Fiber与其alternate（备用/上一次的Fiber）有相同的子节点，则跳过更新

    let newChildLanes = NoLanes; // 合并后的子Fiber的lanes
    let subtreeFlags = NoFlags; // 子树的flags。

    if (!didBailout) {
        // 没有bailout，需要冒泡子Fiber的属性到父Fiber
        let child = completedWork.child;
        // 遍历子Fiber，并合并它们的lanes和flags
        while (child !== null) {
          newChildLanes = mergeLanes(
            newChildLanes,
            mergeLanes(child.lanes, child.childLanes),
          );

          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;

          child.return = completedWork; // Fiber的return指向父Fiber，确保整个Fiber树的一致性
          child = child.sibling;
        }
        completedWork.subtreeFlags |= subtreeFlags; // 合并所有flags（副作用）
    } else {
        // 有bailout，只冒泡那些具有“静态”生命周期的flags
        let child = completedWork.child;
        while (child !== null) {
          newChildLanes = mergeLanes(
            newChildLanes,
            mergeLanes(child.lanes, child.childLanes),
          );

          subtreeFlags |= child.subtreeFlags &amp; StaticMask; // 不同
          subtreeFlags |= child.flags &amp; StaticMask; // 不同

          child.return = completedWork;
          child = child.sibling;
        }
        completedWork.subtreeFlags |= subtreeFlags;
    }
    completedWork.childLanes = newChildLanes; // 获取所有子Fiber的lanes。
    return didBailout;
}
</code></pre>

<h1>Introduction</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.patterns.dev/vanilla/rendering-patterns">www.patterns.dev</a></p>
</blockquote>
<h1>Rendering Patterns</h1>
<ul>
<li>SSG</li>
<li>ISR</li>
<li>SSR,RSC</li>
<li>Streaming SSR</li>
<li>Edge rendering</li>
</ul>
<h2>Develop Experiences</h2>
<h2>faster build times, easy rollbacks, scalable infrastructure
dynamic content, reliable uptime
Choosing a Pattern</h2>
<p>While this can get overwhelming, it’s important to remember that every pattern was designed to address specific use cases.</p>
<h3>Static Rendering</h3>
<p>Static rendering is a simple yet powerful pattern you can use to build fast websites with nearly instant page loads.</p>
<ul>
<li>the entire page gets generated at build time and does not change till the next build.</li>
<li>The HTML content is static and easily cacheable on a CDN or an Edge network.
<ul>
<li>CDNs can quickly serve the pre-rendered cached HTML to clients when they request a specific page.</li>
</ul>
</li>
</ul>
<p>cuts down the time it would otherwise take to process the request, render HTML content and respond to a request in a typical server-side rendering set-up.</p>
<h4>Static Rendering Suitable web</h4>
<p>The process described above is most suitable for pages that do not change often and display the same data no matter who requests them.
Since we consume a lot of dynamic, customized data on the web today, we have variations of static rendering to cater to different use cases.</p>
<ul>
<li>Plain static</li>
<li>Static with Client side</li>
<li>Incremental Static regenration</li>
<li>On demant Incremental Static regenration</li>
</ul>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/img1.png" alt=""></p>
<h3>Basic/Plain Static Rendering</h3>
<p>Since there are many variations of static rendering, let’s call the primary technique we discussed earlier Plain Static Rendering. You can use it for pages with little to no dynamic content.
When a user requests the page, the server sends the pre-generated HTML to the client. This response is also cached to the edge location closest to the user. The browser then renders the HTML and employs a JavaScript bundle to hydrate the page.</p>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/7.png" alt=""></p>
<p>Plain static rendering is excellent for performance because</p>
<ul>
<li>it results in an extremely <strong>quick TTFB</strong> since HTML is already available on the server.</li>
<li>The browser receives a faster response and can render it quickly, resulting in a <strong>fast FCP and LCP</strong>.</li>
<li>Since the content is static, there is <strong>no layout shift</strong> while rendering it.</li>
</ul>
<h3>Static Rendering with Client-Side <code>fetch</code></h3>
<p>Best for pages</p>
<ul>
<li>Contain data that should refresh on every load</li>
<li>contain stable placeholder components
The pre-generated HTML file is sent to the client when the user requests the page. The user initially sees the skeleton UI without any data. The client fetches the data from the API route, receives the response, and shows the listings. es the response and shows the listings. (the hydration call is not included in the example)</li>
</ul>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/12.png" alt=""></p>
<p>While <strong>Static Rendering with Client-Side</strong> fetch gives us a <strong>good TTFB and FCP</strong>, the <strong>LCP is sub-optimal</strong> since “largest content” can only be displayed after we get the listings data from the API route.</p>
<p>disadvantage</p>
<ul>
<li>There is also a strong <strong>possibility of layout shifts</strong>, especially if the size of the skeleton UI doesn’t match the content rendered eventually.</li>
<li>this approach could result in <strong>higher server costs</strong> since we call the API route once per page request.</li>
</ul>
<h3>Static with <code>getStaticProps</code></h3>
<p>This method allows you to access the data provider and fetch data at build time on the server. It can be a good solution if you know that the dynamic data on a static page will always be available at build time.
<img src="/Users/lmelon/myGitHubMac/simple-read/_resources/15.png" alt=""></p>
<p>The <code>getStaticProps</code> method allows us to generate the HTML with the data on the server. Thus, we can avoid creating API routes to fetch the data on the client. Similarly, a skeleton component is not required while the data loads, as the page, will be rendered with the data.
When we build the project, the data provider is called, and the returned data is piped to the generated HTML.</p>
<p>When a user requests the page, the process is similar to plain static rendering. The response is cached and rendered to the screen, and the browser fetches the JavaScript bundles required to hydrate the page.</p>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/16.png" alt=""></p>
<p>From a client perspective, the network and main thread work are identical to plain static rendering, so we get a similarly <strong>superior performance</strong>.</p>
<p>Disadvantages</p>
<ul>
<li>As the site grows, the DX, when using this method, may not be so good.
<ul>
<li><strong>long build times</strong>: For sites with hundreds of pages built statically(for example, blog sites), calling the <code>getStaticProps</code> method repeatedly can result in <strong>long build times</strong>.</li>
<li><strong>large usage</strong>:If you’re using an external API, you might hit the request limit or run a <strong>large usage bill</strong>.</li>
</ul>
</li>
<li>Only suitable only when we can get away with renewing data infrequently at build time.
<ul>
<li>Frequent updates to data would mean often having to rebuild and redeploy the site.</li>
</ul>
</li>
</ul>
<h3>Incremental Static Regeneration</h3>
<p>We can use incremental static regeneration to solve the build time, and dynamic data issues discussed earlier.</p>
<p>ISR is hybrid in the sense that it allows us</p>
<ul>
<li>to pre-render only certain static pages</li>
<li>render the dynamic pages on-demand when the user requests them.
This results in shorter build times and allows automatic invalidation of the cache and regeneration of the page after a specific interval</li>
</ul>
<p>Let’s assume we now want to show individual property details to enhance our previous demo. We can pre-render these new pages so that they load quickly when a user clicks on a listing.</p>
<p>Next.js helps us achieve this by using the getStaticPaths method to generate dynamic paths. We can tell Next.js which pages to pre-generate based on their query parameter.
For our demo, let’s fetch all listings and pre-generate the pages for each of them.
Note that this would take very long if there were thousands of listings. In that case, we will have to tell Next to only pre-generate a subset of all the pages and render a fallback when the remaining listing pages are generated on-demand (when the user requests).</p>
<p>The pre-rendered and generated on-demand pages are delivered similarly. If a user requests a page that hasn’t been generated yet, it gets generated on-demand and cached by the Edge. Thus, only the first user is likely to have a poorer experience for pages that are not pre-rendered. Everyone else will benefit from the fast, cached response.</p>
<h4>Automatically invalidate the cache and regenerate the page</h4>
<p>This addresses the long build-time problem of the previous methods. But we still have the landing page, which needs to be redeployed every time we have a new listing.
To enable a refresh of the landing page, we can automatically invalidate the cache and regenerate the page in the background at a specific interval. We can use this by adding a revalidate field to the returned object.
If a user requests a page that has been in the cache for longer than the specified number of seconds, the user will initially see the stale page. The page regeneration is triggered simultaneously. Once the page is regenerated in the background, the cache is invalidated and updated with the recently regenerated page.
With Incremental Static Regeneration, we can show dynamic content by automatically revalidating the page every few seconds.</p>
<p>Disvantages</p>
<ul>
<li>Our content likely doesn’t update as often as the interval we have defined. This would result in unnecessary page regeneration and invalidation of the cache.</li>
<li>Each time this happens, we invoke our serverless functions, which could result in higher server costs.</li>
</ul>
<h3>On-demand Incremental Static Regeneration</h3>
<p>To solve the last drawback mentioned above we have <strong>On-demand Incremental Static Regeneration</strong> which allows us to use ISR, but the regeneration occurs on certain events rather than at fixed intervals.
Instead of using a <code>revalidate</code> field, we revalidate based on new data in API routes.</p>
<p><video src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.24.13_PM_xeumhu.webm" control></video></p>
<p>For example, we can listen to an incoming webhook event that tells us when new data has been added to our data provider.
With regular ISR, the updated page is cached only at the edge nodes which have handled user requests for the page. On-demand ISR regenerates and redistributes the page across the edge network so that users worldwide will automatically see the most recent version of the page from the edge cache without seeing stale content.
We also avoid unnecessary regenerations and serverless function calls, reducing operational costs compared to regular ISR.</p>
<h3>Server-Side Rendering</h3>
<p>There are use cases where static isn’t the best option, for example, for highly dynamic, personalized pages that are different for every user. Let’s see what pattern works best for these.
With server-side rendering, we generate the HTML for every request.</p>
<ul>
<li>This approach is most suitable for pages containing highly personalized data, for example, data based on the user cookie or generally any data obtained from the user’s request.</li>
<li>It’s also suitable for pages that should be render-blocking, perhaps based on authentication state.</li>
<li>A personalized dashboard is an excellent example of highly dynamic content on a page. Most of the content is based on the user’s identity or authorization level that may be contained in a user cookie.</li>
</ul>
<p>Next.js allows us to render the page on the server using the <code>getServerSideProps</code> method. This method runs on the server for every request and eventually passes the returned data to the page to generate the HTML.
When a user requests the page, the <code>getServerSideProps</code> method runs, returns the data used to generate the page, and sends the response to the client. The client then renders this HTML and may send another request to fetch the JavaScript bundle that hydrates the elements.</p>
<p>The generated HTML content is unique to every request and should not be cached by the CDN.
<img src="/Users/lmelon/myGitHubMac/simple-read/_resources/31.png" alt=""></p>
<p>The network and main thread for the client are very similar for static and server-side rendering. The FCP is almost equal to the LCP, and we can easily avoid layout shifts as there is no dynamic content loading after the initial page load.</p>
<p><video src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.36.49_PM_kkuxv3.webm" control></video></p>
<p>SSR Disvantage</p>
<ul>
<li>the TTFB for server-rendered pages is significantly longer than static rendering as the page gets generated from scratch at every request.</li>
<li>server costs are likely to be high because you invoke serverless functions at every request.</li>
<li>The time it takes to start up the lambda, known as the long cold boot, is a common issue with serverless functions.</li>
</ul>
<p>SSR optimization</p>
<ol>
<li><strong>Execution time of <code>getServerSideProps</code></strong>
The page generation does not start until the data from <code>getServerSideProps</code> is available. Hence, we must ensure that the <code>getServerSideProps</code> method doesn’t run too long.</li>
<li><strong>Deploy databases in the same region as your serverless function</strong>
If the data comes from a database, we must reduce the time taken to query the database. In addition to query optimization, you should also consider the location of the database.</li>
<li><strong>Add <code>Cache-control</code> headers to responses</strong>
Another step to improve SSR performance is adding Cache-Control headers to the responses.</li>
</ol>
<h3>Edge SSR + HTTP Streaming</h3>
<p>Vercel is currently exploring <strong>Edge Server-Side Rendering</strong>, which will enable users to <strong>server-render from all regions</strong> and experience a <strong>near-zero cold boot</strong>.
Another benefit of <strong>Edge SSR</strong> is that the edge runtime allows <strong>HTTP streaming</strong>.</p>
<p>With serverless functions, we generate the entire page server-side and wait for the whole bundle to be loaded and parsed on the client before hydration can begin.
With Edge SSR, we can stream parts of the document as soon as they’re ready and hydrate these components granularly. This reduces the waiting time for users as they can see components as they stream in one by one.</p>
<p><strong>Streaming SSR</strong> also enables <strong>React Server Components</strong>. The combination of <strong>Edge SSR with React Server Components</strong> can allow us to have a beautiful <strong>hybrid between static and server rendering</strong>.</p>
<p><strong>React Server Components</strong> allow us to partially render React components on the server, which is useful for components that require large dependencies that need not be downloaded to the client.</p>
<p>Going back to the real-estate website example, if we wanted to show the landing page again and include region-specific listings for the user.</p>
<ul>
<li>The vast majority of the page only contains static data; it’s just the listings that require request-based data.</li>
<li>Instead of having to server-render the entire page, we can now choose only to render the listings component server-side and the rest client-side.</li>
<li>Whereas we initially had to server-render the whole page to achieve this behavior, we can now get the <strong>excellent performance of Static Rendering with the dynamic benefits of Server-Side Rendering</strong>.</li>
</ul>
<h2>Conclusion</h2>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/_resources/Rendering-ComparisonTable.svg.png" alt=""></p>
<p>The following table from <a href="https://dev.to/this-is-learning/patterns-for-building-javascript-websites-in-2022-5a93">Patterns for Building JavaScript Websites in 2022</a> offers another view pivoted by key application characteristics. It should be helpful for anyone looking for a suitable pattern for common <a href="https://jasonformat.com/application-holotypes/">application holotypes</a>.</p>
<table><thead><tr><th></th><th>Portfolio</th><th>Content</th><th>Storefront</th><th>Social Network</th><th>Immersive</th></tr></thead><tbody><tr><th>Holotype</th><td>Personal Blog</td><td>CNN</td><td>Amazon</td><td>Facebook</td><td>Figma</td></tr><tr><th>Interactivity</th><td>Minimal</td><td>Linked Articles</td><td>Purchase</td><td>Multi-Point, Real-time</td><td>Everything</td></tr><tr><th>Session Depth</th><td>Shallow</td><td>Shallow</td><td>Shallow - Medium</td><td>Extended</td><td>Deep</td></tr><tr><th>Values</th><td>Simplicity</td><td>Discover-ability</td><td>Load Performance</td><td>Dynamicism</td><td>Immersiveness</td></tr><tr><th>Routing</th><td>Server</td><td>Server, Hybrid</td><td>Hybrid, Transitional</td><td>Transitional, Client</td><td>Client</td></tr><tr><th>Rendering</th><td>Static</td><td>Static, SSR</td><td>Static, SSR</td><td>SSR</td><td>CSR</td></tr><tr><th>Hydration</th><td>None</td><td>Progressive, Partial</td><td>Partial, Resumable</td><td>Any</td><td>None (CSR)</td></tr><tr><th>Example Framework</th><td>11ty</td><td>Astro, Elder</td><td>Marko, Qwik, Hydrogen</td><td>Next, Remix</td><td>Create React App</td></tr></tbody></table>
<h1>requestAnimationFrame</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7062178363800027173?searchId=202401111042005CE25745555C47841FB9">juejin.cn</a></p>
</blockquote>
<h2>requestAnimationFrame</h2>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。</p>
<p>该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p>
<pre><code>window.requestAnimationFrame(callback);
</code></pre>
<ul>
<li>callback 下一次重绘之前更新动画帧所调用的函数 (即上面所说的回调函数)。该回调函数会被传入 DOMHighResTimeStamp 参数，该参数与 performance.now() 的返回值相同，它表示 requestAnimationFrame() 开始去执行回调函数的时刻。</li>
<li>返回值 一个 long 整数，请求 ID ，是回调列表中唯一的标识。是个非零值，没别的意义。你可以传这个值给 <strong>window.cancelAnimationFrame()</strong> 以取消回调函数。</li>
</ul>
<h3>基本应用</h3>
<p>用法其实跟 setTimeout 完全一致，只不过当前的时间间隔是跟着系统的绘制频率走，是固定的</p>
<pre><code>// 调用的是系统的时间间隔
const element = document.getElementById('some-element-you-want-to-animate');
let start;
function step(timestamp) {
  if (start === undefined)
    start = timestamp;
  const elapsed = timestamp - start;
  //这里使用`Math.min()`确保元素刚好停在200px的位置。
  element.style.transform = 'translateX(' + Math.min(0.1 * elapsed, 200) + 'px)';
  if (elapsed &lt; 2000) { // 在两秒后停止动画
    window.requestAnimationFrame(step);
  }
}
var timer1 = window.requestAnimationFrame(step);
//取消回调函数
cancelAnimationFrame(timer1);
</code></pre>
<p>注意若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用 window.requestAnimationFrame()</p>
<h3>优点</h3>
<ul>
<li>使得动画更加流畅，防止动画失帧 requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率</li>
<li>资源节能 (Cpu、内存等)
<ol>
<li>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量</li>
<li>requestAnimationFrame 是由浏览器专门为动画提供的 API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了 CPU 开销</li>
</ol>
</li>
</ul>
<h3>注意点</h3>
<ul>
<li>为了提高性能和电池寿命，因此在大多数浏览器里，当 requestAnimationFrame() 运行在后台标签页或者隐藏的 里时，requestAnimationFrame() 会被暂停调用以提升性能和电池寿命。</li>
<li>回调函数会被传入 DOMHighResTimeStamp 参数，DOMHighResTimeStamp 指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间。在同一个帧中的多个回调函数，它们每一个都会接受到一个相同的时间戳，即使在计算上一个回调函数的工作负载期间已经消耗了一些时间。该时间戳是一个十进制数，单位毫秒，最小精度为 1ms(1000μs)。</li>
</ul>
<h2>requestAnimationFrame 和 setInterval、setTimeout 的联系</h2>
<ul>
<li>因为 setTimeout 和 setInterval 是异步 api，必须需要等同步任务执行，还需要等待微任务完成以后，然后才会去执行当前这个回调函数。</li>
<li>这里会存在一个问题，没有办法去精准地把时间定位到，哪怕你写成 16，它也没有办法，让时间精准定位到 16。时间间隔没有办法保证。
深入 requestAnimationFrame 与 Event Loop</li>
</ul>
<hr>
<p>Event Loop（事件循环）是用来协调事件、用户交互、脚本、渲染、网络的一种浏览器内部机制。</p>
<ul>
<li>Event Loop 在浏览器内也分几种：
<ul>
<li>window event loop</li>
<li>worker event loop</li>
<li>worklet event loop
我们这里主要讨论的是 window event loop。也就是浏览器一个渲染进程内主线程所控制的 Event Loop。</li>
</ul>
</li>
</ul>
<h3>Event Loop 的基本处理过程</h3>
<ol>
<li>在所选 task queue (taskQueue) 中约定必须包含一个可运行任务。
<ol>
<li>如果没有此类 task queue，则跳转至下面 microtasks 步骤。</li>
</ol>
</li>
<li>pop 出taskQueue 中最老的 Task ，并将其设置为 event loop中正在运行的 task。</li>
<li>执行 oldestTask。</li>
<li>将 event loop 中正在运行的 task 设置为 null。</li>
<li>执行 microtasks 检查点（也就是执行 microtasks 队列中的任务）。</li>
<li>设置 hasARenderingOpportunity 为 false。</li>
<li>更新渲染。</li>
<li>如果当前是 window event loop 且 task queues 里没有 task 且 microtask queue 是空的，同时渲染时机变量 hasARenderingOpportunity 为 false ，去执行 idle period（requestIdleCallback）。</li>
<li>返回到第一步。</li>
</ol>
<p>大体上来说，event loop 就是不停地找 task queues 里是否有可执行的 task ，如果存在即将其推入到 call stack （执行栈）里执行，并且在合适的时机更新渲染。</p>
<p>下图 3（源）是 event loop 在浏览器主线程上运行的一个清晰的流程：</p>
<p><img src="/Users/lmelon/myGitHubMac/simple-read/https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca5ec835c88b4f89b06e0302bfe98a7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0..jpg alt=""></p>
<p>在上面规范的说明中，渲染的流程是在执行 microtasks 队列之后，更进一步，再来看看渲染的处理过程。</p>
<h2>requestAnimationFrame 的应用场景</h2>
<ul>
<li>大数据渲染
在大数据渲染过程中，比如表格的渲染，如果不进行一些性能策略处理，就会出现 UI 冻结现象，用户体验极差。有个场景，将后台返回的十万条记录插入到表格中，如果一次性在循环中生成 DOM 元素，会导致页面卡顿 5s 左右。这时候我们就可以用 <strong>requestAnimationFrame</strong> 进行分步渲染，确定最好的时间间隔，使得页面加载过程中很流畅。</li>
</ul>
<pre><code>var total = 100000;
var size = 100;
var count = total / size;
var done = 0;
var ul = document.getElementById('list');

function addItems() {
    var li = null;
    var fg = document.createDocumentFragment();

    for (var i = 0; i &lt; size; i++) {
        li = document.createElement('li');
        li.innerText = 'item ' + (done * size + i);
        fg.appendChild(li);
    }

    ul.appendChild(fg);
    done++;

    if (done &lt; count) {
        requestAnimationFrame(addItems);
    }
};
requestAnimationFrame(addItems);
</code></pre>
<ul>
<li>实现动画
css3 实现使得性能和流畅度都得到了很大的提升，但同时局限性也挺大比如不是所有的属性都能参与动画，动画过程不能完全控制，动画缓动效果太小等等。
setTimeout 和 setInterval 能达成更多的可控性质的自有帧动画，但是由于刷新时间和定时器时间不同会出现掉帧现象，定时器时间设的越短掉帧时间越严重，而且性能牺牲很严重
<strong>requestAnimationFrame</strong> 的出现让我们有了除了这两种我们常用的方案之外的另一种更优的选择</li>
</ul>

<h1>为什么面试官这么爱问性能优化？</h1><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7239267216805838903">juejin.cn</a></p>
<p>所以通常我硬着头皮只能说出以下这些：</p>
<ol>
<li>开发前会花点时间梳理业务，全局视角过一遍交互和视觉，思考组件划分，找出项目中相似的部分，提取为公共组件和通用逻辑。</li>
<li>代码开发中尽量保证写出的代码清晰、可维护，比如：清晰的目录和文件结构、添加必要的注释、提取公共函数公共组件、组件单向数据流、组件功能尽量单一等。</li>
<li>时刻关注可能会存在性能问题的部分，比如：</li>
</ol>
<p>缓存-frequency</p>
<ul>
<li>频繁切换的组件使用 KeepAlive 进行缓存</li>
<li>缓存复杂或常用的计算结果</li>
<li>对实时性不高的接口进行缓存
<ul>
<li>http 相关：
gzip 压缩
强缓存、协商缓存
on demand 加载</li>
</ul>
</li>
<li>路由组件异步加载，预加载</li>
<li>动态加载一些初始不需要用到的资源</li>
<li>懒加载列表，懒加载图，虚拟滚动</li>
<li>使用三方库或组件库尽量采用按需加载，减少打包体积
进程池</li>
<li>同一个接口多次请求时取消上一次没有完成的请求</li>
<li>对移出可视区的图片和 dom 进行销毁</li>
<li>对于一些频繁的操作使用防抖或节流</li>
<li>组件卸载时取消事件的监听、取消组件中的定时器、销毁一些三方库的实例
用户体验</li>
<li>对于一些确实比较慢的接口使用 loading 或骨架屏
优先级加载</li>
<li>页面中存在很多接口时进行优先级排序，优先请求页面重要信息的接口，并关注同一时刻请求的接口数量，如果过多进行分批请求
资源</li>
<li>关注页面中使用到的图片大小，推动后端进行图片压缩</li>
<li>雪碧图、使用字体图标、svg</li>
<li>tree shaking，分包，代码压缩
JS 单线程</li>
<li>复杂计算使用 web worker</li>
</ul>
<p>比如我开源的一个思维导图项目 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwanglin2%2Fmind-map" title="https://github.com/wanglin2/mind-map">mind-map</a>，
通过<code>svg</code>实现，所以就是 DOM 节点，当节点数量非常多以后，删除节点和创建节点都是非常耗时的，</p>
<ul>
<li>数据驱动视图的框架比如<code>Vue</code>会通过虚拟 DOM 的<code>diff</code>算法对比来找出最小的更新部分</li>
<li>将真实节点缓存起来，渲染时通过数据唯一的 id 来检查是否存在可复用节点，如果没有，那么代表是新增节点，那么创建新节点即可；如果有，那么就判断节点数据是否发生改变，没有改变直接复用，如果发生了改变那么判断是否可以进行更新，如果更新成本高那么直接重新创建；另外也需要和上一次的缓存进行对比，找出本次渲染不需要的节点进行删除；</li>
</ul>
<p>当然，为了避免缓存节点数量无限膨胀，也通过 LRU 缓存算法来管理
对于不影响其他节点的操作只更新被操作的节点
通过<code>setTimeout</code>异步渲染节点，留一些中间时间来响应页面其他操作
将触发渲染的任务放到队列中，在下一帧进行处理，合并掉一些中间状态</p>
<p>对于鼠标移动和滚动的场景，通过节流来优化</p>
<p>进行一些取舍，早期节点激活时可以修改节点的所有样式，导致激活操作需要重新计算节点大小，更新节点样式，在多选和全选操作下非常耗时，所以后期改为只允许修改不改变节点大小的样式属性</p>
<p>其他一些细节优化：对于数据没有改变的操作不触发赋值或函数调用，一些不起眼的操作可能也是需要耗费时间的；改变了不涉及节点大小的属性不触发节点大小重新计算等</p>

<h1>缓存与 CDN</h1><h2><strong>2. 为什么要使用缓存（Why）</strong></h2>
<p><strong>1）硬件层面：如 CPU 中的高速缓存</strong>
在 CPU 访问数据和指令遵循<strong>计算机系统的局部性原理</strong>：</p>
<ol>
<li><strong>时间局部性</strong>：CPU 通常使用的许多数据会被多次使用。</li>
<li><strong>空间局部性</strong>：CPU 使用的许多数据通常在物理上接近以前使用的数据。
<strong>使用高速缓存可以弥补 CPU 和内存之间的性能差异，减少 CPU 浪费计算时间等待内存数据。</strong></li>
</ol>
<p><strong>2）软件层面</strong></p>
<ol>
<li>为缓解 CPU 压力而做缓存：
<ol>
<li>比如把方法运行结果存储起来、把原本要实时计算的内容提前算好、把一些公用的数据进行复用，这可以节省 CPU 算力，顺带提升响应性能。</li>
</ol>
</li>
<li>为缓解 I/O 压力而做缓存：
<ol>
<li>比如把原本对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，将原本对单点部件（如数据库）的读写访问变为到可扩缩组件（如缓存中间件）的访问，顺带提升响应性能。</li>
</ol>
</li>
</ol>
<p><strong>3）产品层面</strong>
是否可以解决用户的痛点问题决定着用户会不会一开始尝试使用某款产品，是否有极致的用户体验影响用户会不会持续使用某款产品。</p>
<ul>
<li>在业务中使用缓存的目的就是通过<strong>扩大系统吞吐量、减少时延和响应时间来优化用户体验</strong>，适当的性能优化可以<strong>提升体验，增强用户粘性</strong>。</li>
</ul>
<h2><strong>3. 什么时候使用缓存（When）</strong></h2>
<ul>
<li>并非所有的业务场景都适合用缓存，<strong>读多写少、不要求一致性、时效要求越低、访问频率越高、对最终一致性和数据丢失有一定程度的容忍的场景才适合使用缓存</strong>，</li>
<li>缓存并不能解决所有的性能问题，倘若滥用缓存会带来额外的维护成本，使得系统架构更复杂更难以维护。</li>
</ul>
<h2>缓存前思考的问题</h2>
<p>虽然缓存适用于各种各样的案例，但要充分利用缓存，需要进行一定的规划。所以在决定是否缓存一段数据时，请考虑以下问题：</p>
<ul>
<li><strong>使用缓存值是否安全？</strong> 相同的数据在不同的上下文中可能有<strong>不同的一致性要求</strong>。例如电商系统中，在线结账期间，必须知道商品的确切价格，因此不适合使用缓存</li>
<li><strong>对于该数据而言，缓存是否高效？</strong> 某些应用程序会生成不适合缓存的访问模式；例如，扫描频繁变化的大型数据集的键空间。在这种情况下，保持缓存更新可能会抵消缓存带来的所有优势。</li>
<li>**数据结构是否适合缓存？**例如： 以单条数据库记录形式缓存数据通常足以提供显著的性能优势。但有些时候，数据最好以多条记录组合在一起的格式进行缓存。缓存以简单的键值形式存储，因此您可能还需要以多种不同格式缓存数据记录，以便按记录中的不同属性进行访问。</li>
</ul>
<p>另外把缓存当做存储来使用是一件极其致命的做法，这种错误的认识，将缓存引入系统的那一刻起就意味着已经让系统走上了危险的局面，<strong>只有对缓存的使用边界有深刻的理解，才能尽可能减少引入缓存带来的副作用。</strong></p>
<h1>缓存分类</h1>
<ol>
<li>客户端缓存
<ol>
<li>页面缓存</li>
<li>APP 缓存</li>
<li>浏览器缓存</li>
</ol>
</li>
<li>网络缓存</li>
</ol>
<h3><strong>1. 客户端缓存</strong></h3>
<p><strong>HTTP 协议的无状态性决定了它必须依靠客户端缓存来解决网络传输效率上的缺陷</strong>。由于每次请求都是独立的，服务端不保存此前请求的状态和资源，所以也不可避免地导致其携带有重复的数据，造成网络性能降低。HTTP 协议对此问题的解决方案便是客户端缓存。
常见的客户端缓存有如下几种：
<strong>1) 页面缓存</strong>
页面缓存是指将静态页面获取页面中的部分元素缓存到本地，以便下次请求不需要重复资源文件，
具体实现可通过页面指定 manifest 文件，当浏览器访问一个带有 manifest 属性的文件时，会先从应用缓存中获取加载页面的资源文件，并通过检查机制处理缓存更新的问题。
<strong>2) APP 缓存</strong>
APP 可以将内容缓存到内存或者本地数据库中，例如在一些开源的图片库中都具备缓存的技术特性，当图片等资源文件从远程服务器获取后会进行缓存，以便下一次不再进行重复请求，并可以减少用户的流量费用。
<strong>3) 浏览器缓存</strong>
浏览器缓存通常会专门开辟内存空间以存储资源副本，当用户后退或者返回上一步操作时可以通过浏览器缓存快速的获取数据，减少页面加载时间和带宽使用。在 HTTP 从 1.0 到 1.1，再到 2.0 版本的每次演进中，逐步形成了现在被称为 “状态缓存”、“强制缓存”（许多资料中简称为“强缓存”）和“协商缓存” 的 HTTP 缓存机制。在 HTTP 1.1 中通过引入 e-tag 标签并结合 expire、cache-control 两个特性能够很好的支持浏览器缓存。</p>
<h2>Etag</h2>
<p><strong>对于 Etag 的补充说明：</strong>
HTTP 服务器可以根据自己的意愿来选择如何生成这个标识，比如 Apache 服务器的 Etag 值默认是对文件的索引节点（INode），大小和最后修改时间进行哈希计算后得到的。
Etag 是 HTTP 中一致性最强的缓存机制，
Last-Modified 的问题</p>
<ul>
<li>标注的最后修改只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；</li>
<li>如果某些文件会被定期生成，可能内容并没有任何变化，但 Last-Modified 却改变了，导致文件无法有效使用缓存，
<strong>Etag 却又是 HTTP 中性能最差的缓存机制</strong>，体现在每次请求时，服务端都必须对资源进行哈希计算，这比起简单获取一下修改时间，开销要大了很多。Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内。</li>
</ul>
<h3>内容协商机制</h3>
<p>HTTP 的协商缓存机制已经能很好地处理通过 URL 获取单个资源的场景，
为什么要强调 “单个资源” 呢？
在 HTTP 协议的设计中，一个 URL 地址是有可能能够提供多份不同版本的资源，</p>
<ul>
<li>比如，一段文字的不同语言版本，一个文件的不同编码格式版本，一份数据的不同压缩方式版本，等等。</li>
<li>因此针对请求的缓存机制，也必须能够提供对应的支持。
为此，HTTP 协议设计了</li>
<li>以 Accept_（Accept、Accept-Language、Accept-Charset、Accept-Encoding）开头的一套请求 Header</li>
<li>对应的以 Content-（Content-Language、Content-Type、Content-Encoding）开头的响应 Header，</li>
</ul>
<p>-这些 Headers 被称为 HTTP 的内容协商机制。因此对于一个 URL 能够获取多个资源的场景中，缓存也同样也需要有明确的标识来获知根据什么内容来对同一个 URL 返回给用户正确的资源。这就是 Vary Header 的作用</p>
<ul>
<li>Vary 后面应该跟随一组其他 Header 的名字</li>
</ul>
<pre><code>HTTP/1.1 200 OK
Vary: Accept, User-Agent
</code></pre>
<p>以上响应的含义是应该根据 MIME 类型和浏览器类型来缓存资源，获取资源时也需要根据请求 Header 中对应的字段来筛选出适合的资源版本。</p>
<h2>正向代理和反向代理</h2>
<p>正向代理其实就是：源服务器感知不到客户端的存在，隐藏了客户端
那正向代理有什么作用呢？</p>
<ul>
<li>提高访问速度：通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</li>
<li>控制对内部资源的访问：如某大学 FTP（前提是该代理地址在该资源的允许访问范围之内）使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类 FTP 下载上传，以及各类资料查询共享等服务。</li>
<li>过滤、调整内容：例如限制对特定计算机的访问、压缩请求包、改变请求包的语言格式等。</li>
<li>隐藏真实 IP：通过代理服务器隐藏自己的 IP，但更安全的方法是利用特定的工具创建代理链</li>
<li>突破网站的区域限制：通过代理服务器访问一些被限制的网站。</li>
</ul>
<p>反向代理就是：隐藏了源服务器
反向代理</p>
<ul>
<li>负载均衡：若服务器集群中有机器负荷较高，反向代理通过 URL 重写，把请求转移到低负荷机器获取与所需相同的资源。</li>
</ul>
<ul>
<li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务。</li>
<li>安全：作为应用层防火墙，为服务器提供基于 Web 的攻击行为（例如 DoS/DDoS）的防护，更容易排查恶意软件等</li>
<li>为后端服务器（集群）统一提供加密和 SSL 加速（如 SSL 终端代理）。</li>
<li>对一些内容进行压缩，以节约带宽或为带宽不佳的网络提供正常服务。</li>
<li>提供 HTTP 访问认证。</li>
</ul>
<h2>网络缓存</h2>
<p><strong>网络缓存位于客户端以及服务端中间，通过代理的方式解决数据请求的响应，降低数据请求的回源率</strong>。回源率又分为以下两种：</p>
<ul>
<li><strong>回源流量比</strong>：回源流量是代理服务器节点请求源服务器资源时产生流量。回源流量比 = 回源流量 /（回源流量 + 用户请求访问的流量），比值越低，性能越好。</li>
<li><strong>回源请求数比</strong>：指代理服务器节点对于没有缓存、缓存过期（可缓存）和不可缓存的请求占全部请求记录的比例。</li>
</ul>
<p>网络缓存常见的代理形式分为两种：web 代理缓存、边缘缓存。</p>
<ul>
<li>web 代理缓存通常是
<ul>
<li>指正向代理，会将资源文件和热点数据放在代理服务器上，当新的请求到来时，如果在代理服务器上能获取数据，则不需要重复请求到应用服务器上。</li>
</ul>
</li>
<li>边缘缓存：和正向代理一样，反向代理同样可以用于缓存，例如 nginx 就提供了缓存的功能。
<ul>
<li>进一步，如果这些反向代理服务器能够做到和用户请求来自同一个网络，那么获取资源的速度进一步提升，这类的反向代理服务器可以称之为边缘缓存。常见的边缘缓存就是内容分发网络（Content Delivery Network），简称 CDN。可以将图片等静态资源文件放到 CDN 上。</li>
</ul>
</li>
</ul>
<h2>DNS解析过程</h2>
<ol>
<li>加一个. ,它是 “<code>.root</code>” 的含义。早期的域名必须带有这个点才能被 DNS 正确解析</li>
<li>先检查本地的 DNS 缓存，查看是否存在并且是存活着的该域名的地址记录。
<ol>
<li>DNS 是以<a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间</a>（Time to Live，TTL）来衡量缓存的有效情况的，</li>
<li>后续每一级 DNS 查询的过程都会有类似的缓存查询操作</li>
</ol>
</li>
<li>客户端将地址发送给本机操作系统中配置的本地 DNS（Local DNS）
<ol>
<li>手工配置 or DHCP 分配</li>
</ol>
</li>
<li>会按照 “是否有 <a href="https://www.zhihu.com/question/www.wallbig.club.cn">www.wallbig.club.cn</a> 的权威服务器”→“是否有 wallbig.club.cn 的权威服务器”→“是否有 club.cn 的权威服务器”→“是否有 cn 的权威服务器” 的顺序，依次查询自己的地址记录
<ol>
<li>地址记录并不一定就是指 IP 地址，在 RFC 规范中有定义的地址记录类型已经多达数十种，比如 IPv4 下的 IP 地址为 A 记录，IPv6 下的 AAAA 记录、每种记录类型中还可以包括多条记录</li>
<li>权威服务器可以根据自己的策略来进行选择最优的</li>
</ol>
</li>
<li>如果都没有查询到，就会一直找到最后点号代表的根域名服务器为止。这个步骤里涉及了两个重要名词</li>
</ol>
<p><strong>权威域名服务器</strong>（Authoritative DNS）：是指负责翻译特定域名的 DNS 服务器，“权威” 意味着这个域名应该翻译出怎样的结果是由它来决定的。
<strong>根域名服务器</strong>（Root DNS）是指固定的、无需查询的<a href="https://en.wikipedia.org/wiki/Top-level_domain">顶级域名</a>（Top-Level Domain）服务器，可以默认为它们已内置在操作系统代码之中。全世界一共有 13 组根域名服务器
13 这个数字是由于 DNS 主要采用 UDP 传输协议来进行数据交换，未分片的 UDP 数据包在 IPv4 下最大有效值为 512 字节，最多可以存放 13 组地址记录</p>
<p>专门有一种被称为 “<a href="https://en.wikipedia.org/wiki/Link_prefetching">DNS 预取</a>”（DNS Prefetching）的前端优化手段用来避免这类问题：如果网站后续要使用来自于其他域的资源，那就在网页加载时生成一个 link 请求，促使浏览器提前对该域名进行预解释，比如下面代码所示：</p>
<pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//domain.not-wallbig.club&quot;&gt;
</code></pre>
<h2>CDN 利用场景</h2>
<p>主要包括路由解析、内容分发,负载均衡、CDN 的利用场景
CDN 路由提前准备</p>
<ol>
<li>架设好 “<code>wallbig.club</code>” 的服务器后，将服务器的 IP 地址在你的 CDN 服务商上注册为 “源站”，注册后你会得到一个 CNAME，即本例中的 “<code>wallbig.club.cdn.dnsv1.com.</code>”。</li>
<li>将得到的 CNAME 在你购买域名的 DNS 服务商上注册为一条 CNAME 记录。
<strong>一、路由解析</strong></li>
<li>如果没有缓存的话，都会先经过 DNS 服务器的解析翻译，找到域名对应的 IP 地址
<ol>
<li>操作系统自动完成的</li>
</ol>
</li>
<li>当第一位用户来访你的站点时，将首先发生一次未命中缓存的 DNS 查询，域名服务商解析出 CNAME 后，返回给本地 DNS，至此之后链路解析的主导权就开始由内容分发网络的调度服务接管了。</li>
<li>本地 DNS 查询 CNAME 时，由于能解析该 CNAME 的权威服务器只有 CDN 服务商所架设的权威 DNS，这个 DNS 服务将根据一定的均衡策略和参数，如拓扑结构、容量、时延等，在全国各地能提供服务的 CDN 缓存节点中挑选一个最适合的，将它的 IP 代替源站的 IP 地址，返回给本地 DNS。</li>
<li>浏览器从本地 DNS 拿到 IP 地址，将该 IP 当作源站服务器来进行访问，此时该 IP 的 CDN 节点上可能有，也可能没有缓存过源站的资源，这点将在下面的 <strong>“内容分发”</strong> 小节讨论。</li>
<li>经过内容分发后的 CDN 节点，就有能力代替源站向用户提供所请求的资源。</li>
</ol>
