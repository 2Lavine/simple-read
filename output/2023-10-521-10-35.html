<h1>2023-10-01</h1><p>#js/string
js当中string.indexOf 方法返回一个字符串中指定值的第一个匹配项的索引。
indexOf 的第二个参数是搜索的起始索引。
在这个例子中，我们将 start 作为 indexOf 的第二个参数传递，这意味着搜索将从紧随 str1 结束的索引开始。这是因为我们想要在 str1 后找到第一个 str2 的匹配项。</p>
<h2>DRY: don’t repeat yourself</h2>
<p>Shared code among services results in coupling
A general rule of thumb: don’t violate DRY within a service, but be relaxed about violating DRY across services</p>

<h1>2023-10-02</h1><h2>翻转链表</h2>
<p>定义pre,cur=&gt;四步翻转
temp=cur.next
cur.next=pre
pre=cur
cur=temp
#python</p>
<h2>遍历节点</h2>
<p>想要移动到最后一个节点或者不遍历最后一个节点： while cur.next:
想要遍历完最后一个节点:     while cur:</p>
<h1>DDD</h1>
<p>在领域驱动设计（DDD）中，有两个层次的设计，分别是战略设计（Strategy Design）和战术设计（Tactical Design）。</p>
<h3>战略设计（Strategy Design）：</h3>
<p>战略设计是在领域驱动设计的早期阶段进行的，它关注的是整体的架构和组织</p>
<ul>
<li>Bounded Contexts（界限上下文）</li>
<li>Ubiquitous Language（通用语言）：确保开发团队和领域专家之间使用相同的术语和概念进行沟通和理解。通过共享通用语言，可以减少误解和偏差，提高开发效率和软件质量。</li>
<li>Context Mapping（上下文映射）：定义不同上下文之间的关系和交互方式。这包括确定上下文之间的合作关系、共享的模型和接口，并解决不同上下文之间的一致性和集成问题。</li>
<li>大胆的设计决策：在战略设计中，可以进行一些重要的设计决策，例如选择适合系统需求的架构模式、技术栈和持久化策略等。这些决策将在战术设计中指导具体的实现。</li>
</ul>
<h3>战术设计（Tactical Design）：</h3>
<p>战术设计是在战略设计之后，更接近具体实现的阶段。</p>
<ul>
<li>领域模型（Domain Model）：领域模型是对业务领域的抽象和建模，它包含了业务概念、规则和流程。领域模型是软件系统的内核，它反映了业务需求和领域知识。</li>
<li>领域服务（Domain Service）：领域服务是一些与领域相关的操作或行为，它们不属于特定的领域对象，而是为领域模型提供一些通用的功能。</li>
<li>聚合（Aggregate）：聚合是一组相关对象的集合，用于管理聚合内的对象和维护聚合的一致性。</li>
<li>聚合根（Aggregate Root）：聚合根是聚合中的一个特殊对象，它是聚合的入口点和唯一访问点。通过聚合根，可以保证聚合的一致性和完整性。</li>
<li>实体（Entity）：实体是具有唯一标识的领域对象，通常代表业务中的重要概念，例如订单、用户等。</li>
<li>值对象（Value Object）：值对象是没有唯一标识的领域对象，它通过其属性来定义其身份。值对象通常是不可变的，用于表示一些具体的属性或组合。</li>
</ul>
<h3>DDD使用例子</h3>
<p>用领域驱动设计内核概念的例子：
首先，我们需要定义领域模型，即确定哪些概念在系统中是重要的。在这个例子中，我们可以确定商品、购物车和订单是内核概念。</p>
<p>接下来，我们可以定义商品对象作为一个实体。商品具有唯一标识、名称、价格等属性。我们可以为商品定义相应的行为，例如计算商品的折扣价格或更新商品信息。</p>
<p>然后，我们可以定义购物车对象作为一个聚合。购物车可以包含多个商品，因此购物车可以被看作是一个聚合，而购物车中的每个商品可以看作是聚合中的实体。购物车可以管理商品的添加、删除和数量的修改等操作。</p>
<p>在购物车中，我们可能需要使用值对象来表示商品的数量。值对象是没有唯一标识的对象，我们可以使用商品的ID和数量来定义一个值对象，以便在购物车中管理商品的数量。</p>
<p>最后，当用户确认购买时，我们可以创建订单对象。订单可以包含购物车中的商品和相应的数量，以及其他订单信息，例如用户信息、支付信息等。订单可以作为一个聚合根，通过订单来管理购物车中的商品和生成相应的订单。</p>
<h3>将软件系统划分为Bounded Contexts和使用Ubiquitous Language的原因：</h3>
<ul>
<li>
<p>复杂性管理：通过将系统划分为较小的Bounded Contexts，可以将复杂性分解为更小的、相对独立的部分，从而更容易管理和理解系统。</p>
</li>
<li>
<p>领域专注：每个Bounded Context都关注于特定的领域或子系统，开发团队可以更专注地处理该领域的业务需求和问题。</p>
</li>
<li>
<p>解耦合：通过明确定义每个Bounded Context的边界和接口，可以实现不同上下文之间的解耦合。这样，当一个上下文需要进行更改或升级时，对其他上下文的影响将被最小化，从而提高系统的灵活性和可维护性。</p>
</li>
<li>
<p>共享理解：通过使用Ubiquitous Language，开发团队和领域专家之间可以共享同一套术语和概念，从而确保在开发过程中的沟通和理解的准确性。</p>
</li>
</ul>

<h1>2023-10-03</h1><p><code>WORKDIR /usr/src/app</code>是Dockerfile中的一个指令，用于设置Docker容器的工作目录。</p>
<p>在Docker容器中，工作目录是指在容器内部执行命令时的默认路径。通过使用<code>WORKDIR</code>指令，可以设置容器中的工作目录，使得在容器中执行的命令可以相对于该目录进行操作。</p>
<p>在给定的例子中，<code>WORKDIR /usr/src/app</code>将容器的工作目录设置为<code>/usr/src/app</code>。这意味着，当在容器中执行命令时，会默认在<code>/usr/src/app</code>目录下执行。</p>
<p>设置工作目录的好处在于：</p>
<ol>
<li>简化命令：由于工作目录已经设置好，执行命令时可以使用相对路径，而无需使用完整的绝对路径。</li>
<li>代码管理：将项目文件和依赖项放在工作目录下，可以更好地组织和管理代码。</li>
<li>容器化应用：对于容器化的应用程序，可以将应用程序的代码和依赖项放在工作目录下，并在容器中设置工作目录，从而实现代码和环境的隔离。</li>
</ol>
<p>总之，<code>WORKDIR</code>指令用于设置Docker容器的工作目录，方便在容器中执行命令时操作文件和路径。</p>
<h2>Rest APi补充</h2>
<p>Use kebab-case for resource names that have more than one word</p>
<hr>
<p>•400: Bad request (client should modify the request)
•401: Unauthorized, credentials not recognized
•403: Forbidden, credentials accepted but don’t have permission</p>
<hr>
<p>•201: Successful request after a create, usually a POST
•204: Successful request with no content returned, usually a PUT or PATCH</p>
<h2>RestFul API 的等级</h2>
<ul>
<li>RPC</li>
<li>resources</li>
<li>Http verbs</li>
<li>Hateoas</li>
</ul>
<h2>Patch和 Post 的区别</h2>
<ol>
<li>语义不同：PUT 方法用于完全替换指定的资源，而 PATCH 方法用于对资源进行部分更新。PUT 方法要求客户端提供完整的资源表述，而 PATCH 方法仅需要提供需要更新的部分。</li>
<li>请求体内容：PUT 请求的请求体中应包含完整的资源表述，即包含所有字段和属性的完整数据。而 PATCH 请求的请求体中仅包含需要更新的字段和属性的数据。</li>
<li>幂等性：PUT 请求是幂等的，即多次相同的 PUT 请求最终的结果是相同的。而 PATCH 请求不一定是幂等的，多次相同的 PATCH 请求可能会导致不同的结果。</li>
<li>安全性：PUT 请求可能会对资源进行创建或修改操作，因此可能会对服务器上的数据产生更大的影响。而 PATCH 请求通常用于对资源进行局部修改，对服务器上的数据影响较小。</li>
</ol>
<h2>Headers</h2>
<p>POST/paths       http          1.1
http 1.1               203          OK</p>
<h3>请求头压缩</h3>
<p>Accept-Encoding: gzip</p>
<h2>GraphQL 而不是RESTFUI API</h2>
<p>GraphQL查询可以减少网络延迟和请求次数，提高应用的性能。同时，客户端可以根据实际需求来精确获取所需的数据，而不需要获取整个资源或多个资源，避免了过度获取和欠获取数据的问题。</p>
<p>假设我们有一个电影数据库，并且有以下资源和关系：</p>
<ul>
<li>Movie（电影）：包含id、title、releaseYear、director和actors等字段。</li>
<li>Actor（演员）：包含id、name和age等字段。</li>
<li>Director（导演）：包含id、name和nationality等字段。</li>
</ul>
<p>使用RESTful API的方式，我们可能需要多次请求来获取相关数据。例如，要获取电影的标题、导演和演员列表，我们可能需要先请求电影资源，然后根据返回的导演ID和演员ID再分别请求导演和演员资源。</p>
<p>使用GraphQL的方式，我们可以使用一次查询来获取所需的数据，如下所示：</p>
<pre><code class="language-graphql">query {
  movie(id: &quot;1&quot;) {
    title
    director {
      name
      nationality
    }
    actors {
      name
      age
    }
  }
}
</code></pre>
<p>通过这个查询，我们可以一次性获取电影的标题、导演的姓名和国籍，以及演员的姓名和年龄，而不需要多次请求。</p>
<p>这样的查询可以减少网络延迟和请求次数，提高应用的性能。同时，客户端可以根据实际需求来精确获取所需的数据，而不需要获取整个资源或多个资源，避免了过度获取和欠获取数据的问题。</p>
<hr>
<p>hateoas
Idempotent 幂等
ephemeral 暂时的</p>
<hr>
<p>只有 post和Patch 不是Idempotent的</p>
<hr>
<p>elapsed time 实际运行时间</p>

<h1>2023-10-04</h1><p>#Microservices</p>
<h2>Microservices : Service Registery</h2>
<p>Service Registry Just Internal DNS
for a service to find another service</p>
<p>#DevOps/Strategy</p>
<h2>DevOps Deployment Strategies</h2>
<p>Recreate: Version A terminated then version B is rolled out
Ramped: Version B is slowly rolled out and replacing version A</p>
<h3>Deployment Strategies</h3>
<p>Blue/Green</p>
<ul>
<li>Version B is released alongside version A</li>
<li>Version B is deployed at the same time as version A, then after Version B is confirmed work right the traffic is switched to version B
A/B Testing</li>
<li>Version B is released to a subset of users under specific condition</li>
</ul>
<h3>Strategies  Deploy</h3>
<p>Shadow</p>
<ul>
<li>Version V receives real world traffic alongside version A and doesn’t impact the response</li>
<li>Helps evaluate the performance and stability of new versions without actually switching users to the new version.
Canary</li>
<li>Version B is released to a subset of users（normally inner staff）, then proceed to a full rollout
Rolling update</li>
<li>progressively replace Another Version without downtime
Ramped（逐步）
rollout 首次展示，退出</li>
</ul>
<h2>tombstoned</h2>
<p>Deletes are tombstoned
just marking the row as “deleted” but not physically deleting</p>
<h2>Scaling</h2>
<p>#Database/scaling
add Caching layer to imporve read(only read when miss) and write(write faster)
cons:</p>
<h2>Scaling Writing</h2>
<p>#Database/scaling/Writing
A shard is a subset of data
per shard has one primary zoom
Partitioning of data acrossseveral machines</p>
<h2>CAP</h2>
<p>#Database/distribute
在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三个属性无法同时完全实现，
partition tolerance: 在网络分区发生故障时，能够继续正常运行，并且在分区解决后能够自动进行数据的同步和一致性恢复</p>
<h3>Two-phase commit and Saga pattern</h3>
<p>两阶段提交协议和Saga pattern都可以用于处理分布式事务。两阶段提交协议通过协调者的角色来保证所有参与者的一致性，而Saga pattern通过拆分事务为多个步骤并记录回滚操作来保证一致性。选择哪种方式取决于具体的业务需求和系统设计。</p>
<h3>两阶段提交（Two-Phase Commit）协议：</h3>
<ul>
<li>准备阶段：在这个阶段，协调者（事务管理器）向库存服务和支付服务发送准备请求。库存服务会检查商品的库存是否足够，并将准备就绪的状态记录到日志中；支付服务会检查用户账户余额是否足够，并将准备就绪的状态记录到日志中。如果两个服务都准备就绪，它们会向协调者发送准备就绪的回复。</li>
<li>提交阶段：在这个阶段，协调者根据接收到的回复决定是否提交或回滚事务。如果两个服务都回复了准备就绪的消息，协调者会向库存服务和支付服务发送提交请求。库存服务会将商品库存减少，并将结果持久化；支付服务会从用户账户扣款，并将结果持久化。如果两个服务都成功提交了事务，它们会向协调者发送提交完成的回复。</li>
<li>如果有任何一个服务回复了准备失败的消息，或者协调者在等待回复超时时出现错误，协调者会向两个服务发送回滚请求，恢复库存和取消支付。</li>
</ul>
<h3>Saga pattern：</h3>
<p>在Saga pattern中，将整个购物过程拆分为多个Saga步骤，每个步骤对应一个服务的操作。每个步骤都有自己的回滚操作，以便在发生错误时可以回滚到之前的状态。</p>
<ul>
<li>创建订单步骤：在这个步骤中，库存服务会检查商品的库存是否足够，并将商品从库存中减少。如果库存足够，订单会被创建，并记录到日志中；如果库存不足，订单创建失败，并记录到日志中。</li>
<li>支付步骤：在这个步骤中，支付服务会检查用户账户余额是否足够，并从用户账户扣款。如果支付成功，订单状态会更新为已支付，并记录到日志中；如果支付失败，订单状态会更新为支付失败，并记录到日志中。</li>
</ul>
<p>如果所有的Saga步骤都成功执行，订单会被确认并完成购物过程。如果任何一个步骤失败，Saga会根据每个步骤的回滚操作来恢复到之前的状态，例如回滚库存和取消支付。</p>
<h2>forName和 new Class()的区别</h2>
<p>#java/reflect
<code>Class.forName(className)</code> 可以通过类的名称获取类对象，是因为在Java中，类的名称是类的唯一标识符。
当我们使用 <code>Class.forName(className)</code> 方法时，它会尝试加载并返回与给定类名对应的类对象。这个方法会根据类名查找并加载类的字节码，然后返回表示该类的 <code>Class</code> 对象。</p>
<p>类的名称是由包名和类名组成的，使用全限定名来表示。例如，&quot;com.example.UserService&quot; 就是一个类的全限定名。当我们通过 <code>Class.forName(className)</code> 方法传入这个全限定名时，它会根据类路径查找并加载这个类的字节码文件，然后返回对应的 <code>Class</code> 对象。</p>
<p>需要注意的是，<code>Class.forName(className)</code> 方法在加载类时还会执行类的静态代码块，因此，如果类中有静态代码块或静态成员需要初始化，这些静态代码块会在调用 <code>Class.forName(className)</code> 方法时执行。</p>
<p>总而言之，通过 <code>Class.forName(className)</code> 方法，我们可以通过类的全限定名来获取类对象，从而进行反射操作。这种方式使得我们可以在运行时动态地加载和使用类，增加了程序的灵活性和扩展性。</p>
<h2>Class.forName</h2>
<p>#java/reflect
<code>Class.forName(className)</code> 可以通过类的名称获取类对象，是因为在Java中，类的名称是类的唯一标识符。</p>
<p>当我们使用 <code>Class.forName(className)</code> 方法时，它会尝试加载并返回与给定类名对应的类对象。这个方法会根据类名查找并加载类的字节码，然后返回表示该类的 <code>Class</code> 对象。</p>
<p>类的名称是由包名和类名组成的，使用全限定名来表示。例如，&quot;com.example.UserService&quot; 就是一个类的全限定名。当我们通过 <code>Class.forName(className)</code> 方法传入这个全限定名时，它会根据类路径查找并加载这个类的字节码文件，然后返回对应的 <code>Class</code> 对象。</p>
<p>需要注意的是，<code>Class.forName(className)</code> 方法在加载类时还会执行类的静态代码块，因此，如果类中有静态代码块或静态成员需要初始化，这些静态代码块会在调用 <code>Class.forName(className)</code> 方法时执行。</p>
<p>总而言之，通过 <code>Class.forName(className)</code> 方法，我们可以通过类的全限定名来获取类对象，从而进行反射操作。这种方式使得我们可以在运行时动态地加载和使用类，增加了程序的灵活性和扩展性。</p>
<hr>
<p>#English
cons：缺点
pros： 优点
ransomNote: 赎金</p>

<h1>2023-10-05</h1><p>无论是在 py还是在 js 中
sort ，reverse 方法都是改变数组本身的顺序</p>

<h1>Python set sort dic</h1><h2>Python中的 set</h2>
<p>#python/set
直接用 newset=set(arr1)就可以
my_set = {1, 2, 3}
增加和删除元素 my_set.add(4) set.remove(4)
测试是否在   if 4 in my_set
集合的方法  union intersection difference</p>
<h2>Python中的dict ionary</h2>
<p>#python/dict
用{}或者 dict()来声明</p>
<h2>Python 中的 sort</h2>
<p>#python/内置函数
如果要按照元素的大小进行降序排序，可以使用sort()方法的reverse参数：</p>
<pre><code class="language-python">nums = [3, 1, 4, 2, 5]
nums.sort(reverse=True)
print(nums)  # 输出：[5, 4, 3, 2, 1]
</code></pre>
<p>如果要对列表中的元素进行自定义排序，可以使用sort()方法的key参数来指定排序的依据。key参数接收一个函数，该函数将对列表中的每个元素进行处理，并返回一个用于排序的值。例如，按照元素的绝对值进行排序：</p>
<pre><code class="language-python">nums = [-3, 1, -4, 2, 5]
nums.sort(key=abs)
print(nums)  # 输出：[1, 2, -3, -4, 5]
</code></pre>
<p>需要注意的是，sort()方法只适用于可排序的元素类型，例如数字、字符串等。对于自定义的对象，可以通过在对象类中实现__lt__方法来定义排序规则，然后使用sort()方法进行排序。</p>

<h1>Python 字典</h1><p>#python/dict</p>
<h2>Python 的字典是可以比较的</h2>
<p>是的，两个字典可以直接使用相等运算符==
进行比较。当且仅当两个字典的键和对应的值都相等时，比较结果才为True。</p>
<p>示例：</p>
<pre><code class="language-python">dict1 = {'a': 1, 'b': 2, 'c': 3}
dict2 = {'a': 1, 'b': 2, 'c': 3}
dict3 = {'a': 1, 'b': 2, 'c': 4}

print(dict1 == dict2)  # 输出: True
print(dict1 == dict3)  # 输出: False
</code></pre>
<p>在上述示例中，dict1和dict2的键和对应的值都相等，所以比较结果为True。而dict1和dict3的键相等，但值不相等，所以比较结果为False。</p>
<p>因此，在代码中使用<code>sDir == tDir</code>来比较两个字典是否相等是合法的。如果两个字典的键和对应的值都相等，则返回True；否则返回False。</p>
<h2>Python字典计算和</h2>
<p>sum(sDir.values())是Python内置函数sum()的用法，用于计算字典中所有值的总和。</p>
<p>具体来说，sDir.values()返回一个可迭代对象，其中包含字典sDir中所有的值。然后，sum()函数将这些值相加，得到它们的总和。</p>
<h2>遍历数组除第一个之外的其他元素</h2>
<p>words[1:]表示从列表words的第二个元素开始，截取到列表末尾的部分。这样可以得到一个新的列表，其中包含了除第一个元素外的所有元素。在这种情况下，我们使用words[1:]来遍历除第一个单词外的所有单词。
for word in words[1:]:</p>
<h2>Python中的 ASCII 码</h2>
<p>使用ord(letter) - ord('a')来计算差值。
用 chr 把 ASCII码转成字符</p>

<h1>ref.current 属性赋值</h1><h2>ref.current 属性赋值</h2>
<p>在 render 阶段，会调用 markRef 为 fiber 节点添加 Ref 副作用。
在 commit 阶段，React 会判断 fiber 是否具有 Ref 副作用，如果有，则为 fiber.ref 设置 current 值。</p>
<h3>Ref 操作有关的阶段</h3>
<p>在<a href="https://raw.githubusercontent.com/lizuncong/mini-react/master/docs/render/%E6%B7%B1%E5%85%A5%E6%A6%82%E8%BF%B0%20React%E5%88%9D%E6%AC%A1%E6%B8%B2%E6%9F%93%E5%8F%8A%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E4%B8%BB%E6%B5%81%E7%A8%8B.md">深入概述 React 初次渲染及状态更新主流程</a>中介绍过，commit 分为三个小阶段：</p>
<ul>
<li>commitBeforeMutationEffects</li>
<li>commitMutationEffects</li>
<li>commitLayoutEffects
与 Ref 操作有关的阶段只有<code>commitMutationEffects</code>以及<code>commitLayoutEffects</code></li>
</ul>
<pre><code class="language-js">function commitRootImpl(root, renderPriorityLevel) {
  //...
  commitBeforeMutationEffects();
  //...
  commitMutationEffects(root, renderPriorityLevel);
  //...
  commitLayoutEffects(root, lanes);
  //...
}
</code></pre>
<h3>commitMutationEffects：重置 ref 为 null</h3>
<p><code>commitMutationEffects</code>主要是执行节点的增删改操作，
在执行这些操作之前，会先调用 commitDetachRef 重置 ref。
然后根据 flag 执行不同的操作</p>
<pre><code class="language-js">function commitMutationEffects(root, renderPriorityLevel) {
  while (nextEffect !== null) {
    var flags = nextEffect.flags;
    if (flags &amp; Ref) {
      var current = nextEffect.alternate;
      if (current !== null) {
        commitDetachRef(current);
      }
    }
    var primaryFlags = flags &amp; (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case Deletion: {
        commitDeletion(root, nextEffect);
        break;
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
</code></pre>
<h3>commitDeletion操作</h3>
<p>这里，删除节点（commitDeletion）的操作比较特殊，
commitDeletion 最终会调用 commitUnmount 卸载节点
在 commitUnmount 中会调用 safelyDetachRef 小心的重置 ref 为 null</p>
<pre><code class="language-js">function commitUnmount(finishedRoot, current, renderPriorityLevel) {
  onCommitUnmount(current);
  switch (current.tag) {
    case ClassComponent: {
      safelyDetachRef(current);
      var instance = current.stateNode;
      if (typeof instance.componentWillUnmount === &quot;function&quot;) {
        safelyCallComponentWillUnmount(current, instance);
      }
      return;
    }
    case HostComponent: {
      safelyDetachRef(current);
      return;
    }
  }
}
</code></pre>
<h3>safelyDetachRef</h3>
<p>现在版本用的是 safelyDetachRef</p>
<pre><code class="language-jsx">function commitDetachRef(current) {
  var currentRef = current.ref;
  if (currentRef !== null) {
    if (typeof currentRef === &quot;function&quot;) {
      currentRef(null);
    } else {
      currentRef.current = null;
    }
  }
}

function safelyDetachRef(current) {
  var ref = current.ref;
  if (ref !== null) {
    if (typeof ref === &quot;function&quot;) {
      try {
        ref(null);
      } catch (refError) {
        captureCommitPhaseError(current, refError);
      }
    } else {
      ref.current = null;
    }
  }
}
</code></pre>
<h3>commitLayoutEffects：为 ref 设置新值</h3>
<p>commitLayoutEffects 会判断 fiber 是否具有 Ref 副作用，
如果有，则调用 commitAttachRef 设置 ref 的新值</p>
<pre><code class="language-js">function commitLayoutEffects(root, committedLanes) {
  while (nextEffect !== null) {
    var flags = nextEffect.flags;
    if (flags &amp; Ref) {
      commitAttachRef(nextEffect);
    }
    nextEffect = nextEffect.nextEffect;
  }
}
</code></pre>
<h2>commitAttachRef</h2>
<p>commitAttachRef 主要就是设置 ref 的值，
这里会判断 ref 属性是否是函数，如果是函数，则执行。否则直接设置 ref.current 属性</p>
<pre><code class="language-js">function commitAttachRef(finishedWork) {
  var ref = finishedWork.ref;
  if (ref !== null) {
    var instance = finishedWork.stateNode;
    if (typeof ref === &quot;function&quot;) {
      ref(instance);
    } else {
      ref.current = instance;
    }
  }
}
</code></pre>
<h2>useImperativeHandle</h2>
<h3>useImperativeHandle   render 阶段</h3>
<p>在 render 阶段，执行函数调用 useImperativeHandle 时，React 会为 forwardRef 创建一个 imperativeHandle 类型的 Effect 对象，并添加到 updateQueue 队列中，如下：</p>
<pre><code class="language-js">function imperativeHandleEffect(create, ref) {
  if (typeof ref === &quot;function&quot;) {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      // 注意这里会返回一个函数!!!
      refCallback(null);
    };
  } else if (ref !== null &amp;&amp; ref !== undefined) {
    var refObject = ref;

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}
const imperativeEffect = {
  create: imperativeHandleEffect,
  deps: null,
  destroy: undefined,
  next: null,
  tag: 3,
};
imperativeEffect.next = imperativeEffect;

fiber.updateQueue = {
  lastEffect: imperativeEffect,
};
</code></pre>
<h4>useImperativeHandle例子</h4>
<p>以下面的代码为例：</p>
<pre><code class="language-jsx">const FunctionCounter = (props, ref) =&gt; {
  const createInst = () =&gt; ({
    focus: () =&gt; {
      console.log(&quot;focus...&quot;);
    },
  });
  useImperativeHandle(ref, createInst);
  return &lt;div&gt;{`计数器：${props.count}`}&lt;/div&gt;;
};

const ForwardRefCounter = React.forwardRef(FunctionCounter);
</code></pre>
<p><code>imperativeHandleEffect(create, ref)</code>中的
第一个参数<code>create</code>对应中的第二个参数<code>createInst</code>。
第二个参数<code>ref</code>对应第一个参数`ref</p>
<blockquote>
<p>注意，这里我们用 React.forwardRef 包裹 FunctionCounter，React 会为 forwardRef 创建一个 fiber 节点，但不会为 FunctionCounter 创建一个 fiber 节点。因此 render 阶段执行的工作是针对 forwardRef 类型的 fiber 节点</p>
</blockquote>
<h3>commitLayoutEffects 阶段：设置 ref.current 的值</h3>
<p>当finishedWork的tag为ForwardRef时，会调用commitHookEffectListMount函数，
这个函数会遍历fiber.updateQueue的effect队列，然后执行effect.create方法，
effect.create这个方法就是我们前面提到的imperativeHandleEffect方法。</p>
<pre><code class="language-js">function commitLifeCycles(current, finishedWork) {
  switch (finishedWork.tag) {
    case ForwardRef: {
      commitHookEffectListMount(Layout | HasEffect, finishedWork);
      return;
    }
  }
}
function commitHookEffectListMount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag &amp; tag) === tag) {
        // Mount
        var create = effect.create;
        effect.destroy = create(); // 调用effect.create
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
const imperativeEffect = {
  create: imperativeHandleEffect,
	...
};
</code></pre>
<h3>imperativeHandleEffect</h3>
<p>这个函数会根据ref的类型（函数或对象）来创建一个实例，并将这个实例赋值给ref。
同时，这个函数会返回一个函数，这个函数用来重置ref.current属性为null。
返回函数会在 commitMutationEffects 阶段执行</p>
<pre><code class="language-js">function imperativeHandleEffect(create, ref) {
  if (typeof ref === &quot;function&quot;) {
    var refCallback = ref;

    var _inst = create();

    refCallback(_inst);
    return function () {
      // 注意这里会返回一个函数!!!
      refCallback(null);
    };
  } else if (ref !== null &amp;&amp; ref !== undefined) {
    var refObject = ref;

    var _inst2 = create();

    refObject.current = _inst2;
    return function () {
      refObject.current = null;
    };
  }
}
</code></pre>
<h3>commitMutationEffects 阶段：重置 ref.current 为 null</h3>
<p>commitMutationEffects 阶段调用 commitWork,他会重置 ref.current为 null</p>
<pre><code class="language-js">function commitWork(current, finishedWork) {
  switch (finishedWork.tag) {
    case ForwardRef:
      commitHookEffectListUnmount(Layout | HasEffect, finishedWork);
      return;
  }
}
function commitHookEffectListUnmount(tag, finishedWork) {
  var updateQueue = finishedWork.updateQueue;
  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    var firstEffect = lastEffect.next;
    var effect = firstEffect;

    do {
      if ((effect.tag &amp; tag) === tag) {
        // Unmount
        var destroy = effect.destroy;
        effect.destroy = undefined;

        if (destroy !== undefined) {
          destroy();
        }
      }

      effect = effect.next;
    } while (effect !== firstEffect);
  }
}
</code></pre>
<blockquote>
<p>从这个过程也可以看出，如果 ref 是一个函数，会被执行两次，第一次在 commitMutationEffects 阶段执行，用于重置 ref.current 为 null，第二次在 commitLayoutEffects 阶段执行，用于设置 ref.current 为最新的值</p>
</blockquote>

<h1>为什么你可以删除 90% 的 useMemo 和 useCallback</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7251802404877893689?searchId=202308271525500339E8A38274CBF18EF2">juejin.cn</a></p>
</blockquote>
<h2>不多废话，正文开始</h2>
<p>有两个主要原因导致了这两个 hooks 恶心地向四面八方扩散：</p>
<ul>
<li>缓存（memorize） props，从而防止组件重渲染 (re-render)</li>
<li>缓存某些值，从而避免在每次重渲染时执行开销昂贵的计算任务</li>
</ul>
<p>我们将在下面的文章里仔细审视这两个原因，但第一点是：<code>useMemo</code> 和 <code>useCallback</code> 的目的到底是什么？</p>
<h2>我们为什么需要 useMemo 和 useCallback ？</h2>
<p>答案很简单：在每次<strong>重渲染之间</strong>缓存数据。
如果不使用它们，所有非原始类型的值，如 <code>array</code>、<code>object</code>，或 <code>function</code>，都会在每一次重渲染时被彻底重新创建。</p>
<hr>
<p>如果你需要在每次重渲染时比较这些值，那么缓存它们是很有用的。例子是这样的：</p>
<pre><code>const Component = () =&gt; {  
  const a = { test: 1 };
  useEffect(() =&gt; {    
    // &quot;a&quot; 将会在每次重渲染时被比较
  }, [a]);
  // 你剩下的代码
};
</code></pre>
<p>在 <code>Component</code> 的每次重渲染时， <code>React</code> 都会把它与的值与上次渲染时的值做比较. <code>a</code> 是一个在 <code>Component</code> 内部定义的 <code>object</code>，这意味着在每次重渲染时，<code>a</code> 都会被完完全全地重新创建 (re-create)。
因此，比较” 重渲染之前的 <code>a</code>“和” 重渲染之后的 <code>a</code>“，结果都会是 <code>false</code>，所以被 <code>useEffect</code> 包裹的函数也将会在每次重渲染的过程中触发调用。
为了避免以上结果，我们可以把 <code>a</code> 包裹在 <code>useMemo</code> 中：</p>
<pre><code>const Component = () =&gt; {
  // 在每次重渲染之间保存 a
  const a = useMemo(() =&gt; ({ test: 1 }), []);

  useEffect(() =&gt; {
    // 只有当 a 的值真实发生改变时才会触发
  }, [a]);
  // 你剩下的代码
};
</code></pre>
<p>现在 <code>useEffect</code> 中的方法只有在 <code>a</code> 值确实发生变化的时候才会触发（不过在本例中这不会发生）。</p>
<hr>
<p>在这里，需要记住的最重要的一件事是，<code>useMemo</code> 和 <code>useCallback</code> 只有在<strong>重渲染的过程中</strong>才有用。在初始渲染过程中，它们不仅是无用的，甚至是有害的：它们会让 React 做很多额外的工作。这意味着你的应用在初始渲染过程中会<strong>稍稍更慢</strong>一些。并且，如果你的应用有数百个这些 hooks 分布在各处，那么这些轻微的影响初始渲染的作用就可以被观察到。</p>
<h2>缓存 props 以避免重渲染</h2>
<p>这两个 hook最常被用到的一点，就是缓存 props 以避免重渲染。
在以下所有的例子里，这两个 hooks 都 毫无作用。它们让代码变得复杂，拖慢了初始渲染，却没有阻止任何事情（指重渲染）。</p>
<ol>
<li>
<p>把 onClick 包裹在 useCallback 中以避免重渲染</p>
<pre><code>const Component = () =&gt; {
  const onClick = useCallback(
    () =&gt; {    /* do something */  }, []
  );
  return (
    &lt;&gt;
      &lt;button onClick={onClick}&gt;Click me&lt;/button&gt;
     ... // 其他组件  
    &lt;/&gt;  
  );
};
</code></pre>
</li>
<li>
<p>把 value 包裹在 useMemo 中，因为它是被缓存的 onClick 的依赖：</p>
<pre><code>const Item = ({ item, onClick }) =&gt; &lt;button onClick={onClick}&gt;
  {item.name}
&lt;/button&gt;;
const Component = ({ data }) =&gt; {
  const value = useMemo(() =&gt; ({ a: someStateValue }), [someStateValue]);
  const onClick = useCallback(() =&gt; {    console.log(value);  }, [value]);
  return (
    &lt;&gt;
      {data.map((d) =&gt; (&lt;Item item={d} onClick={onClick} /&gt;))}
    &lt;/&gt;
  );
};
</code></pre>
</li>
</ol>
<h2>为什么一个组件会重渲染它自己？</h2>
<p>当 state 或者 prop 发生变化的时候，组件就会重渲染自己
但这不意味着如果 prop 没有变化（比如，被缓存了），那组件就不会重渲染。
因为还有一个重要的原因会导致组件重渲染：<strong>当组件的父组件重渲染！</strong>
或者说，如果我们从相反的角度考虑：当一个组件重渲染它自己的时候，它也会同时重渲染它的 children。看一下下面的代码示例：</p>
<pre><code>const App = () =&gt; {
  const [state, setState] = useState(1);
  return (
    &lt;div class&gt;
      &lt;button onClick={() =&gt; setState(state + 1)}&gt;
        click to re-render {state}
      &lt;/button&gt;
      &lt;br /&gt;
      &lt;Page /&gt;
    &lt;/div&gt;
  );
};
</code></pre>
<p><code>App</code> 组件有一些 state，也有一些 children，包括 <code>Page</code> 组件。
button 被点击的时候，State 会变化，它会导致 App 的重渲染，并且会触发它重渲染它所有的 children，包括 <code>Page</code> 组件。在这过程中 <code>Page</code> 组件甚至没有 props！但是当 App 重渲染的时候， Page 组件依旧会重渲染，并连同重渲染它内部的 Item 组件。</p>
<h2>避免子组件不必要的渲染</h2>
<p>我们知道当一个组件重渲染它自己的时候，它也会同时重渲染它的 children
唯一去打断这链条的办法，是去缓存组件内的子组件。
我们能够用 <code>useMemo</code> 做到这些，更好的方法则是使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Flegacy.reactjs.org%2Fdocs%2Freact-api.html%23reactmemo" title="https://legacy.reactjs.org/docs/react-api.html#reactmemo">React.memo</a> 工具函数。
只有当组件被包裹在其以内时，React 才会在重渲染之前先停下来检查一下 props 是否产生了变化。
这样缓存一个组件：</p>
<pre><code>const Page = () =&gt; &lt;Item /&gt;;
const PageMemoized = React.memo(Page);
</code></pre>
<p>在一个包含 state 的 App 中使用它：</p>
<pre><code>const App = () =&gt; {
  const [state, setState] = useState(1);
  return (
    ... // same code as before
    &lt;PageMemoized /&gt;
  );
};
</code></pre>
<p><strong>只有</strong>在以上场景中，props 是否被缓存才是重要的。</p>
<hr>
<p>让我们想象 <code>Page</code> 组件存在一个 <code>onClick</code> prop，它接收一个函数。如果我在不缓存这个函数的情况下，把它传递给 <code>Page</code>，会发生什么呢？</p>
<pre><code>const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = () =&gt; {
    console.log('Do something on click');
  };
  return (
    // 不管 onClick 有没有缓存，page 都会重渲染
    &lt;Page onClick={onClick} /&gt;
  );
};
</code></pre>
<p><code>App</code> 会重渲染，React 会在 App 的 children 中找到 <code>Page</code> 组件，并且重渲染它。<code>onClick</code> 是否包裹在 <code>useCallback</code> 中并不重要。</p>
<p>那么如果我们把 <code>Page</code> 组件缓存起来了呢？</p>
<pre><code>const PageMemoized = React.memo(Page);
const App = () =&gt; {
  const [state, setState] = useState(1);
  const onClick = () =&gt; {
    console.log('Do something on click');
  };
  return (
    // 因为 onClick 没有缓存，PageMemoized 「将会」重渲染
    &lt;PageMemoized onClick={onClick} /&gt;
  );
};
</code></pre>
<p><code>App</code> 会重渲染，React 会在它的 children 中发现 <code>PageMemoized</code> 组件，并意识到它被 <code>React.memo</code> 方法包裹，这会打断重渲染链条，React 会事先检查这个组件的 props 是否有变化。
在这个例子里，既然 <code>onClick</code> 是一个未被缓存的函数，props 比较的结果就会是 <code>false</code>，那么 <code>PageMemoized</code> 组件就会重渲染它自己。</p>
<h2>什么时候缓存 props有意义</h2>
<p>我们可以得出结论，只有在唯一的一种场景下，缓存 props 才是有意义的：
<strong>当组件的每一个 prop，以及组件本身被缓存的时候</strong>。</p>
<p>如果组件代码里有以下情形，我们可以毫无心理负担地删掉 <code>useMemo</code> 和 <code>useCallback</code>：</p>
<ul>
<li>它们被作为 attributes ，直接地或作为依赖树的上层，被传递到某个 DOM 上</li>
<li>它们被作为 props，直接地或作为依赖树的上层，被传递到某个未被缓存的组件上</li>
<li>它们被作为 props，直接地或作为依赖树的上层，被传递到某个组件上，而那个组件至少有一个 prop 未被缓存</li>
</ul>
<h2>在每次重渲染时避免开销巨大的运算</h2>
<p><code>useMemo</code> 最主要的作用，就是在每次的渲染过程中避免开销巨大的运算。
在叙述中，并没有提到什么算是 “开销巨大” 的运算。</p>
<h3>什么是开销巨大的运算？</h3>
<p>考虑我们有一个国家列表（大概有 250 个元素），并且我们希望在页面上展示它们，并且允许用户去执行排序操作。</p>
<pre><code>const List = ({ countries }) =&gt; {
  // sorting list of countries here
  const sortedCountries = orderBy(countries, 'name', sort);
  return (
    &lt;&gt;
      {
        sortedCountries.map((country) =&gt; (
          &lt;Item country={country} key={country.id} /&gt;
        ))
      }
    &lt;/&gt;
  );
};
</code></pre>
<p>使用我们常用的 performance api 就行了。来看看给 250 个元素排序属于开销巨大的操作么，</p>
<pre><code>const List = ({ countries }) =&gt; {
  const before = performance.now();
  const sortedCountries = orderBy(countries, 'name', sort);
  // this is the number we're after
  const after = performance.now() - before;
  return (    // same  )
};
</code></pre>
<p>最终结果如果不缓存的话给 250 个元素排序耗时 少于 2 毫秒。 作为比较，渲染这个列表——仅仅是原生的按钮上带文字——就消耗了 20 毫秒。在实际场景中，数组往往比示例中的更小，同时渲染的内容比示例中的更复杂，因此更慢。所以总的来说「计算」与「渲染」之间的耗时往往超过 10 倍。
因此缓存js 的 order 排序，不如缓存需要渲染的组件</p>
<hr>
<p>我们更应该缓存的是实际上是最耗时的计算——重渲染并更新组件。像下面这样：</p>
<pre><code>const List = ({ countries }) =&gt; {
  const content = useMemo(() =&gt; {
    const sortedCountries = orderBy(countries, 'name', sort);
    return sortedCountries.map((country) =&gt;
      &lt;Item country={country} key={country.id} /&gt;
    );
  }, [countries, sort]);
  return content;
};
</code></pre>
<p>以上 <code>useMemo</code> 把大约 20ms 的重渲染时间，减少了不到 2ms（也就是 18ms 左右）。
因此我把把 useMemo 更多用在渲染组件上，而不是记录 JavaScript 的计算结果</p>
<hr>
<p>考虑以上事实，我想说的关于缓存” 开销巨大 “操作的一条准则就是：除非你真的要搞类似大数阶乘，疯狂递归，大素数分解这样的操作，否则就在纯 javascript 操作中把 <code>useMemo</code> 删掉吧。重渲染元素才是你的瓶颈。请只在渲染树的重要部分使用 <code>useMemo</code>。</p>
<h3>为什么要避免不必要的useMemo缓存</h3>
<p>把所有东西缓存起来不是更好吗？哪怕只让重渲染速度提升了 2ms，累加起来就很可观了呀。
因为但是如果我们使用 <code>useMemo</code>，在初始渲染过程中 React 就需要缓存其值了——<strong>这会产生叠加效应</strong>！在初始渲染让你的应用第一次呈现在屏幕前的过程中，当前页面的<strong>每一个</strong>元素都会经历这一过程，这将导致 10~20 ms，</p>
<p>参与初始渲染的是整个页面相关的组件，参与重渲染的只是局部的组件，两者不是一个数量级。参与初始渲染的大量组件，被 <code>useMemo</code> 和 <code>useCallbak</code> 拖慢所产生的叠加明显，远远比参与重渲染的少量组件，被 <code>useMemo</code> 和 <code>useCallbak</code>所优化所产生的叠加效应来的明显！</p>

<h1>强制缓存这么暴力，为什么不使用协商缓存😡😡😡</h1><blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/7248235392284721209?utm_source=gold_browser_extension">juejin.cn</a></p>
</blockquote>
<h1>强缓存和协商缓存</h1>
<p>浏览器缓存是浏览器在本地磁盘对用户最近请求过的文档进行存储, 当访问者再次访问同一页面时, 浏览器就可以直接从本地磁盘加载文档, 其中浏览器缓存就分为 <code>强缓存</code> 和 <code>协商缓存</code>:</p>
<h2>强缓存</h2>
<p>强缓存就是文件直接从本地缓存中获取, 不需要发送请求。
当资源首次被请求时，服务器会在响应头中添加一个属性，即&quot;Cache-Control&quot;或&quot;Expires&quot;来标记资源为强缓存。</p>
<p>例如，</p>
<ul>
<li>设置为&quot;Cache-Control: max-age=3600&quot;表示资源在客户端缓存中存储1小时</li>
<li>设置为&quot;Expires: Fri, 01 Jan 2022 00:00:00 GMT&quot;表示资源在客户端缓存中的有效期截止到2022年1月1日</li>
</ul>
<p>当下一次请求该资源时，客户端会先检查缓存中是否存在该资源，并且检查缓存是否过期。如果缓存中的资源未过期，客户端不会像服务器发送任何请求，直接从本地缓存中读取文件并返回 Status Code: 200 OK</p>
<p>强缓存有过期时间, 如果失效了, 那么它就会像首次请求中一样, 重新向服务器发起请求, 之后服务器会再次返回资源和 <code>Cache-Control</code> 的值。</p>
<h3>cache-control 和 expires 的区别</h3>
<p>&quot;Cache-Control&quot;是HTTP/1.1引入的缓存控制指令</p>
<ul>
<li>指令包括max-age：指定资源在客户端缓存中的最大存储时间，单位为秒。
&quot;Expires&quot;是HTTP/1.0引入的缓存控制字段，它指定了资源的过期时间点</li>
<li>但他它使用的是服务器的时间，如果服务器时间与客户端时间不一致，就会导致缓存失效的问题
最后&quot;max-age&quot;和&quot;Expires&quot;可以同时使用，但&quot;max-age&quot;优先级更高，</li>
</ul>
<h3>max-age 的使用</h3>
<p>客户端接收到响应后，会将该资源存储在缓存中，并记录下缓存的时间戳
当下一次请求该资源时，用当前时间减去缓存时间戳小于等于&quot;max-age&quot;的值来计算</p>
<h3>cache-control的其他属性</h3>
<p>no-cache：指示客户端不要使用缓存的副本，而是发送请求到服务器进行验证。
no-store：指示客户端不要缓存响应的副本。
public：指示响应可以被任何缓存存储，包括中间代理服务器。
private：指示响应只能被客户端缓存，中间代理服务器不能缓存。</p>
<h3>如果没有 cache-control和 expires</h3>
<p>如果没有设置&quot;Cache-Control&quot;或&quot;Expires&quot;，则服务器没有明确指定缓存的行为，这种情况下，客户端通常会默认使用强缓存。</p>
<p>在缺乏缓存控制指令的情况下，浏览器会根据自身的缓存策略来确定是否使用缓存。一般情况下，浏览器会对静态资源进行缓存，例如图片、CSS、JavaScript等。
然而，没有明确指定缓存的过期时间或验证机制，缓存的资源可能会一直被使用，直到浏览器关闭或清除缓存。这可能导致客户端无法获取到最新的资源，特别是在服务器更新了资源</p>
<h2>协商缓存</h2>
<p>如果设置&quot;Cache-Control: no-cache&quot;表示客户端需要与服务器进行协商验证缓存的有效性，这是协商缓存。
如果服务器返回的响应头中包含了&quot;Cache-Control&quot;属性且指令为&quot;no-cache&quot;，或者包含了ETag和Last-Modified属性，那么客户端在请求该资源时就会进行协商缓存，</p>
<p>如果客户端是第一次向服务器发出请求, 则服务器返回资源和对应的资源标识给浏览器, 标识可以是 <code>ETag</code> 或者是 <code>Last-Modified</code>。</p>
<p>之后如果浏览器再次发送请求是, 浏览器就会带上这个标识, 此时服务端就会通过这个资源标识, 可以判断出浏览器的资源跟服务器此时的资源是否一致,
如果一致则返回<code>304 Not Modified</code>, 并在响应头中清除实际的响应头;
如果不一致, 则返回 <code>200</code>, 并返回资源以及新的资源标识。</p>
<h2>协商缓存中的两个字段</h2>
<ol>
<li>如果资源未被标记为强缓存或缓存验证失败, 服务器进行协商缓存的判断:
协商缓存中第一次向服务器发出请求, 会同时接收到资源和资源标识，标识可以是 <code>ETag</code> 或者是 <code>Last-Modified</code>。</li>
</ol>
<p>后续请求会用到这两个标识用来验证资源是否变换。
使用 last-Modified标识： 发送字段<code>If-Modified-Since</code>，他的值为 last-Modified
使用 ETag 表示： 发送字段 <code>If-None-Match</code> ，他的值为 ETag</p>
<p>最后Etag 优先级是高于 Last-Modifed 的，所以服务器会优先验证 Etag</p>
<h1>不同刷新方式对强制缓存和协商缓存的影响</h1>
<p>不同的刷新操作方式对于强制缓存和写上缓存的影响如下:</p>
<ol>
<li>普通刷新 (<code>F5</code> 或 <code>刷新按钮</code>):
<ul>
<li>强制缓存的影响: 浏览器忽略强制缓存, 直接向服务器发送请求, 获取最新的资源, 也就是强制缓存失效;</li>
<li>协商缓存的影响: 浏览器放带有缓存验证的字段的请求, 浏览器会根据验证结果返回新的资源或者 <code>304 Not Modified</code>;</li>
</ul>
</li>
<li>强制刷新 (<code>Ctrl+F5</code> 或 <code>Shift+刷新按钮</code>):
<ul>
<li>强制缓存的影响: 同上, 强制缓存失效;</li>
<li>协商缓存的影响: 浏览器发送不带缓存验证字段的请求, 服务器返回新的资源, 不进行验证, 也就是协商缓存失效;</li>
</ul>
</li>
<li>禁用缓存刷新 (<code>DevTools</code> 中的 <code>Disable cache</code> 或 <code>Network</code> 勾选 <code>Disable cache</code>):
<ul>
<li>强制缓存的影响: 同上, 强制缓存失效;</li>
<li>协商缓存的影响: 浏览器会发送带有缓存验证字段的请求, 服务器会根据验证结果返回新的资源或 <code>304 Not Modified</code>;</li>
</ul>
</li>
</ol>
