> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/composite?_gl=1*6nnpyq*_ga*MTI1NjIzNzY1Ni4xNjkzODA5NTY2*_ga_SR8Y3GYQYC*MTY5Mzg5NjQ1Mi40LjEuMTY5Mzg5Njk2Ny42MC4wLjA.)

问题
--
例如， 你有两类对象： ​ `产品`和 `盒子` 。 一个盒子中可以包含多个 `产品`或者几个较小的 `盒子` 。 这些小 `盒子`中同样可以包含一些 `产品`或更小的 `盒子` ， 以此类推。

假设你希望在这些类的基础上开发一个定购系统。 订单中可以包含无包装的简单产品， 也可以包含装满产品的盒子…… 以及其他盒子。 此时你会如何计算每张订单的总价格呢？

解决方案
----

组合模式建议使用一个通用接口来与 `产品`和 `盒子`进行交互， 并且在该接口中声明一个计算总价的方法。

那么方法该如何设计呢？ 
- 对于一个产品， 该方法直接返回其价格； 
- 对于一个盒子， 该方法遍历盒子中的所有项目， 询问每个项目的价格， 然后返回该盒子的总价格。 
如果其中某个项目是小一号的盒子， 那么当前盒子也会遍历其中的所有项目， 以此类推

![](https://refactoringguru.cn/images/patterns/content/composite/composite-comic-1-zh.png?id=845971cd0cc64fb0f3e303f393a9102c)


---

组合模式以递归方式处理对象树中的所有项目
该方式的最大优点在于你无需了解构成树状结构的对象的具体类。 你也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。 当你调用该方法后， 对象会将请求沿着树结构传递下去。


组合模式结构
------
![](https://refactoringguru.cn/images/patterns/diagrams/composite/structure-zh-indexed.png?id=0fc4960b564ebffa57284eade9141f1a)

1.  **组件** （Component） 接口描述了树中简单项目和复杂项目所共有的操作。
2.  **叶节点** （Leaf） 是树的基本结构， 它不包含子项目。
    一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。
3.  **容器** （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。
	- 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。
	- 容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。
	- 在该类中， 创建一个数组成员变量来存储对于其子元素的引用。 该数组必须能够同时保存叶节点和容器， 因此请确保将其声明为组合接口类型。

伪代码
---

```
// 组件接口会声明组合中简单和复杂对象的通用操作。
interface Graphic is
    method move(x, y)
    method draw()

class Dot implements Graphic is
    field x, y
    constructor Dot(x, y) { …… }
    method move(x, y) is
    method draw() is
        // 在坐标位置(X,Y)处绘制一个点。

class CompoundGraphic implements Graphic is
    field children: array of Graphic
    // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和
    // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，
    // 最后组合将会完成整个对象树的遍历工作。
    method draw() is
        // 1. 对于每个子部件：
        //     - 绘制该部件。
        //     - 更新边框坐标。
        // 2. 根据边框坐标绘制一个虚线长方形。


// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同
// 时支持简单叶节点组件和复杂组件。
class ImageEditor is
    field all: CompoundGraphic
    method groupSelected(components: array of Graphic) is
        group = new CompoundGraphic()
        foreach (component in components) do
            group.add(component)
            all.remove(component)
        all.add(group)
        // 所有组件都将被绘制。
        all.draw()
```

组合模式适合应用场景
----------

如果你需要实现树状对象结构， 可以使用组合模式。

组合模式为你提供了两种共享公共接口的基本元素类型： 简单叶节点和复杂容器。 容器中可以包含叶节点和其他容器。 这使得你可以构建树状嵌套递归对象结构。

如果你希望客户端代码以相同方式处理简单和复杂元素， 可以使用该模式。
组合模式中定义的所有元素共用同一个接口。 在这一接口的帮助下， 客户端不必在意其所使用的对象的具体类。

实现方式
----
在容器中定义添加和删除子元素的方法。
- 记住， 这些操作可在组件接口中声明。 这将会违反_接口隔离原则_， 因为叶节点类中的这些方法为空。 但是， 这可以让客户端无差别地访问所有元素， 即使是组成树状结构的元素。

组合模式优缺点
-------

*   你可以利用多态和递归机制更方便地使用复杂树结构。
*   _开闭原则_。 无需更改现有代码， 你就可以在应用中添加新元素， 使其成为对象树的一部分。

*   对于功能差异较大的类， 提供公共接口或许会有困难。 在特定情况下， 你需要过度一般化组件接口， 使其变得令人难以理解。

与其他模式的关系
--------

*   [桥接模式](/design-patterns/bridge)、 [状态模式](/design-patterns/state)和[策略模式](/design-patterns/strategy) （在某种程度上包括[适配器模式](/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。

---
*   你可以在创建复杂[组合](/design-patterns/composite)树时使用[生成器模式](/design-patterns/builder)， 因为这可使其构造步骤以递归的方式运行。
*   [责任链模式](/design-patterns/chain-of-responsibility)通常和[组合模式](/design-patterns/composite)结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。
