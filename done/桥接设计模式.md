> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/bridge)


意图
--
**桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

问题
--
假如你有一个几何 `形状`Shape 类， 从它能扩展出两个子类： ​ `圆形`Circle 和 `方形`Square 。 你希望包含颜色， 所以你打算创建名为 `红色`Red 和 `蓝色`Blue 的形状子类。 
但是， 由于你已有两个子类， 所以总共需要创建四个类才能覆盖所有组合， 例如 `蓝色圆形`Blue­Circle 和 `红色方形`Red­Square 。

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/problem-zh.png)

所有组合类的数量将以几何级数增长。

解决方案
----
桥接模式通过将继承改为组合的方式来解决这个问题。 
将一个类层次转化为多个相关的类层次， 避免单个类层次的失控。
具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在初始类中引用这个新层次的对象， 从而使得一个类不必拥有所有的状态和行为。

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/solution-zh.png)



#### 抽象部分和实现部分

_抽象部分_ （也被称为接口） 是一些实体的高阶控制层。 该层自身不完成任何具体的工作， 它需要将工作委派给_实现部分_层 。
注意， 这里提到的内容与编程语言中的_接口_或_抽象类_无关。 它们并不是一回事。


桥接模式结构
------

![](https://refactoringguru.cn/images/patterns/diagrams/bridge/structure-zh-indexed.png)

1.  **抽象部分** （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。
2.  **实现部分** （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。
    抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。
3.  **具体实现** （Concrete Implementations） 中包括特定于平台的代码。
5.  通常情况下， **客户端** （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。


桥接模式适合应用场景
----------

如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。
桥接模式可以将庞杂类拆分为几个类层次结构。 此后， 你可以修改任意一个类层次结构而不会影响到其他类层次结构。 这种方法可以简化代码的维护工作， 并将修改已有代码的风险降到最低。


---
如果你希望在几个独立维度上扩展一个类， 可使用桥接模式。
桥接建议将每个维度抽取为独立的类层次。 初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。
如果你需要在运行时切换不同实现方法， 可使用桥接模式。
当然并不是说一定要实现这一点， 桥接模式可替换抽象部分中的实现对象， 具体操作就和给成员变量赋新值一样简单。

---
_顺便提一句， 最后一点是很多人混淆桥接模式和[策略](/design-patterns/strategy)模式的主要原因。 
记住， 设计模式并不仅是一种对类进行组织的方式， 它还能用于沟通意图和解决问题。_


桥接模式优缺点
-------
*   你可以创建与平台无关的类和程序。
*   客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。
*   _开闭原则_。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。
*   _单一职责原则_。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。

*   对高内聚的类使用该模式可能会让代码更加复杂。

与其他模式的关系
--------
*   [桥接](/design-patterns/bridge)、 [状态模式](/design-patterns/state)和[策略模式](/design-patterns/strategy) （在某种程度上包括[适配器](/design-patterns/adapter)） 模式的接口非常相似。 实际上， 它们都基于[组合模式](/design-patterns/composite)——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。


---
*   你可以将[抽象工厂模式](/design-patterns/abstract-factory)和[桥接](/design-patterns/bridge)搭配使用。 如果由_桥接_定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， _抽象工厂_可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
