> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [juejin.cn](https://juejin.cn/post/7226610046833442872)

`事前提醒：阅读本文存在不同想法时，可以在评论中表达，但请勿使用过激的措辞。`

问题概述：（慢慢进入话题，不要太快哦！）
====================

1、作为一名前端开发工程师，我们只关注工程代码，**往往却忽略了依赖文件、以及 node、npm、yarn、pnpm 等 具体是个什么。**

2、什么是**幽灵（幻影）依赖**？**什么是依赖提升？** **npm 的发展历程经历了那些阶段**，**发生了什么故事？** **yarn 是什么？它的出现干什么用？pnpm 又是干什么的？**

3、怎么去理解 package.json？ **_node_ 的寻址过程**是什么样的？

威武！！！开聊吧：
=========

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/857af39cbc5445ad89bd4f97384096d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

> 首先自我说明身份，像我这种**前端小白龙**（_什么都不懂的_）在开发中，我们经尝遇到 **node、npm**、项目依赖版本不对应所引发的大面积爆红，这个时候我们需要补充一下**依赖的寻址、以及 node_modules 存在的意义，看一下下面这个文章，再回来**。

**node 依赖的寻址**：Node.js 模块查找规则。[点击查看文章](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fqq_34399969%2Farticle%2Fdetails%2F126723717 "https://blog.csdn.net/qq_34399969/article/details/126723717")

在项目中，例如 vue 的整体项目中，代码中引用依赖文件，这个时候就会发生一个寻址的过程: 查找**本 js 文件所在目录下的 node_modules** 目录，若不存在该目录，则向上一级目录查找 node_modules 目录。 node_modules 目录中查找名为 packageName 的目录，若不存在，向上一级目录中查找 node_modules 模块。 在 packageName 目录中查找 package.json 文件，查找该文件中 main 属性标注的入口 js 文件。若不存在该入口文件，查找 packageName 目录中是否有 index.js 文件，若存在则将 index.js 作为入口 js 文件。 若连 index.js 文件都不存在，则再向上一级目录查找 node_modules。 没有找到的话，控制台最终就会报错。

好的 理解了这个，我们下边就聊一聊 npm install 的执行 发生了什么事 [友情文章](https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2Fh03580%2Farticle%2Fdetails%2F116021091%3Fspm%3D1001.2014.3001.5501 "https://blog.csdn.net/h03580/article/details/116021091?spm=1001.2014.3001.5501")

文章中介绍了 npm 在安装的时候

npm install 执行后，会检查并获取 npm 配置，优先级为

> 项目级别的. npmrc 文件 > 用户级别的. npmrc 文件 > 全局的. npmrc 文件 > npm 内置的. npmrc 文件

然后检查项目中是否有 package-lock.json 文件。  
如果有，检查 package-lock.json 和 package.json 中声明的依赖是否一致

*   一致：直接使用 package-lock.json 中声明的依赖，从缓存或者网络中加载依赖
*   不一致：各个版本的 npm 处理方式如图

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f6fa4d6ea57444885c352fa51ab77d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)  
如果没有，根据 package.json 递归构建依赖树，然后根据依赖树下载完整的依赖资源，在下载时会检查是否有相关的资源缓存

*   存在：将缓存资源解压到 node_modules 中
*   不存在：从远程仓库下载资源包，并校验完整性，并添加到缓存，同时解压到 node_modules 中

最后生成 package-lock.json 文件。

**正题来咯**：

构建依赖树时，不管是直接依赖还是子依赖，都会按照扁平化的原则，优先将其放置在 node_modules 根目录中 (最新的 npm 规范), 在这个过程中，如果遇到相同的模块，会检查已放置在依赖树中的模块是否符合新模块的版本范围，如果符合，则跳过，不符合，则在当前模块的 node_modules 下放置新模块

首先 **npm 是怎么知道 install 那些依赖文件的？**

当然是根据 package.json 的 **dependencies**:{} 和 **devDependencies**:{} 他们中声明了你项目中所要使用 和 已经安装的依赖名称和版本信息。通常常见的就是 插件、加载器、外部 js 库文件封装的依赖库。**devDependencies** 中一般是声明插件和加载器的，而 **dependencies** 中就是用的的库文件。举个例子 ----vue、vuex、vue-router、element-ui、webpack、less-loader、day.js 应该被声明到哪里？ 正确是这样：

**dependencies**：{ **vue、vuex、vue-router、element-ui、day.js** }

**devDependencies**: { **webpack、less、less-loader** }

还是不懂得可以 **扩充一下 package.json 中其他属性的意思和作用**。

最后 npm 安装依赖时，会下载到缓存当中，然后解压到项目的 node_modules 中。  
再次安装依赖的时候，会根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，然后拿着 key 去目录中查找对应的缓存记录，如果有缓存资源，就会找到 tar 包的 hash 值，根据 hash 再去找缓存的 tar 包，并把对应的二进制文件解压到相应的项目 node_modules 下面，省去了网络下载资源的开销。

看到这里 **有一个问题: package.json 中定义了 10 个 那么 node_modules 就会有 10 个嘛？**

答案是**不会**，这个时候就出现了我们开篇提到的**幽灵依赖**问题了。下边有风趣简介，耐心看

如果让你来设计 npm 你怎么设计？ 我们再来了解一下 node_modules 初版什么样子的, 为什么会有 yarn、pnpm 的出现 ，下面就会看到答案

我们使用 **nvm** 去安装一个老版本 node 可以去测试一下 不同版本下的 node_modules 有什么差别，npm 版本有什么差别。

假如说 **package.json 里依赖了 3 个包 a、b、c 然后 a 依赖了 a_1, b 依赖了 b_1 , c 依赖了 c_1**

如果 ** 初版 npm 去 install 的话 你会发现 node_modules 中只有 3 个包 a、b、c **

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b55c5d6b97d4b3b8e2db239d3e2b080~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

然后 **a 中 node_modules 会有 a_1 的存在**、**b 中 node_modules 会有 b_1 的存在**、 **c 同理**...... 会像是一棵树，tree 一样，深....... 大..... 浪费空间！

这个就是初代 npm 的实现方式。 经过迭代 还是没改变这种问思路，思考一下，如果是你，你怎么设计？？

此时就出现一个问题，我要重复引用一个依赖 ，就要深度的重复。

比如说：**a 依赖 vue@1.0, b 也依赖 vue@1.0**, 早期 npm 的构造就是下图

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8ac6ba6f2214423a77f9c676134cf2f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

可以想一下**这里的 vue 体积，又或者其他库的体积**。。。。。

那怎么去解决这个重复引用的问题呢，**此时一个叫 yarn 的做出了创新** 先看图

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c6a7d04c24042c4a1c996efeb845368~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

由之前的 tree-----> 把 vue@1.0 从内部抽出来，扁平到同一级，这样是不是就解决了重复的问题。哈哈哈哈 好傻的感觉......

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10f193fe34d42dc986b51d25c201a7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

当时 npm 没考虑到的，yarn 想到了，然后 yarn 那段时间大火于开发界。此时更有趣了，npm 说:'**我敲？赶上我了？我抄！**'。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bce2f3f09c2c4812ae6148bb260eee6d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb4750f9fdeb4db6b137fbca04f4da34~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 继而 npm 的再次迭代，拥有了这一特点。然后开发界就呈现了，双龙会。那么把树级结构打平？就没有问题了嘛？ 继续往下聊。

此刻 我们文章的主题 “幽灵依赖成功浮出水面”，打个比方 ，![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2281fa698cc4661935b46d05a380fe8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 看图

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977169b5c61c4305a82741691ff27a1b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

A 的 package.json 的 dependencies 里有 dayjs@1.0

B 的 package.json 的 dependencies 里有 dayjs@1.0

Myproject 的 package.json 的 dependencies 里没有 dayjs@1.0

但是 Myproject 的 view.js 有 import dayjs@1.0 这个时候项目是可以跑起来的，为什么？ 下边补充一下上面提到的 _**node 的寻包过程**_

_**首先在当前目录下的 node_modules 寻找，找到了就直接使用，找不到就会往上一级的 node_modules 寻找，直到找寻到磁盘根目录的 node_modules 找不到 直接抛出对应错误。**_

此时举个例子：

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/307ff7fab93647f28500252d89fa4403~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

在 view.js 中 import vue from 'vue' 是那个版本？

答案是 1.0,

这个时候 能够想到什么是幽灵依赖了吗？ 其实简单来说 就是 项目里使用了，但是未在项目的 package.json 中定义的包。就是幽灵依赖。 按着原理来说 未在 package.json 中定义的包 不会被下载，但是它偏偏就存在了，也被下载了，这又是为什么呢？ 因为依赖提升，造成的副作用。所以说 yarn 的这个方式，就是把相同的依赖包进行提升的方式，就会造成幽灵依赖。 换个言简意赅的说法就是：孙子突然和儿子一个地位、同一个级别， 本来想喊儿子的，发现有个孙子的名字和儿子的名字一样，好家伙 直接把这个孙子当成儿子了，这不就差辈分了嘛，也就是官网说的一个 安全问题。 此时这个问题又该怎么解决呢? 突然天空惊雷一响，pnpm 闪亮登场，

**概念**

performant npm ，意味 “高性能的 npm”。[pnpm](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3Dpnpm%26spm%3D1001.2101.3001.7020 "https://so.csdn.net/so/search?q=pnpm&spm=1001.2101.3001.7020") 由 npm/yarn 衍生而来，解决了 npm/yarn 内部潜在的 bug，极大的优化了性能，扩展了使用场景。被誉为 “最先进的包管理工具”

速度快、节约磁盘空间、支持 monorepo、安全性高

**pnpm 相比较于 yarn/npm 这两个常用的包管理工具在性能上也有了极大的提升**，根据目前官方提供的 [benchmark](https://link.juejin.cn?target=https%3A%2F%2Fso.csdn.net%2Fso%2Fsearch%3Fq%3Dbenchmark%26spm%3D1001.2101.3001.7020 "https://so.csdn.net/so/search?q=benchmark&spm=1001.2101.3001.7020") 数据可以看出在一些综合场景下比 npm/yarn 快了大概两倍。

**存储管理：**

按内容寻址、采用 symlink

pnpm 跳出 npm 和 yarn 两者为了一坨屎而争斗的战场。直接推翻重建工程化，不继续维护屎山、跳出圈子。node 的包寻址思路不变，目前的办法已经不能在成为追求极限的标准了，pnpm 开始进行更新。

**npm1、npm2 采用递归管理，npm3、npm3+、yarn 依赖扁平化管理消除依赖提升。**

**pnpm 依赖策略：消除依赖提升、规范拓扑结构**

**安全**

之前在使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的，但问题是 A 当中并没有声明 C 这个依赖。因此会出现这种非法访问的情况。 但 pnpm 自创了一套依赖管理方式，很好地解决了这个问题，保证了安全性。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93da1a4ff7a0465d83afb4eee88e9464~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

既然 yarn install 花费的时间是 npm install 的一半（不使用缓存的前提下）  
缓存和脱机模式使构建过程几乎不花费时间。那么 pnpm 岂不是降维打击？？？ 它的出现，可以直接完全打败 npm、yarn 嘛？

答案是：不会的，看看目前的使用量来看，npm、yarn 还是一龙一虎。。。。。只不过 pnpm 是个人，手中有枪杆子

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd29fd26c17f4aba94d69c74d000482c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

散会下次再见！！！！！ [@Suning](https://link.juejin.cn?target=https%3A%2F%2Fwww.suning.com%2F "https://www.suning.com/") 张凯杰
==================================================================================================================

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2188a862764e0687f67d763ca73d97~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)