> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/prototype)

> 工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![](https://refactoringguru.cn/images/content-public/sunbed.svg?id=b1e7314a63715a13870a6bd1a43613f7) [   ](#checkout)[](#checkout) 

[](/)/ [设计模式](/design-patterns) / [创建型模式](/design-patterns/creational-patterns)

原型模式
====

亦称： 克隆、Clone、Prototype

意图
--

**原型模式**是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

![](https://refactoringguru.cn/images/patterns/content/prototype/prototype.png)

问题
--

如果你有一个对象， 并希望生成与其完全相同的一个复制品， 你该如何实现呢？ 首先， 你必须新建一个属于相同类的对象。 然后， 你必须遍历原始对象的所有成员变量， 并将成员变量值复制到新对象中。

不错！ 但有个小问题。 并非所有对象都能通过这种方式进行复制， 因为有些对象可能拥有私有成员变量， 它们在对象本身以外是不可见的。

![](https://refactoringguru.cn/images/patterns/content/prototype/prototype-comic-1-zh.png)

“从外部” 复制对象[并非](https://refactoringguru.cn/cargo-cult)总是可行。

直接复制还有另外一个问题。 因为你必须知道对象所属的类才能创建复制品， 所以代码必须依赖该类。 即使你可以接受额外的依赖性， 那还有另外一个问题： 有时你只知道对象所实现的接口， 而不知道其所属的具体类， 比如可向方法的某个参数传入实现了某个接口的任何对象。

解决方案
----

原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。 通常情况下， 这样的接口中仅包含一个 `克隆`方法。

所有的类对 `克隆`方法的实现都非常相似。 该方法会创建一个当前类的对象， 然后将原始对象所有的成员变量值复制到新建的类中。 你甚至可以复制私有成员变量， 因为绝大部分编程语言都允许对象访问其同类对象的私有成员变量。

支持克隆的对象即为_原型_。 当你的对象有几十个成员变量和几百种类型时， 对其进行克隆甚至可以代替子类的构造。

![](https://refactoringguru.cn/images/patterns/content/prototype/prototype-comic-2-zh.png)

预生成原型可以代替子类的构造。

其运作方式如下： 创建一系列不同类型的对象并不同的方式对其进行配置。 如果所需对象与预先配置的对象相同， 那么你只需克隆原型即可， 无需新建一个对象。

真实世界类比
------

现实生活中， 产品在得到大规模生产前会使用原型进行各种测试。 但在这种情况下， 原型只是一种被动的工具， 不参与任何真正的生产活动。

![](https://refactoringguru.cn/images/patterns/content/prototype/prototype-comic-3-zh.png)

一个细胞的分裂。

由于工业原型并不是真正意义上的自我复制， 因此细胞有丝分裂 （还记得生物学知识吗？） 或许是更恰当的类比。 有丝分裂会产生一对完全相同的细胞。 原始细胞就是一个原型， 它在复制体的生成过程中起到了推动作用。

原型模式结构
------

#### 基本实现

![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure.png)![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-indexed.png)

1.  **原型** （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 `clone`克隆的方法。
    
2.  **具体原型** （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。
    
3.  **客户端** （Client） 可以复制实现了原型接口的任何对象。
    

#### 原型注册表实现

![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache.png)![](https://refactoringguru.cn/images/patterns/diagrams/prototype/structure-prototype-cache-indexed.png)

1.  **原型注册表** （Prototype Registry） 提供了一种访问常用原型的简单方法， 其中存储了一系列可供随时复制的预生成对象。 最简单的注册表原型是一个 `名称 → 原型`的哈希表。 但如果需要使用名称以外的条件进行搜索， 你可以创建更加完善的注册表版本。
    

@media (min-width: 1200px) { .structure { margin: 0; width: auto; height: 1190px; } .prototype-normal { height: 490px; } .prototype-pool { height: 500px; } .struct-image1 { left: 0px; top: 170px; } .struct-li1 { left: 300px; top: 70px; width: 280px; } .struct-li2 { left: 510px; top: 290px; width: 280px; } .struct-li3 { left: 100px; top: 70px; width: 150px; } .struct-image2 { left: 100px; top: 670px; } .struct-li4 { left: 20px; top: 1020px; width: 370px; } }

伪代码
---

在本例中， **原型**模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。

![](https://refactoringguru.cn/images/patterns/diagrams/prototype/example.png)

克隆一系列位于同一类层次结构中的对象。

所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。

```
// 基础原型。
abstract class Shape is
    field X: int
    field Y: int
    field color: string

    // 常规构造函数。
    constructor Shape() is
        // ……

    // 原型构造函数。使用已有对象的数值来初始化一个新对象。
    constructor Shape(source: Shape) is
        this()
        this.X = source.X
        this.Y = source.Y
        this.color = source.color

    // clone（克隆）操作会返回一个形状子类。
    abstract method clone():Shape


// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运
// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生
// 成的克隆对象。这可以保持克隆结果的一致。
class Rectangle extends Shape is
    field width: int
    field height: int

    constructor Rectangle(source: Rectangle) is
        // 需要调用父构造函数来复制父类中定义的私有成员变量。
        super(source)
        this.width = source.width
        this.height = source.height

    method clone():Shape is
        return new Rectangle(this)


class Circle extends Shape is
    field radius: int

    constructor Circle(source: Circle) is
        super(source)
        this.radius = source.radius

    method clone():Shape is
        return new Circle(this)


// 客户端代码中的某个位置。
class Application is
    field shapes: array of Shape

    constructor Application() is
        Circle circle = new Circle()
        circle.X = 10
        circle.Y = 10
        circle.radius = 20
        shapes.add(circle)

        Circle anotherCircle = circle.clone()
        shapes.add(anotherCircle)
        // 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内
        // 容完全一样。

        Rectangle rectangle = new Rectangle()
        rectangle.width = 10
        rectangle.height = 20
        shapes.add(rectangle)

    method businessLogic() is
        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与
        // 其完全相同的复制品。
        Array shapesCopy = new Array of Shapes.

        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。
        // 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`
        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，
        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。
        foreach (s in shapes) do
            shapesCopy.add(s.clone())

        // `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有
        // 子元素的复制品。
```

原型模式适合应用场景
----------

如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。

这一点考量通常出现在代码需要处理第三方代码通过接口传递过来的对象时。 即使不考虑代码耦合的情况， 你的代码也不能依赖这些对象所属的具体类， 因为你不知道它们的具体信息。

原型模式为客户端代码提供一个通用接口， 客户端代码可通过这一接口与所有实现了克隆的对象进行交互， 它也使得客户端代码与其所克隆的对象具体类独立开来。

如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。

在原型模式中， 你可以使用一系列预生成的、 各种类型的对象作为原型。

客户端不必根据需求对子类进行实例化， 只需找到合适的原型并对其进行克隆即可。

实现方式
----

1.  创建原型接口， 并在其中声明 `克隆`方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。
    
2.  原型类必须另行定义一个以该类对象为参数的构造函数。 构造函数必须复制参数对象中的所有成员变量值到新建实体中。 如果你需要修改子类， 则必须调用父类构造函数， 让父类复制其私有成员变量值。
    
    如果编程语言不支持方法重载， 那么你可能需要定义一个特殊方法来复制对象数据。 在构造函数中进行此类处理比较方便， 因为它在调用 `new`运算符后会马上返回结果对象。
    
3.  克隆方法通常只有一行代码： 使用 `new`运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 `new`运算符。 否则， 克隆方法可能会生成父类的对象。
    
4.  你还可以创建一个中心化原型注册表， 用于存储常用原型。
    
    你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。
    
    最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。
    

原型模式优缺点
-------

*   你可以克隆对象， 而无需与它们所属的具体类相耦合。
*   你可以克隆预生成原型， 避免反复运行初始化代码。
*   你可以更方便地生成复杂对象。
*   你可以用继承以外的方式来处理复杂对象的不同配置。

*   克隆包含循环引用的复杂对象可能会非常麻烦。

与其他模式的关系
--------

*   在许多设计工作的初期都会使用[工厂方法模式](/design-patterns/factory-method) （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](/design-patterns/abstract-factory)、 [原型模式](/design-patterns/prototype)或[生成器模式](/design-patterns/builder) （更灵活但更加复杂）。
    
*   [抽象工厂模式](/design-patterns/abstract-factory)通常基于一组[工厂方法](/design-patterns/factory-method)， 但你也可以使用[原型模式](/design-patterns/prototype)来生成这些类的方法。
    
*   [原型](/design-patterns/prototype)可用于保存[命令模式](/design-patterns/command)的历史记录。
    
*   大量使用[组合模式](/design-patterns/composite)和[装饰模式](/design-patterns/decorator)的设计通常可从对于[原型](/design-patterns/prototype)的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。
    
*   [原型](/design-patterns/prototype)并不基于继承， 因此没有继承的缺点。 另一方面， _原型_需要对被复制对象进行复杂的初始化。 [工厂方法](/design-patterns/factory-method)基于继承， 但是它不需要初始化步骤。
    
*   有时候[原型](/design-patterns/prototype)可以作为[备忘录模式](/design-patterns/memento)的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。
    
*   [抽象工厂](/design-patterns/abstract-factory)、 [生成器](/design-patterns/builder)和[原型](/design-patterns/prototype)都可以用[单例模式](/design-patterns/singleton)来实现。
    

代码示例
----

[![](https://refactoringguru.cn/images/patterns/icons/csharp.svg?id=da64592defc6e86d57c39c66e9de3e58)](/design-patterns/prototype/csharp/example "C# 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/cpp.svg?id=f7782ed8b8666246bfcc3f8fefc3b858)](/design-patterns/prototype/cpp/example "C++ 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/go.svg?id=1a89927eb99b1ea3fde7701d97970aca)](/design-patterns/prototype/go/example "Go 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/java.svg?id=e6d87e2dca08c953fe3acd1275ed4f4e)](/design-patterns/prototype/java/example "Java 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/php.svg?id=be1906eb26b71ec1d3b93720d6156618)](/design-patterns/prototype/php/example "PHP 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/python.svg?id=6d815d43c0f7050a1151b43e51569c9f)](/design-patterns/prototype/python/example "Python 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/ruby.svg?id=b065b718c914bf8e960ef731600be1eb)](/design-patterns/prototype/ruby/example "Ruby 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/rust.svg?id=1f5698a4b5ae23fe79413511747e4a87)](/design-patterns/prototype/rust/example "Rust 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/swift.svg?id=0b716c2d52ec3a48fbe91ac031070c1d)](/design-patterns/prototype/swift/example "Swift 原型模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/typescript.svg?id=2239d0f16cb703540c205dd8cb0c0cb7)](/design-patterns/prototype/typescript/example "TypeScript 原型模式讲解和代码示例")

 [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-3.png?id=7d445df13c80287beaab234b4f3b698c)](/design-patterns/book) 

### 支持我们的免费网站并获得电子书！

*   22 个设计模式和 8 条原则的详细讲解。
*   382 页精心编排、易于阅读且没有术语的内容。
*   225 幅有助于理解的简明图表。
*   11 种编程语言的代码示例档案。
*   支持所有的设备：PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [<video src="" control></video>](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   我们必须承认：在网页上阅读没有一点趣味！
*   在通勤途中做些有价值的事情。
*   在沙发上放松时学些新东西。
*   包含实用的面向对象程序设计的伪代码示例。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-1-b.png?id=0877cab2f0102d98cd07b50af0e5beea)](/design-patterns/book) 

### 为什么你应该在通勤途中带着这本电子书？

*   你将在上班路上学些有用的东西。
*   无需互联网连接：随时可用还可进行搜索。
*   可选择多种阅读模式以便轻松阅读。
*   少带一件东西，永远不会忘记。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-4.png?id=87deabea80734585e2cda786f05dd7f6)](/design-patterns/book) 

### 为什么你应该在床上阅读这本电子书？

*   与刷视频相比，它更能更好地激发灵感。
*   与其它选择相比，它能让你更好地放松。
*   与其虚度光阴，还不如做些富有成效的事！
*   提供夜间阅读模式以便轻松阅读。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-2.png?id=ef3f7b0bdfe11e2cdad1e64a40db87da)](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   **初学者：**学习基础模式及其运作方式！
*   **专家：**可把本书当作一本便捷的、易于搜索的参考书！
*   **与语言无关：**提供 PHP、C# 和 Java 等语言的示例！
*   详细说明 22 个设计模式及其背后的 8 条原则。
*   382 页结构清晰、便于阅读且没有术语的内容。
*   225 幅清晰实用的插图和图表。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

### 为什么我们需要了解设计模式？

*   **轻松应对面试和审核。**关于模式的问题总是一再出现。
*   获得你应得的加薪和升职！
*   **扩展你的工具箱**，在其中添加经过验证且没有问题的代码示例。
*   定制现成的解决方案。不要重新开发所有内容。
*   **更好地与同事沟通**，无需冗长的解释。
*   只需指出设计模式的名称，你就能轻松解决问题！

[了解更多……](/design-patterns/book)

#### 继续阅读

[单例模式](/design-patterns/singleton) 

#### 返回

 [生成器模式](/design-patterns/builder)

 [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

本文是我们的电子书  
**《深入设计模式》**的一部分。

[了解更多……](/design-patterns/book)

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new.png?id=97d554614702483f31e38b32e82d8e34)](/) 

*   [会员专属内容](/store)
    *   [深入设计模式](/design-patterns/book)
    *   [Refactoring Course](/refactoring/course)
*   [设计模式](/design-patterns)
    *   [目录](/design-patterns/catalog)
    *   [创建型模式](/design-patterns/creational-patterns)
        *   [工厂方法模式](/design-patterns/factory-method)
        *   [抽象工厂模式](/design-patterns/abstract-factory)
        *   [生成器模式](/design-patterns/builder)
        *   [原型模式](/design-patterns/prototype)
        *   [单例模式](/design-patterns/singleton)
    *   [结构型模式](/design-patterns/structural-patterns)
        *   [适配器模式](/design-patterns/adapter)
        *   [桥接模式](/design-patterns/bridge)
        *   [组合模式](/design-patterns/composite)
        *   [装饰模式](/design-patterns/decorator)
        *   [外观模式](/design-patterns/facade)
        *   [享元模式](/design-patterns/flyweight)
        *   [代理模式](/design-patterns/proxy)
    *   [行为模式](/design-patterns/behavioral-patterns)
        *   [责任链模式](/design-patterns/chain-of-responsibility)
        *   [命令模式](/design-patterns/command)
        *   [迭代器模式](/design-patterns/iterator)
        *   [中介者模式](/design-patterns/mediator)
        *   [备忘录模式](/design-patterns/memento)
        *   [观察者模式](/design-patterns/observer)
        *   [状态模式](/design-patterns/state)
        *   [策略模式](/design-patterns/strategy)
        *   [模板方法模式](/design-patterns/template-method)
        *   [访问者模式](/design-patterns/visitor)
    *   [示例代码](/design-patterns/examples)
        *   [C#](/design-patterns/csharp)
        *   [C++](/design-patterns/cpp)
        *   [Go](/design-patterns/go)
        *   [Java](/design-patterns/java)
        *   [PHP](/design-patterns/php)
        *   [Python](/design-patterns/python)
        *   [Ruby](/design-patterns/ruby)
        *   [Rust](/design-patterns/rust)
        *   [Swift](/design-patterns/swift)
        *   [TypeScript](/design-patterns/typescript)
*   [重构未翻译](/refactoring)
    *   [What is Refactoring](/refactoring/what-is-refactoring)
        *   [Clean code](/refactoring/what-is-refactoring)
        *   [Technical debt](/refactoring/technical-debt)
        *   [When to refactor](/refactoring/when)
        *   [How to refactor](/refactoring/how-to)
    *   [Catalog](/refactoring/catalog)
    *   [Code Smells](/refactoring/smells)
        *   [Bloaters](/refactoring/smells/bloaters)
            *   [Long Method](/smells/long-method)
            *   [Large Class](/smells/large-class)
            *   [Primitive Obsession](/smells/primitive-obsession)
            *   [Long Parameter List](/smells/long-parameter-list)
            *   [Data Clumps](/smells/data-clumps)
        *   [Object-Orientation Abusers](/refactoring/smells/oo-abusers)
            *   [Switch Statements](/smells/switch-statements)
            *   [Temporary Field](/smells/temporary-field)
            *   [Refused Bequest](/smells/refused-bequest)
            *   [Alternative Classes with Different Interfaces](/smells/alternative-classes-with-different-interfaces)
        *   [Change Preventers](/refactoring/smells/change-preventers)
            *   [Divergent Change](/smells/divergent-change)
            *   [Shotgun Surgery](/smells/shotgun-surgery)
            *   [Parallel Inheritance Hierarchies](/smells/parallel-inheritance-hierarchies)
        *   [Dispensables](/refactoring/smells/dispensables)
            *   [Comments](/smells/comments)
            *   [Duplicate Code](/smells/duplicate-code)
            *   [Lazy Class](/smells/lazy-class)
            *   [Data Class](/smells/data-class)
            *   [Dead Code](/smells/dead-code)
            *   [Speculative Generality](/smells/speculative-generality)
        *   [Couplers](/refactoring/smells/couplers)
            *   [Feature Envy](/smells/feature-envy)
            *   [Inappropriate Intimacy](/smells/inappropriate-intimacy)
            *   [Message Chains](/smells/message-chains)
            *   [Middle Man](/smells/middle-man)
        *   [Other Smells](/refactoring/smells/other)
            *   [Incomplete Library Class](/smells/incomplete-library-class)
    *   [Refactorings](/refactoring/techniques)
        *   [Composing Methods](/refactoring/techniques/composing-methods)
            *   [Extract Method](/extract-method)
            *   [Inline Method](/inline-method)
            *   [Extract Variable](/extract-variable)
            *   [Inline Temp](/inline-temp)
            *   [Replace Temp with Query](/replace-temp-with-query)
            *   [Split Temporary Variable](/split-temporary-variable)
            *   [Remove Assignments to Parameters](/remove-assignments-to-parameters)
            *   [Replace Method with Method Object](/replace-method-with-method-object)
            *   [Substitute Algorithm](/substitute-algorithm)
        *   [Moving Features between Objects](/refactoring/techniques/moving-features-between-objects)
            *   [Move Method](/move-method)
            *   [Move Field](/move-field)
            *   [Extract Class](/extract-class)
            *   [Inline Class](/inline-class)
            *   [Hide Delegate](/hide-delegate)
            *   [Remove Middle Man](/remove-middle-man)
            *   [Introduce Foreign Method](/introduce-foreign-method)
            *   [Introduce Local Extension](/introduce-local-extension)
        *   [Organizing Data](/refactoring/techniques/organizing-data)
            *   [Self Encapsulate Field](/self-encapsulate-field)
            *   [Replace Data Value with Object](/replace-data-value-with-object)
            *   [Change Value to Reference](/change-value-to-reference)
            *   [Change Reference to Value](/change-reference-to-value)
            *   [Replace Array with Object](/replace-array-with-object)
            *   [Duplicate Observed Data](/duplicate-observed-data)
            *   [Change Unidirectional Association to Bidirectional](/change-unidirectional-association-to-bidirectional)
            *   [Change Bidirectional Association to Unidirectional](/change-bidirectional-association-to-unidirectional)
            *   [Replace Magic Number with Symbolic Constant](/replace-magic-number-with-symbolic-constant)
            *   [Encapsulate Field](/encapsulate-field)
            *   [Encapsulate Collection](/encapsulate-collection)
            *   [Replace Type Code with Class](/replace-type-code-with-class)
            *   [Replace Type Code with Subclasses](/replace-type-code-with-subclasses)
            *   [Replace Type Code with State/Strategy](/replace-type-code-with-state-strategy)
            *   [Replace Subclass with Fields](/replace-subclass-with-fields)
        *   [Simplifying Conditional Expressions](/refactoring/techniques/simplifying-conditional-expressions)
            *   [Decompose Conditional](/decompose-conditional)
            *   [Consolidate Conditional Expression](/consolidate-conditional-expression)
            *   [Consolidate Duplicate Conditional Fragments](/consolidate-duplicate-conditional-fragments)
            *   [Remove Control Flag](/remove-control-flag)
            *   [Replace Nested Conditional with Guard Clauses](/replace-nested-conditional-with-guard-clauses)
            *   [Replace Conditional with Polymorphism](/replace-conditional-with-polymorphism)
            *   [Introduce Null Object](/introduce-null-object)
            *   [Introduce Assertion](/introduce-assertion)
        *   [Simplifying Method Calls](/refactoring/techniques/simplifying-method-calls)
            *   [Rename Method](/rename-method)
            *   [Add Parameter](/add-parameter)
            *   [Remove Parameter](/remove-parameter)
            *   [Separate Query from Modifier](/separate-query-from-modifier)
            *   [Parameterize Method](/parameterize-method)
            *   [Replace Parameter with Explicit Methods](/replace-parameter-with-explicit-methods)
            *   [Preserve Whole Object](/preserve-whole-object)
            *   [Replace Parameter with Method Call](/replace-parameter-with-method-call)
            *   [Introduce Parameter Object](/introduce-parameter-object)
            *   [Remove Setting Method](/remove-setting-method)
            *   [Hide Method](/hide-method)
            *   [Replace Constructor with Factory Method](/replace-constructor-with-factory-method)
            *   [Replace Error Code with Exception](/replace-error-code-with-exception)
            *   [Replace Exception with Test](/replace-exception-with-test)
        *   [Dealing with Generalization](/refactoring/techniques/dealing-with-generalization)
            *   [Pull Up Field](/pull-up-field)
            *   [Pull Up Method](/pull-up-method)
            *   [Pull Up Constructor Body](/pull-up-constructor-body)
            *   [Push Down Method](/push-down-method)
            *   [Push Down Field](/push-down-field)
            *   [Extract Subclass](/extract-subclass)
            *   [Extract Superclass](/extract-superclass)
            *   [Extract Interface](/extract-interface)
            *   [Collapse Hierarchy](/collapse-hierarchy)
            *   [Form Template Method](/form-template-method)
            *   [Replace Inheritance with Delegation](/replace-inheritance-with-delegation)
            *   [Replace Delegation with Inheritance](/replace-delegation-with-inheritance)

[登录](https://refactoring.guru/zh/login "登录") [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans "联系我们")

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new-mobile.png?id=ea18aa9b032eaa92835ed6d472b03b4a)](/) [ 我的商店](/store)

*   中文 [English](https://refactoring.guru/design-patterns/prototype "English") [Español](https://refactoring.guru/es/design-patterns/prototype "Español") [Français](https://refactoring.guru/fr/design-patterns/prototype "Français") [日本語](https://refactoring.guru/ja/design-patterns/prototype "日本語") [한국어](https://refactoring.guru/ko/design-patterns/prototype "한국어") [Polski](https://refactoring.guru/pl/design-patterns/prototype "Polski") [Português Brasileiro](https://refactoring.guru/pt-br/design-patterns/prototype "Português Brasileiro") [Русский](https://refactoring.guru/ru/design-patterns/prototype "Русский") [Українська](https://refactoring.guru/uk/design-patterns/prototype "Українська") [中文](https://refactoringguru.cn/design-patterns/prototype "中文")
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true "联系我们")
*   [登录](https://refactoring.guru/zh/login "登录")

*   [主页](/)
*   [重构](/refactoring)
*   [设计模式](/design-patterns)
*   [会员专属内容](/store)
*   [论坛](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans)
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true)

2014-2023 [Refactoring.Guru](/). 版权所有  
图片作者： [Dmitry Zhart](http://zhart.us/) **Ukrainian office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) FOP Olga Skobeleva  
Abolmasova 7  
Kyiv, Ukraine, 02002  
Email: support@refactoring.guru **Spanish office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) Oleksandr Shvets  
Avda Pamplona 63, 4b  
Pamplona, Spain, 31010  
Email: spain@refactoring.guru

*   [条款与政策](/terms)
*   [隐私政策](/privacy-policy)
*   [内容使用政策](/content-usage-policy)
*   [About us](/site-about)