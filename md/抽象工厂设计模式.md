> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/abstract-factory)

抽象工厂意图
--
**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

问题
--
假设你正在开发一款家具商店模拟器
 - 一系列产品及其不同变体，
 - 你不希望在添加新产品或新风格时修改已有代码。

解决方案
----

 以不同的产品类型与产品变体为维度绘制矩阵。

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 
- 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推。
- 实际上就是同一对象的所有变体都必须放置在同一个类层次结构之中。

接下来， 我们需要声明抽象工厂——包含系列中所有产品构造方法的接口。 
- 例如 `create­Chair`创建椅子 、 ​ `create­Sofa`创建沙发
- 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口

最后，每个具体工厂类都对应一个特定的产品变体。
- 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 
- 例如， ​ `现代家具工厂`Modern­Furniture­Factory 只能创建 `现代椅子`Modern­Chair 

---

客户端代码可以通过相应的抽象接口调用工厂和产品类。 
- 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。
- 客户端无需了解其所调用工厂的具体类信息。


最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下，
初始化代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 
然后将该工厂对象传递给所有需要创建产品的类。
找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

抽象工厂模式结构
--------

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure-indexed.png)


尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 
- 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 
- **客户端** （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂 / 产品变体交互。

伪代码
---

下面例子通过应用**抽象工厂**模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/example.png)
```java
// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂
// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。
class Application is
    private field factory: GUIFactory
    private field button: Button
    constructor Application(factory: GUIFactory) is
        this.factory = factory
    method createUI() is
        this.button = factory.createButton()
    method paint() is
        button.paint()


// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初
// 始化阶段）。
class ApplicationConfigurator is
    method main() is
        config = readApplicationConfigFile()
        if (config.OS == "Windows") then
            factory = new WinFactory()
        else if (config.OS == "Mac") then
            factory = new MacFactory()
        else
            throw new Exception("错误！未知的操作系统。")

        Application app = new Application(factory)
```

抽象工厂模式适合应用场景
------------

如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。

每个类仅负责一件事。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

抽象工厂模式优缺点
---------

*   你可以确保同一工厂生成的产品相互匹配。
*   你可以避免客户端和具体产品代码的耦合。
*   _单一职责原则_。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
*   _开闭原则_。 向应用程序中引入新产品变体时， 你无需修改客户端代码。

*   由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

与其他模式的关系
--------
*   在许多设计工作的初期都会使用[工厂方法模式](/design-patterns/factory-method) （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](/design-patterns/abstract-factory)、 [原型模式](/design-patterns/prototype)或[生成器模式](/design-patterns/builder) （更灵活但更加复杂）。

---
*  [生成器](/design-patterns/builder)重点关注如何分步生成复杂对象。 [抽象工厂](/design-patterns/abstract-factory)专门用于生产一系列相关对象。 
* 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。 

* [抽象工厂模式](/design-patterns/abstract-factory)通常基于一组[工厂方法](/design-patterns/factory-method)， 但你也可以使用[原型模式](/design-patterns/prototype)来生成这些类的方法。
*   当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[抽象工厂](/design-patterns/abstract-factory)来代替[外观模式](/design-patterns/facade)