> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/abstract-factory)

> 工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![](https://refactoringguru.cn/images/content-public/sunbed.svg?id=b1e7314a63715a13870a6bd1a43613f7)

 [](#checkout) [](#checkout)

[](/)/ [设计模式](/design-patterns) / [创建型模式](/design-patterns/creational-patterns)

抽象工厂模式
======

亦称： Abstract Factory

意图
--

**抽象工厂模式**是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。

![](https://refactoringguru.cn/images/patterns/content/abstract-factory/abstract-factory-zh.png)

问题
--

假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：

1.  一系列相关产品， 例如 `椅子`Chair 、 ​ `沙发`Sofa 和 `咖啡桌`Coffee­Table 。
    
2.  系列产品的不同变体。 例如， 你可以使用 `现代`Modern 、 ​ `维多利亚`Victorian 、 ​ `装饰风艺术`Art­Deco 等风格生成 `椅子` 、 ​ `沙发`和 `咖啡桌` 。
    

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/problem-zh.png)

系列产品及其不同变体。

你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。

![](https://refactoringguru.cn/images/patterns/content/abstract-factory/abstract-factory-comic-1-zh.png)

现代风格的沙发和维多利亚风格的椅子不搭。

此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。

解决方案
----

首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 `椅子`接口； 所有风格的咖啡桌都实现 `咖啡桌`接口， 以此类推。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/solution1.png)

同一对象的所有变体都必须放置在同一个类层次结构之中。

接下来， 我们需要声明_抽象工厂_——包含系列中所有产品构造方法的接口。 例如 `create­Chair`创建椅子 、 ​ `create­Sofa`创建沙发和 `create­Coffee­Table`创建咖啡桌 。 这些方法必须返回**抽象**产品类型， 即我们之前抽取的那些接口： ​ `椅子` ， ​ `沙发`和 `咖啡桌`等等。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/solution2.png)

每个具体工厂类都对应一个特定的产品变体。

那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 `抽象工厂`接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如， ​ `现代家具工厂`Modern­Furniture­Factory 只能创建 `现代椅子`Modern­Chair 、 ​ `现代沙发`Modern­Sofa 和 `现代咖啡桌`Modern­Coffee­Table 对象。

客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。

![](https://refactoringguru.cn/images/patterns/content/abstract-factory/abstract-factory-comic-2-zh.png)

客户端无需了解其所调用工厂的具体类信息。

假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 `椅子`接口就可以了。 这样一来， 客户端只需知道椅子以某种方式实现了 `sit­On`坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。

最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。

抽象工厂模式结构
--------

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure.png)![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/structure-indexed.png)

1.  **抽象产品** （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。
    
2.  **具体产品** （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚 / 现代） 都必须实现相应的抽象产品 （椅子 / 沙发）。
    
3.  **抽象工厂** （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。
    
4.  **具体工厂** （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
    
5.  尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的_抽象_产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 **客户端** （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂 / 产品变体交互。
    

@media (min-width: 1200px) { .structure { margin: 0; width: auto; height: 550px; } .struct-image1 { left: 160px; top: 10px; } .struct-li1 { left: 0px; top: 170px; width: 150px; } .struct-li2 { left: 0px; top: 10px; width: 320px; } .struct-li3 { left: 610px; top: 60px; width: 220px; } .struct-li4 { left: 290px; top: 480px; width: 290px; } .struct-li5 { left: 620px; top: 360px; width: 220px; } }

伪代码
---

下面例子通过应用**抽象工厂**模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。

![](https://refactoringguru.cn/images/patterns/diagrams/abstract-factory/example.png)

跨平台 UI 类示例。

跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。

抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。

其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。

使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。

这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。

```
// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列
// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产
// 品可有多个变体，但不同变体的产品不能搭配使用。
interface GUIFactory is
    method createButton():Button
    method createCheckbox():Checkbox


// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配
// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进
// 行实例化。
class WinFactory implements GUIFactory is
    method createButton():Button is
        return new WinButton()
    method createCheckbox():Checkbox is
        return new WinCheckbox()

// 每个具体工厂中都会包含一个相应的产品变体。
class MacFactory implements GUIFactory is
    method createButton():Button is
        return new MacButton()
    method createCheckbox():Checkbox is
        return new MacCheckbox()


// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。
interface Button is
    method paint()

// 具体产品由相应的具体工厂创建。
class WinButton implements Button is
    method paint() is
        // 根据 Windows 样式渲染按钮。

class MacButton implements Button is
    method paint() is
        // 根据 macOS 样式渲染按钮

// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产
// 品之间才能够正确地进行交互。
interface Checkbox is
    method paint()

class WinCheckbox implements Checkbox is
    method paint() is
        // 根据 Windows 样式渲染复选框。

class MacCheckbox implements Checkbox is
    method paint() is
        // 根据 macOS 样式渲染复选框。

// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂
// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。
class Application is
    private field factory: GUIFactory
    private field button: Button
    constructor Application(factory: GUIFactory) is
        this.factory = factory
    method createUI() is
        this.button = factory.createButton()
    method paint() is
        button.paint()


// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初
// 始化阶段）。
class ApplicationConfigurator is
    method main() is
        config = readApplicationConfigFile()

        if (config.OS == "Windows") then
            factory = new WinFactory()
        else if (config.OS == "Mac") then
            factory = new MacFactory()
        else
            throw new Exception("错误！未知的操作系统。")

        Application app = new Application(factory)
```

抽象工厂模式适合应用场景
------------

如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。

抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。

如果你有一个基于一组[抽象方法](/design-patterns/factory-method)的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

在设计良好的程序中， _每个类仅负责一件事_。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。

实现方式
----

1.  以不同的产品类型与产品变体为维度绘制矩阵。
    
2.  为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
    
3.  声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
    
4.  为每种产品变体实现一个具体工厂类。
    
5.  在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
    
6.  找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。
    

抽象工厂模式优缺点
---------

*   你可以确保同一工厂生成的产品相互匹配。
*   你可以避免客户端和具体产品代码的耦合。
*   _单一职责原则_。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
*   _开闭原则_。 向应用程序中引入新产品变体时， 你无需修改客户端代码。

*   由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

与其他模式的关系
--------

*   在许多设计工作的初期都会使用[工厂方法模式](/design-patterns/factory-method) （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用[抽象工厂模式](/design-patterns/abstract-factory)、 [原型模式](/design-patterns/prototype)或[生成器模式](/design-patterns/builder) （更灵活但更加复杂）。
    
*   [生成器](/design-patterns/builder)重点关注如何分步生成复杂对象。 [抽象工厂](/design-patterns/abstract-factory)专门用于生产一系列相关对象。 _抽象工厂_会马上返回产品， _生成器_则允许你在获取产品前执行一些额外构造步骤。
    
*   [抽象工厂模式](/design-patterns/abstract-factory)通常基于一组[工厂方法](/design-patterns/factory-method)， 但你也可以使用[原型模式](/design-patterns/prototype)来生成这些类的方法。
    
*   当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用[抽象工厂](/design-patterns/abstract-factory)来代替[外观模式](/design-patterns/facade)。
    
*   你可以将[抽象工厂](/design-patterns/abstract-factory)和[桥接模式](/design-patterns/bridge)搭配使用。 如果由_桥接_定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， _抽象工厂_可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。
    
*   [抽象工厂](/design-patterns/abstract-factory)、 [生成器](/design-patterns/builder)和[原型](/design-patterns/prototype)都可以用[单例模式](/design-patterns/singleton)来实现。
    

代码示例
----

[![](https://refactoringguru.cn/images/patterns/icons/csharp.svg?id=da64592defc6e86d57c39c66e9de3e58)](/design-patterns/abstract-factory/csharp/example "C# 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/cpp.svg?id=f7782ed8b8666246bfcc3f8fefc3b858)](/design-patterns/abstract-factory/cpp/example "C++ 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/go.svg?id=1a89927eb99b1ea3fde7701d97970aca)](/design-patterns/abstract-factory/go/example "Go 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/java.svg?id=e6d87e2dca08c953fe3acd1275ed4f4e)](/design-patterns/abstract-factory/java/example "Java 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/php.svg?id=be1906eb26b71ec1d3b93720d6156618)](/design-patterns/abstract-factory/php/example "PHP 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/python.svg?id=6d815d43c0f7050a1151b43e51569c9f)](/design-patterns/abstract-factory/python/example "Python 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/ruby.svg?id=b065b718c914bf8e960ef731600be1eb)](/design-patterns/abstract-factory/ruby/example "Ruby 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/rust.svg?id=1f5698a4b5ae23fe79413511747e4a87)](/design-patterns/abstract-factory/rust/example "Rust 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/swift.svg?id=0b716c2d52ec3a48fbe91ac031070c1d)](/design-patterns/abstract-factory/swift/example "Swift 抽象工厂模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/typescript.svg?id=2239d0f16cb703540c205dd8cb0c0cb7)](/design-patterns/abstract-factory/typescript/example "TypeScript 抽象工厂模式讲解和代码示例")

额外内容
----

*   如果你希望了解不同工厂模式和概念之间的区别， 可参阅我们的[工厂模式比较指南](/design-patterns/factory-comparison)。

 [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-3.png?id=7d445df13c80287beaab234b4f3b698c)](/design-patterns/book) 

### 支持我们的免费网站并获得电子书！

*   22 个设计模式和 8 条原则的详细讲解。
*   382 页精心编排、易于阅读且没有术语的内容。
*   225 幅有助于理解的简明图表。
*   11 种编程语言的代码示例档案。
*   支持所有的设备：PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [<video src="" control></video>](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   我们必须承认：在网页上阅读没有一点趣味！
*   在通勤途中做些有价值的事情。
*   在沙发上放松时学些新东西。
*   包含实用的面向对象程序设计的伪代码示例。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-1-b.png?id=0877cab2f0102d98cd07b50af0e5beea)](/design-patterns/book) 

### 为什么你应该在通勤途中带着这本电子书？

*   你将在上班路上学些有用的东西。
*   无需互联网连接：随时可用还可进行搜索。
*   可选择多种阅读模式以便轻松阅读。
*   少带一件东西，永远不会忘记。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-4.png?id=87deabea80734585e2cda786f05dd7f6)](/design-patterns/book) 

### 为什么你应该在床上阅读这本电子书？

*   与刷视频相比，它更能更好地激发灵感。
*   与其它选择相比，它能让你更好地放松。
*   与其虚度光阴，还不如做些富有成效的事！
*   提供夜间阅读模式以便轻松阅读。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-2.png?id=ef3f7b0bdfe11e2cdad1e64a40db87da)](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   **初学者：**学习基础模式及其运作方式！
*   **专家：**可把本书当作一本便捷的、易于搜索的参考书！
*   **与语言无关：**提供 PHP、C# 和 Java 等语言的示例！
*   详细说明 22 个设计模式及其背后的 8 条原则。
*   382 页结构清晰、便于阅读且没有术语的内容。
*   225 幅清晰实用的插图和图表。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

### 为什么我们需要了解设计模式？

*   **轻松应对面试和审核。**关于模式的问题总是一再出现。
*   获得你应得的加薪和升职！
*   **扩展你的工具箱**，在其中添加经过验证且没有问题的代码示例。
*   定制现成的解决方案。不要重新开发所有内容。
*   **更好地与同事沟通**，无需冗长的解释。
*   只需指出设计模式的名称，你就能轻松解决问题！

[了解更多……](/design-patterns/book)

#### 继续阅读

[工厂模式比较](/design-patterns/factory-comparison) 

#### 返回

 [工厂方法模式](/design-patterns/factory-method)

 [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

本文是我们的电子书  
**《深入设计模式》**的一部分。

[了解更多……](/design-patterns/book)

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new.png?id=97d554614702483f31e38b32e82d8e34)](/) 

*   [会员专属内容](/store)
    *   [深入设计模式](/design-patterns/book)
    *   [Refactoring Course](/refactoring/course)
*   [设计模式](/design-patterns)
    *   [目录](/design-patterns/catalog)
    *   [创建型模式](/design-patterns/creational-patterns)
        *   [工厂方法模式](/design-patterns/factory-method)
        *   [抽象工厂模式](/design-patterns/abstract-factory)
        *   [生成器模式](/design-patterns/builder)
        *   [原型模式](/design-patterns/prototype)
        *   [单例模式](/design-patterns/singleton)
    *   [结构型模式](/design-patterns/structural-patterns)
        *   [适配器模式](/design-patterns/adapter)
        *   [桥接模式](/design-patterns/bridge)
        *   [组合模式](/design-patterns/composite)
        *   [装饰模式](/design-patterns/decorator)
        *   [外观模式](/design-patterns/facade)
        *   [享元模式](/design-patterns/flyweight)
        *   [代理模式](/design-patterns/proxy)
    *   [行为模式](/design-patterns/behavioral-patterns)
        *   [责任链模式](/design-patterns/chain-of-responsibility)
        *   [命令模式](/design-patterns/command)
        *   [迭代器模式](/design-patterns/iterator)
        *   [中介者模式](/design-patterns/mediator)
        *   [备忘录模式](/design-patterns/memento)
        *   [观察者模式](/design-patterns/observer)
        *   [状态模式](/design-patterns/state)
        *   [策略模式](/design-patterns/strategy)
        *   [模板方法模式](/design-patterns/template-method)
        *   [访问者模式](/design-patterns/visitor)
    *   [示例代码](/design-patterns/examples)
        *   [C#](/design-patterns/csharp)
        *   [C++](/design-patterns/cpp)
        *   [Go](/design-patterns/go)
        *   [Java](/design-patterns/java)
        *   [PHP](/design-patterns/php)
        *   [Python](/design-patterns/python)
        *   [Ruby](/design-patterns/ruby)
        *   [Rust](/design-patterns/rust)
        *   [Swift](/design-patterns/swift)
        *   [TypeScript](/design-patterns/typescript)
*   [重构未翻译](/refactoring)
    *   [What is Refactoring](/refactoring/what-is-refactoring)
        *   [Clean code](/refactoring/what-is-refactoring)
        *   [Technical debt](/refactoring/technical-debt)
        *   [When to refactor](/refactoring/when)
        *   [How to refactor](/refactoring/how-to)
    *   [Catalog](/refactoring/catalog)
    *   [Code Smells](/refactoring/smells)
        *   [Bloaters](/refactoring/smells/bloaters)
            *   [Long Method](/smells/long-method)
            *   [Large Class](/smells/large-class)
            *   [Primitive Obsession](/smells/primitive-obsession)
            *   [Long Parameter List](/smells/long-parameter-list)
            *   [Data Clumps](/smells/data-clumps)
        *   [Object-Orientation Abusers](/refactoring/smells/oo-abusers)
            *   [Switch Statements](/smells/switch-statements)
            *   [Temporary Field](/smells/temporary-field)
            *   [Refused Bequest](/smells/refused-bequest)
            *   [Alternative Classes with Different Interfaces](/smells/alternative-classes-with-different-interfaces)
        *   [Change Preventers](/refactoring/smells/change-preventers)
            *   [Divergent Change](/smells/divergent-change)
            *   [Shotgun Surgery](/smells/shotgun-surgery)
            *   [Parallel Inheritance Hierarchies](/smells/parallel-inheritance-hierarchies)
        *   [Dispensables](/refactoring/smells/dispensables)
            *   [Comments](/smells/comments)
            *   [Duplicate Code](/smells/duplicate-code)
            *   [Lazy Class](/smells/lazy-class)
            *   [Data Class](/smells/data-class)
            *   [Dead Code](/smells/dead-code)
            *   [Speculative Generality](/smells/speculative-generality)
        *   [Couplers](/refactoring/smells/couplers)
            *   [Feature Envy](/smells/feature-envy)
            *   [Inappropriate Intimacy](/smells/inappropriate-intimacy)
            *   [Message Chains](/smells/message-chains)
            *   [Middle Man](/smells/middle-man)
        *   [Other Smells](/refactoring/smells/other)
            *   [Incomplete Library Class](/smells/incomplete-library-class)
    *   [Refactorings](/refactoring/techniques)
        *   [Composing Methods](/refactoring/techniques/composing-methods)
            *   [Extract Method](/extract-method)
            *   [Inline Method](/inline-method)
            *   [Extract Variable](/extract-variable)
            *   [Inline Temp](/inline-temp)
            *   [Replace Temp with Query](/replace-temp-with-query)
            *   [Split Temporary Variable](/split-temporary-variable)
            *   [Remove Assignments to Parameters](/remove-assignments-to-parameters)
            *   [Replace Method with Method Object](/replace-method-with-method-object)
            *   [Substitute Algorithm](/substitute-algorithm)
        *   [Moving Features between Objects](/refactoring/techniques/moving-features-between-objects)
            *   [Move Method](/move-method)
            *   [Move Field](/move-field)
            *   [Extract Class](/extract-class)
            *   [Inline Class](/inline-class)
            *   [Hide Delegate](/hide-delegate)
            *   [Remove Middle Man](/remove-middle-man)
            *   [Introduce Foreign Method](/introduce-foreign-method)
            *   [Introduce Local Extension](/introduce-local-extension)
        *   [Organizing Data](/refactoring/techniques/organizing-data)
            *   [Self Encapsulate Field](/self-encapsulate-field)
            *   [Replace Data Value with Object](/replace-data-value-with-object)
            *   [Change Value to Reference](/change-value-to-reference)
            *   [Change Reference to Value](/change-reference-to-value)
            *   [Replace Array with Object](/replace-array-with-object)
            *   [Duplicate Observed Data](/duplicate-observed-data)
            *   [Change Unidirectional Association to Bidirectional](/change-unidirectional-association-to-bidirectional)
            *   [Change Bidirectional Association to Unidirectional](/change-bidirectional-association-to-unidirectional)
            *   [Replace Magic Number with Symbolic Constant](/replace-magic-number-with-symbolic-constant)
            *   [Encapsulate Field](/encapsulate-field)
            *   [Encapsulate Collection](/encapsulate-collection)
            *   [Replace Type Code with Class](/replace-type-code-with-class)
            *   [Replace Type Code with Subclasses](/replace-type-code-with-subclasses)
            *   [Replace Type Code with State/Strategy](/replace-type-code-with-state-strategy)
            *   [Replace Subclass with Fields](/replace-subclass-with-fields)
        *   [Simplifying Conditional Expressions](/refactoring/techniques/simplifying-conditional-expressions)
            *   [Decompose Conditional](/decompose-conditional)
            *   [Consolidate Conditional Expression](/consolidate-conditional-expression)
            *   [Consolidate Duplicate Conditional Fragments](/consolidate-duplicate-conditional-fragments)
            *   [Remove Control Flag](/remove-control-flag)
            *   [Replace Nested Conditional with Guard Clauses](/replace-nested-conditional-with-guard-clauses)
            *   [Replace Conditional with Polymorphism](/replace-conditional-with-polymorphism)
            *   [Introduce Null Object](/introduce-null-object)
            *   [Introduce Assertion](/introduce-assertion)
        *   [Simplifying Method Calls](/refactoring/techniques/simplifying-method-calls)
            *   [Rename Method](/rename-method)
            *   [Add Parameter](/add-parameter)
            *   [Remove Parameter](/remove-parameter)
            *   [Separate Query from Modifier](/separate-query-from-modifier)
            *   [Parameterize Method](/parameterize-method)
            *   [Replace Parameter with Explicit Methods](/replace-parameter-with-explicit-methods)
            *   [Preserve Whole Object](/preserve-whole-object)
            *   [Replace Parameter with Method Call](/replace-parameter-with-method-call)
            *   [Introduce Parameter Object](/introduce-parameter-object)
            *   [Remove Setting Method](/remove-setting-method)
            *   [Hide Method](/hide-method)
            *   [Replace Constructor with Factory Method](/replace-constructor-with-factory-method)
            *   [Replace Error Code with Exception](/replace-error-code-with-exception)
            *   [Replace Exception with Test](/replace-exception-with-test)
        *   [Dealing with Generalization](/refactoring/techniques/dealing-with-generalization)
            *   [Pull Up Field](/pull-up-field)
            *   [Pull Up Method](/pull-up-method)
            *   [Pull Up Constructor Body](/pull-up-constructor-body)
            *   [Push Down Method](/push-down-method)
            *   [Push Down Field](/push-down-field)
            *   [Extract Subclass](/extract-subclass)
            *   [Extract Superclass](/extract-superclass)
            *   [Extract Interface](/extract-interface)
            *   [Collapse Hierarchy](/collapse-hierarchy)
            *   [Form Template Method](/form-template-method)
            *   [Replace Inheritance with Delegation](/replace-inheritance-with-delegation)
            *   [Replace Delegation with Inheritance](/replace-delegation-with-inheritance)

[登录](https://refactoring.guru/zh/login "登录") [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans "联系我们")

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new-mobile.png?id=ea18aa9b032eaa92835ed6d472b03b4a)](/) [ 我的商店](/store)

*   中文 [English](https://refactoring.guru/design-patterns/abstract-factory "English") [Español](https://refactoring.guru/es/design-patterns/abstract-factory "Español") [Français](https://refactoring.guru/fr/design-patterns/abstract-factory "Français") [日本語](https://refactoring.guru/ja/design-patterns/abstract-factory "日本語") [한국어](https://refactoring.guru/ko/design-patterns/abstract-factory "한국어") [Polski](https://refactoring.guru/pl/design-patterns/abstract-factory "Polski") [Português Brasileiro](https://refactoring.guru/pt-br/design-patterns/abstract-factory "Português Brasileiro") [Русский](https://refactoring.guru/ru/design-patterns/abstract-factory "Русский") [Українська](https://refactoring.guru/uk/design-patterns/abstract-factory "Українська") [中文](https://refactoringguru.cn/design-patterns/abstract-factory "中文")
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true "联系我们")
*   [登录](https://refactoring.guru/zh/login "登录")

*   [主页](/)
*   [重构](/refactoring)
*   [设计模式](/design-patterns)
*   [会员专属内容](/store)
*   [论坛](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans)
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true)

2014-2023 [Refactoring.Guru](/). 版权所有  
图片作者： [Dmitry Zhart](http://zhart.us/) **Ukrainian office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) FOP Olga Skobeleva  
Abolmasova 7  
Kyiv, Ukraine, 02002  
Email: support@refactoring.guru **Spanish office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) Oleksandr Shvets  
Avda Pamplona 63, 4b  
Pamplona, Spain, 31010  
Email: spain@refactoring.guru

*   [条款与政策](/terms)
*   [隐私政策](/privacy-policy)
*   [内容使用政策](/content-usage-policy)
*   [About us](/site-about)