> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/singleton)

> 工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![](https://refactoringguru.cn/images/content-public/sunbed.svg?id=b1e7314a63715a13870a6bd1a43613f7) [   ](#checkout)[](#checkout) 

[](/)/ [设计模式](/design-patterns) / [创建型模式](/design-patterns/creational-patterns)

单例模式
====

亦称： 单件模式、Singleton

意图
--

**单例模式**是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。

![](https://refactoringguru.cn/images/patterns/content/singleton/singleton.png)

问题
--

单例模式同时解决了两个问题， 所以违反了_单一职责原则_：

1.  **保证一个类只有一个实例**。 为什么会有人想要控制一个类所拥有的实例数量？ 最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。
    
    它的运作方式是这样的： 如果你创建了一个对象， 同时过一会儿后你决定再创建一个新对象， 此时你会获得之前已创建的对象， 而不是一个新对象。
    
    注意， 普通构造函数无法实现上述行为， 因为构造函数的设计决定了它**必须**总是返回一个新对象。
    

![](https://refactoringguru.cn/images/patterns/content/singleton/singleton-comic-1-zh.png)

客户端甚至可能没有意识到它们一直都在使用同一个对象。

2.  **为该实例提供一个全局访问节点**。 还记得你 （好吧， 其实是我自己） 用过的那些存储重要对象的全局变量吗？ 它们在使用上十分方便， 但同时也非常不安全， 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。
    
    和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。
    
    还有一点： 你不会希望解决同一个问题的代码分散在程序各处的。 因此更好的方式是将其放在同一个类中， 特别是当其他代码已经依赖这个类时更应该如此。
    

如今， 单例模式已经变得非常流行， 以至于人们会将只解决上文描述中任意一个问题的东西称为_单例_。

解决方案
----

所有单例的实现都包含以下两个相同的步骤：

*   将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。
*   新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。

真实世界类比
------

政府是单例模式的一个很好的示例。 一个国家只有一个官方政府。 不管组成政府的每个人的身份是什么， ​ “某政府” 这一称谓总是鉴别那些掌权者的全局访问节点。

单例模式结构
------

![](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh.png)![](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh-indexed.png)

1.  **单例** （Singleton） 类声明了一个名为 `get­Instance`获取实例的静态方法来返回其所属类的一个相同实例。
    
    单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `获取实例`方法必须是获取单例对象的唯一方式。
    

@media (min-width: 1200px) { .structure { margin: 0; width: auto; height: 380px; } .struct-image1 { left: 160px; top: 20px; } .struct-li1 { left: 10px; top: 170px; width: 270px; } }

伪代码
---

在本例中， 数据库连接类即是一个**单例**。 该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 `获取实例`方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。

```
// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处
// 都能访问相同的数据库连接实例。
class Database is
    // 保存单例实例的成员变量必须被声明为静态类型。
    private static field instance: Database

    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构
    // 造方法。
    private constructor Database() is
        // 部分初始化代码（例如到数据库服务器的实际连接）。
        // ……

    // 用于控制对单例实例的访问权限的静态方法。
    public static method getInstance() is
        if (Database.instance == null) then
            acquireThreadLock() and then
                // 确保在该线程等待解锁时，其他线程没有初始化该实例。
                if (Database.instance == null) then
                    Database.instance = new Database()
        return Database.instance

    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。
    public method query(sql) is
        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以
        // 在这里添加限流或缓冲逻辑。
        // ……

class Application is
    method main() is
        Database foo = Database.getInstance()
        foo.query("SELECT ……")
        // ……
        Database bar = Database.getInstance()
        bar.query("SELECT ……")
        // 变量 `bar` 和 `foo` 中将包含同一个对象。
```

单例模式适合应用场景
----------

如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。

单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。

如果你需要更加严格地控制全局变量， 可以使用单例模式。

单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。

请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 `获取实例`方法， 即 getInstance 中的代码即可实现。

实现方式
----

1.  在类中添加一个私有静态成员变量用于保存单例实例。
    
2.  声明一个公有静态构建方法用于获取单例实例。
    
3.  在静态方法中实现 "延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。
    
4.  将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。
    
5.  检查客户端代码， 将对单例的构造函数的调用替换为对其静态构建方法的调用。
    

单例模式优缺点
-------

*   你可以保证一个类只有一个实例。
*   你获得了一个指向该实例的全局访问节点。
*   仅在首次请求单例对象时对其进行初始化。

*   违反了_单一职责原则_。 该模式同时解决了两个问题。
*   单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。
*   该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
*   单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。

与其他模式的关系
--------

*   [外观模式](/design-patterns/facade)类通常可以转换为[单例模式](/design-patterns/singleton)类， 因为在大部分情况下一个外观对象就足够了。
    
*   如果你能将对象的所有共享状态简化为一个享元对象， 那么[享元模式](/design-patterns/flyweight)就和[单例](/design-patterns/singleton)类似了。 但这两个模式有两个根本性的不同。
    
    1.  只会有一个单例实体， 但是_享元_类可以有多个实体， 各实体的内在状态也可以不同。
    2.  _单例_对象可以是可变的。 享元对象是不可变的。
*   [抽象工厂模式](/design-patterns/abstract-factory)、 [生成器模式](/design-patterns/builder)和[原型模式](/design-patterns/prototype)都可以用[单例](/design-patterns/singleton)来实现。
    

代码示例
----

[![](https://refactoringguru.cn/images/patterns/icons/csharp.svg?id=da64592defc6e86d57c39c66e9de3e58)](/design-patterns/singleton/csharp/example "C# 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/cpp.svg?id=f7782ed8b8666246bfcc3f8fefc3b858)](/design-patterns/singleton/cpp/example "C++ 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/go.svg?id=1a89927eb99b1ea3fde7701d97970aca)](/design-patterns/singleton/go/example "Go 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/java.svg?id=e6d87e2dca08c953fe3acd1275ed4f4e)](/design-patterns/singleton/java/example "Java 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/php.svg?id=be1906eb26b71ec1d3b93720d6156618)](/design-patterns/singleton/php/example "PHP 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/python.svg?id=6d815d43c0f7050a1151b43e51569c9f)](/design-patterns/singleton/python/example "Python 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/ruby.svg?id=b065b718c914bf8e960ef731600be1eb)](/design-patterns/singleton/ruby/example "Ruby 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/rust.svg?id=1f5698a4b5ae23fe79413511747e4a87)](/design-patterns/singleton/rust/example "Rust 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/swift.svg?id=0b716c2d52ec3a48fbe91ac031070c1d)](/design-patterns/singleton/swift/example "Swift 单例模式讲解和代码示例") [![](https://refactoringguru.cn/images/patterns/icons/typescript.svg?id=2239d0f16cb703540c205dd8cb0c0cb7)](/design-patterns/singleton/typescript/example "TypeScript 单例模式讲解和代码示例")

 [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-3.png?id=7d445df13c80287beaab234b4f3b698c)](/design-patterns/book) 

### 支持我们的免费网站并获得电子书！

*   22 个设计模式和 8 条原则的详细讲解。
*   382 页精心编排、易于阅读且没有术语的内容。
*   225 幅有助于理解的简明图表。
*   11 种编程语言的代码示例档案。
*   支持所有的设备：PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [<video src="" control></video>](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   我们必须承认：在网页上阅读没有一点趣味！
*   在通勤途中做些有价值的事情。
*   在沙发上放松时学些新东西。
*   包含实用的面向对象程序设计的伪代码示例。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-1-b.png?id=0877cab2f0102d98cd07b50af0e5beea)](/design-patterns/book) 

### 为什么你应该在通勤途中带着这本电子书？

*   你将在上班路上学些有用的东西。
*   无需互联网连接：随时可用还可进行搜索。
*   可选择多种阅读模式以便轻松阅读。
*   少带一件东西，永远不会忘记。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-4.png?id=87deabea80734585e2cda786f05dd7f6)](/design-patterns/book) 

### 为什么你应该在床上阅读这本电子书？

*   与刷视频相比，它更能更好地激发灵感。
*   与其它选择相比，它能让你更好地放松。
*   与其虚度光阴，还不如做些富有成效的事！
*   提供夜间阅读模式以便轻松阅读。
*   支持一切设备，提供 PDF/EPUB/MOBI/KFX 格式。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/banners/patterns-book-banner-2.png?id=ef3f7b0bdfe11e2cdad1e64a40db87da)](/design-patterns/book) 

### 为什么要购买最优秀的设计模式电子书？

*   **初学者：**学习基础模式及其运作方式！
*   **专家：**可把本书当作一本便捷的、易于搜索的参考书！
*   **与语言无关：**提供 PHP、C# 和 Java 等语言的示例！
*   详细说明 22 个设计模式及其背后的 8 条原则。
*   382 页结构清晰、便于阅读且没有术语的内容。
*   225 幅清晰实用的插图和图表。

[了解更多……](/design-patterns/book) [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

### 为什么我们需要了解设计模式？

*   **轻松应对面试和审核。**关于模式的问题总是一再出现。
*   获得你应得的加薪和升职！
*   **扩展你的工具箱**，在其中添加经过验证且没有问题的代码示例。
*   定制现成的解决方案。不要重新开发所有内容。
*   **更好地与同事沟通**，无需冗长的解释。
*   只需指出设计模式的名称，你就能轻松解决问题！

[了解更多……](/design-patterns/book)

#### 继续阅读

[结构型模式](/design-patterns/structural-patterns) 

#### 返回

 [原型模式](/design-patterns/prototype)

 [![](https://refactoringguru.cn/images/patterns/book/web-cover-en.png?id=328861769fd11617674e3b8a7e2dd9e7)](/design-patterns/book) 

本文是我们的电子书  
**《深入设计模式》**的一部分。

[了解更多……](/design-patterns/book)

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new.png?id=97d554614702483f31e38b32e82d8e34)](/) 

*   [会员专属内容](/store)
    *   [深入设计模式](/design-patterns/book)
    *   [Refactoring Course](/refactoring/course)
*   [设计模式](/design-patterns)
    *   [目录](/design-patterns/catalog)
    *   [创建型模式](/design-patterns/creational-patterns)
        *   [工厂方法模式](/design-patterns/factory-method)
        *   [抽象工厂模式](/design-patterns/abstract-factory)
        *   [生成器模式](/design-patterns/builder)
        *   [原型模式](/design-patterns/prototype)
        *   [单例模式](/design-patterns/singleton)
    *   [结构型模式](/design-patterns/structural-patterns)
        *   [适配器模式](/design-patterns/adapter)
        *   [桥接模式](/design-patterns/bridge)
        *   [组合模式](/design-patterns/composite)
        *   [装饰模式](/design-patterns/decorator)
        *   [外观模式](/design-patterns/facade)
        *   [享元模式](/design-patterns/flyweight)
        *   [代理模式](/design-patterns/proxy)
    *   [行为模式](/design-patterns/behavioral-patterns)
        *   [责任链模式](/design-patterns/chain-of-responsibility)
        *   [命令模式](/design-patterns/command)
        *   [迭代器模式](/design-patterns/iterator)
        *   [中介者模式](/design-patterns/mediator)
        *   [备忘录模式](/design-patterns/memento)
        *   [观察者模式](/design-patterns/observer)
        *   [状态模式](/design-patterns/state)
        *   [策略模式](/design-patterns/strategy)
        *   [模板方法模式](/design-patterns/template-method)
        *   [访问者模式](/design-patterns/visitor)
    *   [示例代码](/design-patterns/examples)
        *   [C#](/design-patterns/csharp)
        *   [C++](/design-patterns/cpp)
        *   [Go](/design-patterns/go)
        *   [Java](/design-patterns/java)
        *   [PHP](/design-patterns/php)
        *   [Python](/design-patterns/python)
        *   [Ruby](/design-patterns/ruby)
        *   [Rust](/design-patterns/rust)
        *   [Swift](/design-patterns/swift)
        *   [TypeScript](/design-patterns/typescript)
*   [重构未翻译](/refactoring)
    *   [What is Refactoring](/refactoring/what-is-refactoring)
        *   [Clean code](/refactoring/what-is-refactoring)
        *   [Technical debt](/refactoring/technical-debt)
        *   [When to refactor](/refactoring/when)
        *   [How to refactor](/refactoring/how-to)
    *   [Catalog](/refactoring/catalog)
    *   [Code Smells](/refactoring/smells)
        *   [Bloaters](/refactoring/smells/bloaters)
            *   [Long Method](/smells/long-method)
            *   [Large Class](/smells/large-class)
            *   [Primitive Obsession](/smells/primitive-obsession)
            *   [Long Parameter List](/smells/long-parameter-list)
            *   [Data Clumps](/smells/data-clumps)
        *   [Object-Orientation Abusers](/refactoring/smells/oo-abusers)
            *   [Switch Statements](/smells/switch-statements)
            *   [Temporary Field](/smells/temporary-field)
            *   [Refused Bequest](/smells/refused-bequest)
            *   [Alternative Classes with Different Interfaces](/smells/alternative-classes-with-different-interfaces)
        *   [Change Preventers](/refactoring/smells/change-preventers)
            *   [Divergent Change](/smells/divergent-change)
            *   [Shotgun Surgery](/smells/shotgun-surgery)
            *   [Parallel Inheritance Hierarchies](/smells/parallel-inheritance-hierarchies)
        *   [Dispensables](/refactoring/smells/dispensables)
            *   [Comments](/smells/comments)
            *   [Duplicate Code](/smells/duplicate-code)
            *   [Lazy Class](/smells/lazy-class)
            *   [Data Class](/smells/data-class)
            *   [Dead Code](/smells/dead-code)
            *   [Speculative Generality](/smells/speculative-generality)
        *   [Couplers](/refactoring/smells/couplers)
            *   [Feature Envy](/smells/feature-envy)
            *   [Inappropriate Intimacy](/smells/inappropriate-intimacy)
            *   [Message Chains](/smells/message-chains)
            *   [Middle Man](/smells/middle-man)
        *   [Other Smells](/refactoring/smells/other)
            *   [Incomplete Library Class](/smells/incomplete-library-class)
    *   [Refactorings](/refactoring/techniques)
        *   [Composing Methods](/refactoring/techniques/composing-methods)
            *   [Extract Method](/extract-method)
            *   [Inline Method](/inline-method)
            *   [Extract Variable](/extract-variable)
            *   [Inline Temp](/inline-temp)
            *   [Replace Temp with Query](/replace-temp-with-query)
            *   [Split Temporary Variable](/split-temporary-variable)
            *   [Remove Assignments to Parameters](/remove-assignments-to-parameters)
            *   [Replace Method with Method Object](/replace-method-with-method-object)
            *   [Substitute Algorithm](/substitute-algorithm)
        *   [Moving Features between Objects](/refactoring/techniques/moving-features-between-objects)
            *   [Move Method](/move-method)
            *   [Move Field](/move-field)
            *   [Extract Class](/extract-class)
            *   [Inline Class](/inline-class)
            *   [Hide Delegate](/hide-delegate)
            *   [Remove Middle Man](/remove-middle-man)
            *   [Introduce Foreign Method](/introduce-foreign-method)
            *   [Introduce Local Extension](/introduce-local-extension)
        *   [Organizing Data](/refactoring/techniques/organizing-data)
            *   [Self Encapsulate Field](/self-encapsulate-field)
            *   [Replace Data Value with Object](/replace-data-value-with-object)
            *   [Change Value to Reference](/change-value-to-reference)
            *   [Change Reference to Value](/change-reference-to-value)
            *   [Replace Array with Object](/replace-array-with-object)
            *   [Duplicate Observed Data](/duplicate-observed-data)
            *   [Change Unidirectional Association to Bidirectional](/change-unidirectional-association-to-bidirectional)
            *   [Change Bidirectional Association to Unidirectional](/change-bidirectional-association-to-unidirectional)
            *   [Replace Magic Number with Symbolic Constant](/replace-magic-number-with-symbolic-constant)
            *   [Encapsulate Field](/encapsulate-field)
            *   [Encapsulate Collection](/encapsulate-collection)
            *   [Replace Type Code with Class](/replace-type-code-with-class)
            *   [Replace Type Code with Subclasses](/replace-type-code-with-subclasses)
            *   [Replace Type Code with State/Strategy](/replace-type-code-with-state-strategy)
            *   [Replace Subclass with Fields](/replace-subclass-with-fields)
        *   [Simplifying Conditional Expressions](/refactoring/techniques/simplifying-conditional-expressions)
            *   [Decompose Conditional](/decompose-conditional)
            *   [Consolidate Conditional Expression](/consolidate-conditional-expression)
            *   [Consolidate Duplicate Conditional Fragments](/consolidate-duplicate-conditional-fragments)
            *   [Remove Control Flag](/remove-control-flag)
            *   [Replace Nested Conditional with Guard Clauses](/replace-nested-conditional-with-guard-clauses)
            *   [Replace Conditional with Polymorphism](/replace-conditional-with-polymorphism)
            *   [Introduce Null Object](/introduce-null-object)
            *   [Introduce Assertion](/introduce-assertion)
        *   [Simplifying Method Calls](/refactoring/techniques/simplifying-method-calls)
            *   [Rename Method](/rename-method)
            *   [Add Parameter](/add-parameter)
            *   [Remove Parameter](/remove-parameter)
            *   [Separate Query from Modifier](/separate-query-from-modifier)
            *   [Parameterize Method](/parameterize-method)
            *   [Replace Parameter with Explicit Methods](/replace-parameter-with-explicit-methods)
            *   [Preserve Whole Object](/preserve-whole-object)
            *   [Replace Parameter with Method Call](/replace-parameter-with-method-call)
            *   [Introduce Parameter Object](/introduce-parameter-object)
            *   [Remove Setting Method](/remove-setting-method)
            *   [Hide Method](/hide-method)
            *   [Replace Constructor with Factory Method](/replace-constructor-with-factory-method)
            *   [Replace Error Code with Exception](/replace-error-code-with-exception)
            *   [Replace Exception with Test](/replace-exception-with-test)
        *   [Dealing with Generalization](/refactoring/techniques/dealing-with-generalization)
            *   [Pull Up Field](/pull-up-field)
            *   [Pull Up Method](/pull-up-method)
            *   [Pull Up Constructor Body](/pull-up-constructor-body)
            *   [Push Down Method](/push-down-method)
            *   [Push Down Field](/push-down-field)
            *   [Extract Subclass](/extract-subclass)
            *   [Extract Superclass](/extract-superclass)
            *   [Extract Interface](/extract-interface)
            *   [Collapse Hierarchy](/collapse-hierarchy)
            *   [Form Template Method](/form-template-method)
            *   [Replace Inheritance with Delegation](/replace-inheritance-with-delegation)
            *   [Replace Delegation with Inheritance](/replace-delegation-with-inheritance)

[登录](https://refactoring.guru/zh/login "登录") [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans "联系我们")

 [![](https://refactoringguru.cn/images/content-public/logos/logo-new-mobile.png?id=ea18aa9b032eaa92835ed6d472b03b4a)](/) [ 我的商店](/store)

*   中文 [English](https://refactoring.guru/design-patterns/singleton "English") [Español](https://refactoring.guru/es/design-patterns/singleton "Español") [Français](https://refactoring.guru/fr/design-patterns/singleton "Français") [日本語](https://refactoring.guru/ja/design-patterns/singleton "日本語") [한국어](https://refactoring.guru/ko/design-patterns/singleton "한국어") [Polski](https://refactoring.guru/pl/design-patterns/singleton "Polski") [Português Brasileiro](https://refactoring.guru/pt-br/design-patterns/singleton "Português Brasileiro") [Русский](https://refactoring.guru/ru/design-patterns/singleton "Русский") [Українська](https://refactoring.guru/uk/design-patterns/singleton "Українська") [中文](https://refactoringguru.cn/design-patterns/singleton "中文")
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true "联系我们")
*   [登录](https://refactoring.guru/zh/login "登录")

*   [主页](/)
*   [重构](/refactoring)
*   [设计模式](/design-patterns)
*   [会员专属内容](/store)
*   [论坛](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans)
*   [联系我们](https://feedback.refactoring.guru/communities/39-chinese?lang=zh-hans&show_feedback_form_private=true)

2014-2023 [Refactoring.Guru](/). 版权所有  
图片作者： [Dmitry Zhart](http://zhart.us/) **Ukrainian office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) FOP Olga Skobeleva  
Abolmasova 7  
Kyiv, Ukraine, 02002  
Email: support@refactoring.guru **Spanish office:**  
 ![](https://refactoringguru.cn/images/content-public/icons/fa-building.svg?id=afddb5806968b0a9acfc1df75a181234) Oleksandr Shvets  
Avda Pamplona 63, 4b  
Pamplona, Spain, 31010  
Email: spain@refactoring.guru

*   [条款与政策](/terms)
*   [隐私政策](/privacy-policy)
*   [内容使用政策](/content-usage-policy)
*   [About us](/site-about)