> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [refactoringguru.cn](https://refactoringguru.cn/design-patterns/singleton)



问题
--

单例模式同时解决了两个问题， 所以违反了_单一职责原则_：

1.  **保证一个类只有一个实例**。 
	最常见的原因是控制某些共享资源 （例如数据库或文件） 的访问权限。
2.  **为该实例提供一个全局访问节点**。 。
    和全局变量一样， 单例模式也允许在程序的任何地方访问特定对象。 但是它可以保护该实例不被其他代码覆盖。
    如果你需要更加严格地控制全局变量， 可以使用单例模式。

解决方案
----
所有单例的实现都包含以下两个相同的步骤：
*   将默认构造函数设为私有， 防止其他对象使用单例类的 `new`运算符。
*   新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。

如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。


单例模式结构
------
![](https://refactoringguru.cn/images/patterns/diagrams/singleton/structure-zh-indexed.png)

1.  **单例** （Singleton） 类声明了一个名为 `get­Instance`获取实例的静态方法来返回其所属类的一个相同实例。
2. 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 `获取实例`方法必须是获取单例对象的唯一方式。

单例模式优缺点
-------
*   该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。
*   单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。

与其他模式的关系
--------
*   如果你能将对象的所有共享状态简化为一个享元对象， 那么[享元模式](/design-patterns/flyweight)就和[单例](/design-patterns/singleton)类似了。 
* 但这两个模式有两个根本性的不同。
    1.  单例实体只会有一个， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。
    2.  _单例_对象可以是可变的。 享元对象是不可变的。


 Q1 - Technology-facing tests that support the 
team
– Q2 - Business-facing 
tests that support the 
team
– Q3 - Business-facing 
tests that critique the 
product
– Q4 - Technology-facing